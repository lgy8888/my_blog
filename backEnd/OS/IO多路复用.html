<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.0" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.2" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://vuepress-theme-hope-docs-demo.netlify.app/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html"><meta property="og:site_name" content="林光远的个人笔记"><meta property="og:title" content="IO多路复用"><meta property="og:description" content="Socket 要想客户端和服务器能在网络中通信，必须得使用 Socket 编程，它是进程间通信里比较特别的方式：支持跨主机间通信。 创建 Socket 的时候，可以指定网络层使用的是 IPv4 还是 IPv6，传输层使用的是 TCP 还是 UDP 基于TCP的Socket编程 服务器的程序要先跑起来，然后等待客户端的连接和数据 服务端 服务端首先调用 ..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="LGYNB"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"IO多路复用","image":[""],"dateModified":null,"author":[{"@type":"Person","name":"LGYNB","url":"/"}]}</script><link rel="icon" href="/my_blog/favicon.ico"><title>IO多路复用 | 林光远的个人笔记</title><meta name="description" content="Socket 要想客户端和服务器能在网络中通信，必须得使用 Socket 编程，它是进程间通信里比较特别的方式：支持跨主机间通信。 创建 Socket 的时候，可以指定网络层使用的是 IPv4 还是 IPv6，传输层使用的是 TCP 还是 UDP 基于TCP的Socket编程 服务器的程序要先跑起来，然后等待客户端的连接和数据 服务端 服务端首先调用 ...">
    <link rel="preload" href="/my_blog/assets/style-ERUp4lUP.css" as="style"><link rel="stylesheet" href="/my_blog/assets/style-ERUp4lUP.css">
    <link rel="modulepreload" href="/my_blog/assets/app-OTaO6_y0.js"><link rel="modulepreload" href="/my_blog/assets/IO多路复用.html-cLhjVP4W.js"><link rel="modulepreload" href="/my_blog/assets/IO多路复用.html-0m7pP72G.js"><link rel="modulepreload" href="/my_blog/assets/plugin-vue_export-helper-x3n3nnut.js">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand vp-brand" href="/my_blog/"><img class="vp-nav-logo" src="/my_blog/logo.png" alt="林光远的个人笔记"><!----><span class="vp-site-name hide-in-pad">林光远的个人笔记</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a aria-label="后端技术" class="vp-link nav-link active nav-link active" href="/my_blog/backEnd/"><span class="font-icon icon iconfont icon-back-stage" style=""></span>后端技术<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="Web开发" class="vp-link nav-link nav-link" href="/my_blog/webDevelop/"><span class="font-icon icon iconfont icon-config" style=""></span>Web开发<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="AI技术" class="vp-link nav-link nav-link" href="/my_blog/ai/"><span class="font-icon icon iconfont icon-function" style=""></span>AI技术<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="数据结构与算法" class="vp-link nav-link nav-link" href="/my_blog/coding/"><span class="font-icon icon iconfont icon-calculate" style=""></span>数据结构与算法<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="项目经历" class="vp-link nav-link nav-link" href="/my_blog/projects/"><span class="font-icon icon iconfont icon-code" style=""></span>项目经历<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/lgy8888/my_blog.git" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索本站" autocomplete="off" spellcheck="false" value><!----></form><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-cache" style=""></span><span class="vp-sidebar-title">Redis</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-mysql" style=""></span><span class="vp-sidebar-title">MySQL</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-java" style=""></span><span class="vp-sidebar-title">Java</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><span class="font-icon icon iconfont icon-OS" style=""></span><span class="vp-sidebar-title">OS</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a aria-label="内存管理" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/OS/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><span class="font-icon icon iconfont icon-write" style=""></span>内存管理<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="IO多路复用" class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active nav-link active vp-sidebar-link vp-sidebar-page active" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html"><span class="font-icon icon iconfont icon-write" style=""></span>IO多路复用<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="Socket" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#socket"><!---->Socket<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="基于TCP的Socket编程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#基于tcp的socket编程"><!---->基于TCP的Socket编程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Socket文件描述符" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#socket文件描述符"><!---->Socket文件描述符<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="服务更多的用户" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#服务更多的用户"><!---->服务更多的用户<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="C10K" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#c10k"><!---->C10K<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="多进程模型" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#多进程模型"><!---->多进程模型<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="运行流程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#运行流程"><!---->运行流程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="存在问题" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#存在问题"><!---->存在问题<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="多线程模型" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#多线程模型"><!---->多线程模型<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="线程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#线程"><!---->线程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="运行流程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#运行流程-1"><!---->运行流程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="存在问题" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#存在问题-1"><!---->存在问题<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="I/O多路复用" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#i-o多路复用"><!---->I/O多路复用<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="select/poll" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#select-poll"><!---->select/poll<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="epoll" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#epoll"><!---->epoll<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Reactor" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#reactor"><!---->Reactor<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="两个核心部分" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#两个核心部分"><!---->两个核心部分<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="灵活多变的Reactor" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#灵活多变的reactor"><!---->灵活多变的Reactor<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="三种经典的Reactor方案" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#三种经典的reactor方案"><!---->三种经典的Reactor方案<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Proactor" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#proactor"><!---->Proactor<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="涉及概念" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#涉及概念"><!---->涉及概念<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Reactor和Proactor的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#reactor和proactor的区别"><!---->Reactor和Proactor的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Proactor模式" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#proactor模式"><!---->Proactor模式<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="实用场景" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#实用场景"><!---->实用场景<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a aria-label="CPU Cache" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/OS/CPU%20Cache.html"><span class="font-icon icon iconfont icon-write" style=""></span>CPU Cache<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->IO多路复用</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="/" target="_blank" rel="noopener noreferrer">LGYNB</a></span><span property="author" content="LGYNB"></span></span><!----><!----><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 28 分钟</span><meta property="timeRequired" content="PT28M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#socket">Socket</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#基于tcp的socket编程">基于TCP的Socket编程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#socket文件描述符">Socket文件描述符</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#服务更多的用户">服务更多的用户</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#c10k">C10K</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#多进程模型">多进程模型</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#运行流程">运行流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#存在问题">存在问题</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#多线程模型">多线程模型</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#线程">线程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#运行流程-1">运行流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#存在问题-1">存在问题</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#i-o多路复用">I/O多路复用</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#select-poll">select/poll</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#epoll">epoll</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#reactor">Reactor</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#两个核心部分">两个核心部分</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#灵活多变的reactor">灵活多变的Reactor</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#三种经典的reactor方案">三种经典的Reactor方案</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#proactor">Proactor</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#涉及概念">涉及概念</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#reactor和proactor的区别">Reactor和Proactor的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#proactor模式">Proactor模式</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#实用场景">实用场景</a></li><!----><!--]--></ul></li><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h1 id="io多路复用" tabindex="-1"><a class="header-anchor" href="#io多路复用" aria-hidden="true">#</a> IO多路复用</h1><h2 id="socket" tabindex="-1"><a class="header-anchor" href="#socket" aria-hidden="true">#</a> Socket</h2><p>要想客户端和服务器能在网络中通信，必须得使用 Socket 编程，它是进程间通信里比较特别的方式：支持跨主机间通信。</p><p>创建 Socket 的时候，可以指定网络层使用的是 IPv4 还是 IPv6，传输层使用的是 TCP 还是 UDP</p><h3 id="基于tcp的socket编程" tabindex="-1"><a class="header-anchor" href="#基于tcp的socket编程" aria-hidden="true">#</a> 基于TCP的Socket编程</h3><p>服务器的程序要先跑起来，然后等待客户端的连接和数据</p><p><strong>服务端</strong></p><p>服务端首先调用 <code>socket()</code> 函数，创建网络协议为 IPv4，以及传输协议为 TCP 的 Socket</p><p>接着调用 <code>bind()</code> 函数，给这个 Socket 绑定一个 <strong>IP 地址和端口</strong></p><ul><li><strong>绑定端口的目的</strong>：当内核收到 TCP 报文，通过 TCP 头里面的端口号，来找到我们的应用程序，然后把数据传递给我们。</li><li><strong>绑定 IP 地址的目的</strong>：一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址，当绑定一个网卡时，内核在收到该网卡上的包，才会发给我们</li></ul><p>绑定完 IP 地址和端口后，就可以调用 <code>listen()</code> 函数进行监听，此时对应 TCP 状态图中的 <code>listen</code></p><ul><li>如果我们要判定服务器中一个网络程序有没有启动，可以通过 <code>netstat</code> 命令查看对应的端口号是否有被监听。</li></ul><p>服务端进入了监听状态后，通过调用 <code>accept()</code> 函数，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。</p><p><strong>客户端</strong></p><p>客户端在创建好 Socket 后，调用 <code>connect()</code> 函数发起连接，该函数的参数要指明服务端的 IP 地址和端口号</p><p>然后万众期待的 TCP 三次握手就开始了</p><p>在 TCP 连接的过程中，服务器的内核实际上<strong>为每个 Socket 维护了两个队列</strong>：</p><ul><li>一个是「还没完全建立」连接的队列，称为 <strong>TCP 半连接队列</strong>，这个队列都是没有完成三次握手的连接，此时服务端处于 <code>syn_rcvd</code> 的状态；</li><li>一个是「已经建立」连接的队列，称为 <strong>TCP 全连接队列</strong>，这个队列都是完成了三次握手的连接，此时服务端处于 <code>established</code> 状态；</li></ul><p>当 TCP 全连接队列不为空后，服务端的 <code>accept()</code> 函数，就会从内核中的 TCP 全连接队列里<strong>拿出一个已经完成连接的 Socket 返回应用程序，后续数据传输都用这个 Socket</strong>。</p><p><strong>Socket分为两个</strong>：</p><ul><li>一个叫作<strong>监听 Socket</strong>；</li><li>一个叫作<strong>已连接 Socket</strong>；</li></ul><p>连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过 <code>read()</code> 和 <code>write()</code> 函数来读写数据。</p><p>至此， TCP 协议的 Socket 程序的调用过程就结束了</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/view-16996876702733.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="socket文件描述符" tabindex="-1"><a class="header-anchor" href="#socket文件描述符" aria-hidden="true">#</a> Socket文件描述符</h3><p>基于Linux一切皆文件的理念，在内核中，Socket也是以文件的形式存在的，也有对应的文件描述符</p><p><strong>Socket在本机中可以通过文件描述符进行传输，获得Socket文件描述符的程序可以与客户端进行通信</strong></p><h2 id="服务更多的用户" tabindex="-1"><a class="header-anchor" href="#服务更多的用户" aria-hidden="true">#</a> 服务更多的用户</h2><p><strong>TCP Socket</strong> 调用流程是最简单、最基本的，它<strong>基本只能一对一通信，因为使用的是同步阻塞的方式</strong>，当服务端在还没处理完一个客户端的网络 I/O 时，或者 读写操作发生阻塞时，其他客户端是无法与服务端连接的。</p><p><strong>服务器单机理论最大能连接多少个客户端</strong></p><ul><li>TCP 连接是由四元组唯一确认的，这个四元组就是：<strong>本机IP, 本机端口, 对端IP, 对端端口</strong>。</li><li>服务器作为服务方，通常会在本地固定监听一个端口，等待客户端的连接。因此服务器的本地 IP 和端口是固定的，于是对于服务端 TCP 连接的四元组只有对端 IP 和端口是会变化的</li><li><strong>最大 TCP 连接数 = 客户端 IP 数×客户端端口数</strong>。</li><li>对于 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是<strong>服务端单机最大 TCP 连接数约为 2 的 48 次方</strong>。</li></ul><p>这个理论值相当“丰满”，但是<strong>服务器肯定承载不了那么大的连接数</strong>，主要会受<strong>两个方面的限制</strong>：</p><ul><li><strong>文件描述符</strong>，Socket 实际上是一个文件，也就会对应一个文件描述符。在 Linux 下，单个进程打开的文件描述符数是有限制的，没有经过修改的值一般都是 1024，不过我们可以通过 ulimit 增大文件描述符的数目；</li><li><strong>系统内存</strong>，每个 TCP 连接在内核中都有对应的数据结构，意味着每个连接都是会占用一定内存的；</li></ul><h3 id="c10k" tabindex="-1"><a class="header-anchor" href="#c10k" aria-hidden="true">#</a> C10K</h3><p>那如果服务器的内存只有 2 GB，网卡是千兆的，能支持并发 1 万请求吗？</p><p><strong>并发 1 万请求，也就是经典的 C10K 问题</strong> ，C 是 Client 单词首字母缩写，C10K 就是单机同时处理 1 万个请求的问题。</p><p>从硬件资源角度看，对于 2GB 内存千兆网卡的服务器，如果每个请求处理占用不到 200KB 的内存和 100Kbit 的网络带宽就可以满足并发 1 万个请求。</p><p>不过，要想真正实现 C10K 的服务器，要考虑的地方在于<strong>服务器的网络 I/O 模型</strong>，效率低的模型，会加重系统开销，从而会离 C10K 的目标越来越远。</p><h2 id="多进程模型" tabindex="-1"><a class="header-anchor" href="#多进程模型" aria-hidden="true">#</a> 多进程模型</h2><p>基于最原始的阻塞网络 I/O， 如果服务器要支持多个客户端，其中比较传统的方式，就是使用<strong>多进程模型</strong>，也就是<strong>为每个客户端分配一个进程来处理请求</strong>。</p><h3 id="运行流程" tabindex="-1"><a class="header-anchor" href="#运行流程" aria-hidden="true">#</a> 运行流程</h3><p><strong>服务器的主进程负责监听客户的连接</strong>，一旦与客户端连接完成，accept() 函数就会返回一个「已连接 Socket」，这时就通过 <code>fork()</code> 函数<strong>创建一个子进程</strong></p><blockquote><p>fork一个子进程，实际上就把父进程所有相关的东西都<strong>复制</strong>一份，包括文件描述符、内存地址空间、程序计数器、执行的代码等。</p><p>这两个进程刚复制完的时候，几乎一模一样。不过，会根据<strong>返回值</strong>来区分是父进程还是子进程，如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。</p></blockquote><p>子进程会<strong>复制父进程的文件描述符</strong>，可以直接使用「已连接 Socket 」和客户端通信了，</p><p>子进程跟父进程各自关注一个Socket：</p><ul><li><strong>子进程不需要关心「监听 Socket」，只需要关心「已连接 Socket」</strong></li><li>父进程则相反，将客户服务交给子进程来处理，因此<strong>父进程不需要关心「已连接 Socket」，只需要关心「监听 Socket」</strong>。</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/epoll.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="存在问题" tabindex="-1"><a class="header-anchor" href="#存在问题" aria-hidden="true">#</a> 存在问题</h3><h4 id="僵尸进程" tabindex="-1"><a class="header-anchor" href="#僵尸进程" aria-hidden="true">#</a> 僵尸进程</h4><ul><li>当「子进程」退出时，<strong>实际上内核里还会保留该进程的一些信息</strong>，也是会占用内存的，如果不做好“回收”工作，就会变成<strong>僵尸进程</strong>，随着僵尸进程越多，会慢慢耗尽我们的系统资源。</li><li>有<strong>两种方式可以在子进程退出后回收资源</strong>，分别是调用 <code>wait()</code> 和 <code>waitpid()</code> 函数</li></ul><h4 id="进程间上下文切换" tabindex="-1"><a class="header-anchor" href="#进程间上下文切换" aria-hidden="true">#</a> 进程间上下文切换</h4><p>这种用多个进程来应付多个客户端的方式，在应对 100 个客户端还是可行的，但是当客户端数量高达一万时，肯定扛不住的，因为<strong>每产生一个进程，必会占据一定的系统资源，而且进程间上下文切换的“包袱”是很重的，性能会大打折扣</strong>。</p><blockquote><p>进程的上下文切换不仅包含了<strong>虚拟内存、栈、全局变量等用户空间的资源</strong>，还包括了<strong>内核堆栈、寄存器等内核空间的资源</strong>。</p></blockquote><h2 id="多线程模型" tabindex="-1"><a class="header-anchor" href="#多线程模型" aria-hidden="true">#</a> 多线程模型</h2><p>既然进程间上下文切换的“包袱”很重，那我们就搞个比较轻量级的模型来应对多用户的请求 —— <strong>多线程模型</strong>。</p><h3 id="线程" tabindex="-1"><a class="header-anchor" href="#线程" aria-hidden="true">#</a> 线程</h3><p>线程是运行在进程中的一个“逻辑流”，<strong>单进程中可以运行多个线程，同进程里的线程可以共享进程的部分资源</strong>，比如文件描述符列表、进程空间、代码、全局数据、堆、共享库等，<strong>这些共享些资源在上下文切换时不需要切换，而只需要切换线程的私有数据、寄存器等不共享的数据</strong>，因此同一个进程下的线程上下文切换的开销要比进程小得多。</p><h3 id="运行流程-1" tabindex="-1"><a class="header-anchor" href="#运行流程-1" aria-hidden="true">#</a> 运行流程</h3><p>当服务器与客户端 TCP 完成连接后，通过 <code>pthread_create()</code> 函数创建线程，然后<strong>将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信</strong>，从而达到并发处理的目的。</p><p>频繁创建和销毁线程，系统开销也是不小的。使用<strong>线程池</strong>的方式可以避免线程的频繁创建和销毁</p><p>所谓的线程池，就是<strong>提前创建若干个线程</strong>，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后<strong>线程池里的线程负责从队列中取出「已连接 Socket 」进行处理</strong>。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/多进程-16994219058748.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="存在问题-1" tabindex="-1"><a class="header-anchor" href="#存在问题-1" aria-hidden="true">#</a> 存在问题</h3><p>需要注意的是，<strong>这个队列是全局的，每个线程都会操作，为了避免多线程竞争，线程在操作这个队列前要加锁。</strong></p><p>上面基于进程或者线程模型的，其实还是有问题的。<strong>新到来一个 TCP 连接，就需要分配一个进程或者线程</strong>，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程/线程，操作系统就算死扛也是扛不住的</p><h2 id="i-o多路复用" tabindex="-1"><a class="header-anchor" href="#i-o多路复用" aria-hidden="true">#</a> I/O多路复用</h2><p><strong>I/O 多路复用</strong>就是只使用一个进程来维护多个 Socket</p><p>一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。</p><p><strong>进程可以通过一个系统调用函数从内核中获取多个事件</strong>。</p><h3 id="select-poll" tabindex="-1"><a class="header-anchor" href="#select-poll" aria-hidden="true">#</a> select/poll</h3><h4 id="select-实现多路复用的方式" tabindex="-1"><a class="header-anchor" href="#select-实现多路复用的方式" aria-hidden="true">#</a> select 实现多路复用的方式</h4><ol><li>将已连接的 Socket 都放到一个<strong>文件描述符集合</strong></li><li>调用 select 函数将文件描述符集合<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生 <ul><li>检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式</li></ul></li><li>当检查到有事件产生后，将此 Socket 标记为可读或可写</li><li>再把整个文件描述符集合<strong>拷贝</strong>回用户态里</li><li>用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。</li></ol><p>所以，对于 select 这种方式，需要进行 <strong>2 次「遍历」文件描述符集合</strong>，一次是在内核态里，一个次是在用户态里 ，而且还会发生 <strong>2 次「拷贝」文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p><h4 id="select和pool的异同" tabindex="-1"><a class="header-anchor" href="#select和pool的异同" aria-hidden="true">#</a> select和pool的异同</h4><p><strong>select 使用固定长度的 BitsMap，表示文件描述符集合</strong>，而且<strong>所支持的文件描述符的个数是有限制的</strong>，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 <code>1024</code>，只能监听 0~1023 的文件描述符。</p><p><strong>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制</strong>，当然还<strong>会受到系统文件描述符限制</strong>。</p><p>但是 poll 和 select 并没有太大的本质区别，<strong>都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</strong></p><p>这种方式随着并发数上来，性能的损耗会呈指数级增长。</p><h3 id="epoll" tabindex="-1"><a class="header-anchor" href="#epoll" aria-hidden="true">#</a> epoll</h3><p>epoll_create创建一个epoll对象epfd</p><p>epfd对象中维护了一棵红黑树，用于跟踪进程中所有待检测的fd</p><p>通过epoll_ctl将需要监听的Socket添加到epfd的红黑树中</p><p>一旦事件触发，epfd会将触发的事件从红黑树中取出，放进就绪事件列表中</p><p>最后调用epoll_wait从就绪事件列表中获取数据</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/线程池.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="解决问题" tabindex="-1"><a class="header-anchor" href="#解决问题" aria-hidden="true">#</a> 解决问题</h4><p>epoll通过两个方面很好的解决了select/poll问题</p><ul><li>epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 <code>O(logn)</code><ul><li>select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核</li><li>epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</li></ul></li><li>epoll 使用<strong>事件驱动</strong>的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件列表中 <ul><li>当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</li></ul></li></ul><p>epoll 的方式即使监听的 Socket 数量越多的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数。因而，<strong>epoll 被称为解决 C10K 问题的利器</strong>。</p><h4 id="边缘触发和水平触发" tabindex="-1"><a class="header-anchor" href="#边缘触发和水平触发" aria-hidden="true">#</a> 边缘触发和水平触发</h4><p>epoll 支持两种事件触发模式，分别是<strong>边缘触发（edge-triggered，ET）和水平触发（level-triggered，LT）</strong></p><ul><li>使用<strong>边缘触发模式</strong>时，当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完； <ul><li>水平触发的意思是只要满足事件的条件，比如内核中有数据需要读，就一直不断地把这个事件传递给用户</li></ul></li><li>使用<strong>水平触发模式</strong>时，当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong>，目的是告诉我们有数据需要读取； <ul><li>边缘触发的意思是只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。</li></ul></li></ul><blockquote><p>举个例子，你的快递被放到了一个快递箱里，如果快递箱只会通过短信通知你一次，即使你一直没有去取，它也不会再发送第二条短信提醒你，这个方式就是边缘触发；如果快递箱发现你的快递没有被取出，它就会不停地发短信通知你，直到你取出了快递，它才消停，这个就是水平触发的方式。</p></blockquote><p>如果使用水平触发模式，当内核通知文件描述符可读写时，接下来还可以继续去检测它的状态，看它是否依然可读或可写。所以在收到通知后，没必要一次执行尽可能多的读写操作。</p><p>如果使用边缘触发模式，I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会<strong>循环</strong>从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。</p><p>所以，<strong>边缘触发模式一般和非阻塞 I/O 搭配使用</strong>，程序会一直执行 I/O 操作，直到系统调用（如 <code>read</code> 和 <code>write</code>）返回错误，错误类型为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</p><p>一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。</p><p>select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。</p><p><strong>使用 I/O 多路复用时，最好搭配非阻塞 I/O 一起使用</strong></p><blockquote><p><strong>多路复用 API 返回的事件并不一定可读写的</strong>，如果使用阻塞 I/O， 那么在调用 read/write 时则会发生程序阻塞，因此最好搭配非阻塞 I/O，以便应对极少数的特殊情况。</p></blockquote><h2 id="reactor" tabindex="-1"><a class="header-anchor" href="#reactor" aria-hidden="true">#</a> Reactor</h2><p>I/0多路复用监听事件，收到事件后，根据事件类型分配给某个进程/线程</p><h3 id="两个核心部分" tabindex="-1"><a class="header-anchor" href="#两个核心部分" aria-hidden="true">#</a> 两个核心部分</h3><p>Reactor模式主要由Reactor和处理资源池两个核心部分组成</p><ul><li>Reactor负责监听和分发事件，事件类型包含连接事件、读写事件</li><li>处理资源池负责处理事件，如read -&gt; 业务逻辑 -&gt; send</li></ul><h3 id="灵活多变的reactor" tabindex="-1"><a class="header-anchor" href="#灵活多变的reactor" aria-hidden="true">#</a> 灵活多变的Reactor</h3><ul><li>Reactor的数量可以只有一个，也可以存在多个</li><li>处理资源池可以是单个进程/线程，也可以是多个进程/线程</li></ul><h3 id="三种经典的reactor方案" tabindex="-1"><a class="header-anchor" href="#三种经典的reactor方案" aria-hidden="true">#</a> 三种经典的Reactor方案</h3><p>两种因素排列组合以下，理论上有四种方案可供选择</p><ul><li>单 Reactor 单进程 / 线程；</li><li>单 Reactor 多进程 / 线程；</li><li>多 Reactor 单进程 / 线程；</li><li>多 Reactor 多进程 / 线程；</li></ul><p>由于[多 Reactor 单进程 / 线程]实现方案相比[单 Reactor 单进程 / 线程]方案，不仅复杂而且也没有性能优势，因此实际中并没有应用。</p><p>其他三种方案在实际项目中都有不同的应用</p><ul><li><strong>单 Reactor 单进程 / 线程；</strong></li><li><strong>单 Reactor 多线程 / 进程；</strong></li><li><strong>多 Reactor 多进程 / 线程；</strong></li></ul><p>方案具体使用进程还是线程，要看使用的编程语言以及平台</p><ul><li>Java 语言一般使用线程，比如 Netty;</li><li>C 语言使用进程和线程都可以，例如 Nginx 使用的是进程，Memcache 使用的是线程。</li></ul><h4 id="单-reactor-单进程-线程" tabindex="-1"><a class="header-anchor" href="#单-reactor-单进程-线程" aria-hidden="true">#</a> 单 Reactor 单进程 / 线程</h4><p><strong>C</strong> 语言实现的是「<strong>单 Reactor 单进程</strong>」的方案，因为 C 语言编写完的程序，运行后就是一个独立的进程，不需要在进程中再创建线程。</p><p><strong>Java</strong> 语言实现的是「<strong>单 Reactor 单线程</strong>」的方案，因为 Java 程序是跑在 Java 虚拟机这个进程上面的，虚拟机中有很多线程，我们写的 Java 程序只是其中的一个线程而已。</p><p><strong>Redis</strong> 是由 C 语言实现的，在 Redis 6.0 版本之前采用的正是「<strong>单 Reactor 单进程</strong>」的方案，因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 Redis 对于命令的处理是单进程的方案。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/单Reactor单进程.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h5 id="涉及对象和方法" tabindex="-1"><a class="header-anchor" href="#涉及对象和方法" aria-hidden="true">#</a> 涉及对象和方法</h5><p>进程里有 <strong>Reactor、Acceptor、Handler</strong> 这三个对象：</p><ul><li>Reactor 对象的作用是<strong>监听和分发事件</strong>；</li><li>Acceptor 对象的作用是<strong>获取连接</strong>；</li><li>Handler 对象的作用是<strong>处理业务</strong>；</li></ul><p>select、accept、read、send 是系统调用函数</p><p>dispatch 和 「业务处理」是需要完成的操作，其中 dispatch 是分发事件操作。</p><h5 id="方案流程" tabindex="-1"><a class="header-anchor" href="#方案流程" aria-hidden="true">#</a> 方案流程</h5><ul><li>Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；</li><li>如果是<strong>连接建立的事件</strong>，则交由 <strong>Acceptor对象</strong>进行处理，Acceptor 对象会<strong>通过 accept 方法获取连接，并创建一个 Handler 对象来处理</strong>后续的响应事件；</li><li>如果<strong>不是连接建立事件</strong>， 则交由当前连接对应的 <strong>Handler 对象</strong>来进行响应；</li><li>Handler 对象通过 <strong>read -&gt; 业务处理 -&gt; send</strong> 的流程来完成完整的业务流程。</li></ul><p>单 Reactor 单进程的方案因为<strong>全部工作都在同一个进程内完成</strong>，所以实现起来比较<strong>简单</strong>，<strong>不需要考虑进程间通信，也不用担心多进程竞争</strong>。</p><h5 id="两个缺点" tabindex="-1"><a class="header-anchor" href="#两个缺点" aria-hidden="true">#</a> 两个缺点</h5><ul><li>因为只有一个进程，<strong>无法充分利用 多核 CPU 的性能</strong>；</li><li>Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，<strong>如果业务处理耗时比较长，那么就造成响应的延迟</strong>；</li></ul><p>所以，单 Reactor 单进程的方案<strong>不适用计算机密集型的场景，只适用于业务处理非常快速的场景</strong>。</p><h4 id="单-reactor-多线程-多进程" tabindex="-1"><a class="header-anchor" href="#单-reactor-多线程-多进程" aria-hidden="true">#</a> 单 Reactor 多线程 / 多进程</h4><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/单Reactor多线程-16993689007235.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h5 id="单-reactor-多线程" tabindex="-1"><a class="header-anchor" href="#单-reactor-多线程" aria-hidden="true">#</a> 单 Reactor 多线程</h5><ul><li>Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；</li><li>如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；</li><li>如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；</li></ul><p>上面的三个步骤和单 Reactor 单线程方案是一样的，<strong>接下来的步骤就开始不一样</strong>了：</p><ul><li><strong>Handler 对象不再负责业务处理，只负责数据的接收和发送</strong>，Handler 对象通过 read 读取到数据后，会将数据发给子线程里的 Processor 对象进行业务处理；</li><li><strong>子线程里的 Processor 对象就进行业务处理</strong>，处理完后，<strong>将结果发给主线程中的 Handler 对象</strong>，接着由 <strong>Handler 通过 send 方法将响应结果发送给 client</strong>；</li></ul><h5 id="多线程共享资源竞争" tabindex="-1"><a class="header-anchor" href="#多线程共享资源竞争" aria-hidden="true">#</a> 多线程共享资源竞争</h5><p>单 Reator 多线程的方案优势在于<strong>能够充分利用多核 CPU 的能力</strong>，那既然引入多线程，那么自然就带来了多线程竞争资源的问题。</p><p>子线程完成业务处理后，要把结果传递给主线程的 Handler 进行发送，这里就涉及共享数据的竞争</p><p>要避免多线程由于<strong>竞争共享资源而导致数据错乱</strong>的问题，就需要在操作共享资源前加上互斥锁，以<strong>保证任意时间里只有一个线程在操作共享资源</strong>，待该线程操作完释放互斥锁后，其他线程才有机会操作共享数据。</p><h5 id="单-reactor-多进程" tabindex="-1"><a class="header-anchor" href="#单-reactor-多进程" aria-hidden="true">#</a> 单 Reactor 多进程</h5><p>单 Reactor 多进程相比单 Reactor 多线程实现起来更麻烦</p><p>主要因为<strong>要考虑子进程和父进程的双向通信</strong>，并且<strong>父进程还得知道子进程要将数据发送给哪个客户端</strong>。</p><p>而多线程间可以共享数据，虽然要额外考虑并发问题，但是这远比进程间通信的复杂度低得多，因此<strong>实际应用中也看不到单 Reactor 多进程的模式</strong>。</p><h5 id="存在问题-2" tabindex="-1"><a class="header-anchor" href="#存在问题-2" aria-hidden="true">#</a> 存在问题</h5><p>因为<strong>一个 Reactor</strong> 对象承担所有事件的监听和响应，而且只在主线程中运行，在<strong>面对瞬间高并发的场景时，容易成为性能的瓶颈的地方</strong>。</p><h4 id="多-reactor-多进程-线程" tabindex="-1"><a class="header-anchor" href="#多-reactor-多进程-线程" aria-hidden="true">#</a> 多 Reactor 多进程 / 线程</h4><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/主从Reactor多线程.png" alt="主从Reactor多线程" tabindex="0" loading="lazy"><figcaption>主从Reactor多线程</figcaption></figure><h5 id="方案流程-1" tabindex="-1"><a class="header-anchor" href="#方案流程-1" aria-hidden="true">#</a> 方案流程</h5><ul><li>主线程中的 <strong>MainReactor 对象</strong>通过 select <strong>监控连接建立事件</strong>，收到事件后通过 <strong>Acceptor 对象</strong>中的 accept <strong>获取连接</strong>，将新的连接<strong>分配</strong>给某个子线程；</li><li>子线程中的 <strong>SubReactor 对象将 MainReactor 对象分配的连接加入 select 继续进行监听</strong>，并<strong>创建一个 Handler 用于处理连接的响应事件</strong>。</li><li>如果有<strong>新的事件发生</strong>时，<strong>SubReactor 对象会调用当前连接对应的 Handler 对象</strong>来进行响应。</li><li><strong>Handler 对象</strong>通过 read -&gt; 业务处理 -&gt; send 的流程来<strong>完成完整的业务流程</strong>。</li></ul><h5 id="实现简单" tabindex="-1"><a class="header-anchor" href="#实现简单" aria-hidden="true">#</a> 实现简单</h5><ul><li><strong>主线程和子线程分工明确</strong>，主线程只负责接收新连接，子线程负责完成后续的业务处理。</li><li><strong>主线程和子线程的交互很简单</strong>，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。</li></ul><p>两个开源软件 Netty 和 Memcache 都采用了「多 Reactor 多线程」的方案。</p><p>采用了「多 Reactor 多进程」方案的开源软件是 Nginx，不过方案与标准的多 Reactor 多进程有些差异。</p><blockquote><p>具体差异表现在主进程中仅仅用来初始化 socket，并没有创建 mainReactor 来 accept 连接，而是由子进程的 Reactor 来 accept 连接，通过锁来控制一次只有一个子进程进行 accept（防止出现惊群现象），子进程 accept 新连接后就放到自己的 Reactor 进行处理，不会再分配给其他子进程。</p></blockquote><h2 id="proactor" tabindex="-1"><a class="header-anchor" href="#proactor" aria-hidden="true">#</a> Proactor</h2><p>Reactor 是非阻塞同步网络模式，而 <strong>Proactor 是异步网络模式</strong></p><h3 id="涉及概念" tabindex="-1"><a class="header-anchor" href="#涉及概念" aria-hidden="true">#</a> 涉及概念</h3><h4 id="阻塞i-o" tabindex="-1"><a class="header-anchor" href="#阻塞i-o" aria-hidden="true">#</a> 阻塞I/O</h4><p>当用户程序执行 <code>read</code> ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，<code>read</code> 才会返回。</p><ul><li>阻塞等待的是「<strong>内核数据准备好</strong>」和「<strong>数据从内核态拷贝到用户态</strong>」这两个过程</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240227113134835.png" alt="image-20240227113134835" tabindex="0" loading="lazy"><figcaption>image-20240227113134835</figcaption></figure><h4 id="非阻塞-i-o" tabindex="-1"><a class="header-anchor" href="#非阻塞-i-o" aria-hidden="true">#</a> 非阻塞 I/O</h4><p>非阻塞的 <code>read</code> 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，<code>read</code> 调用才可以获取到结果</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240227113156556.png" alt="image-20240227113156556" tabindex="0" loading="lazy"><figcaption>image-20240227113156556</figcaption></figure><ul><li>这里<strong>最后一次 read 调用，获取数据的过程</strong>，是一个<strong>同步</strong>的过程，<strong>是需要等待的过程</strong>。这里的同步指的是<strong>内核态的数据拷贝到用户程序的缓存区</strong>这个过程</li></ul><p>如果 <code>socket</code> 设置了 <code>O_NONBLOCK</code> 标志，那么就表示使用的是非阻塞 I/O 的方式访问，而不做任何设置的话，默认是阻塞 I/O</p><p>因此，无论 <code>read</code> 和 <code>send</code> 是阻塞 I/O还是非阻塞 I/O 都是同步调用。因为在 <code>read</code> 调用时，内核将数据从内核空间拷贝到用户空间的过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，<code>read</code> 调用就会在这个同步过程中等待比较长的时间。</p><h4 id="异步-i-o" tabindex="-1"><a class="header-anchor" href="#异步-i-o" aria-hidden="true">#</a> 异步 I/O</h4><p>异步I/O下，「内核数据准备好」和「数据从内核态拷贝到用户态」这<strong>两个过程都不用等待</strong>。</p><ul><li>我们发起 <code>aio_read</code> （异步 I/O） 之后，就立即返回，内核自动将数据从内核空间拷贝到用户空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，<strong>应用程序并不需要主动发起拷贝动作</strong>。</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240227113211791.png" alt="image-20240227113211791" tabindex="0" loading="lazy"><figcaption>image-20240227113211791</figcaption></figure><blockquote><p>举个去饭堂吃饭的例子，你好比应用程序，饭堂好比操作系统。</p><p><strong>阻塞 I/O</strong> ：你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。</p><p><strong>非阻塞 I/O</strong> ：你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了。过几分钟，你又来饭堂问阿姨，阿姨还没做好，你又离开了。来回往复问了阿姨几次之后，阿姨终于说做好了。于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。</p><p><strong>异步 I/O</strong> ：你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，然后你就走了，阿姨在做好饭菜和打包好后会通知你并送到你面前来，整个过程你都不需要任何等待。</p></blockquote><p>很明显，异步 I/O 比同步 I/O 性能更好，因为<strong>异步 I/O 在「内核数据准备好」和「数据从内核空间拷贝到用户空间」这两个过程都不用等待</strong>。</p><p>Proactor 正是采用了异步 I/O 技术，所以被称为<strong>异步网络模型</strong>。</p><h3 id="reactor和proactor的区别" tabindex="-1"><a class="header-anchor" href="#reactor和proactor的区别" aria-hidden="true">#</a> Reactor和Proactor的区别</h3><ul><li><strong>Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件</strong>。在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。</li><li><strong>Proactor 是异步网络模式， 感知的是已完成的读写事件</strong>。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read/write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。</li></ul><p>因此，<strong>Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」</strong>，而 <strong>Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」</strong>。这里的「事件」就是有新连接、有数据可读、有数据可写的这些 I/O 事件这里的「处理」包含从驱动读取到内核以及从内核读取到用户空间。</p><blockquote><p>举个实际生活中的例子，Reactor 模式就是快递员在楼下，给你打电话告诉你快递到你家小区了，你需要自己下楼来拿快递。而在 Proactor 模式下，快递员直接将快递送到你家门口，然后通知你。</p></blockquote><p>无论是 Reactor，还是 Proactor，都是一种基于「事件分发」的网络编程模式，区别在于 <strong>Reactor 模式是基于「待完成」的 I/O 事件，而 Proactor 模式则是基于「已完成」的 I/O 事件</strong>。</p><h3 id="proactor模式" tabindex="-1"><a class="header-anchor" href="#proactor模式" aria-hidden="true">#</a> Proactor模式</h3><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240227113242672.png" alt="image-20240227113242672" tabindex="0" loading="lazy"><figcaption>image-20240227113242672</figcaption></figure><ul><li>Proactor <strong>Initiator</strong> 负责<strong>创建 Proactor 和 Handler 对象</strong>，并将 Proactor 和 Handler 都<strong>通过 Asynchronous Operation Processor 注册到内核</strong>；</li><li><strong>Asynchronous Operation Processor 负责处理注册请求，并处理 I/O 操作</strong>；</li><li>Asynchronous Operation Processor <strong>完成</strong> I/O 操作<strong>后通知 Proactor</strong>；</li><li><strong>Proactor 根据不同的事件类型回调不同的 Handler</strong> 进行业务处理；</li><li><strong>Handler 完成业务处理</strong>；</li></ul><h3 id="实用场景" tabindex="-1"><a class="header-anchor" href="#实用场景" aria-hidden="true">#</a> 实用场景</h3><p>可惜的是，在 <strong>Linux 下的异步 I/O 是不完善的</strong>， <code>aio</code> 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的，这也使得<strong>基于 Linux 的高性能网络程序都是使用 Reactor 方案</strong>。</p><p>而 Windows 里实现了一套完整的支持 socket 的异步编程接口，这套接口就是 <code>IOCP</code>，是由操作系统级别实现的异步 I/O，真正意义上异步 I/O，因此<strong>在 Windows 里实现高性能网络程序可以使用效率更高的 Proactor 方案</strong>。</p></div><!--[--><!----><!--]--><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/lgy8888/my_blog.git/edit/main/src/backEnd/OS/IO多路复用.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><nav class="vp-page-nav"><a aria-label="内存管理" class="vp-link nav-link prev nav-link prev" href="/my_blog/backEnd/OS/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><span class="font-icon icon iconfont icon-write" style=""></span>内存管理</div></a><a aria-label="CPU Cache" class="vp-link nav-link next nav-link next" href="/my_blog/backEnd/OS/CPU%20Cache.html"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">CPU Cache<span class="font-icon icon iconfont icon-write" style=""></span></div></a></nav><div id="comment" class="giscus-wrapper input-top" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">林光远的个人笔记网站</div><div class="vp-copyright">Copyright © 2024 LGYNB</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/my_blog/assets/app-OTaO6_y0.js" defer></script>
  </body>
</html>
