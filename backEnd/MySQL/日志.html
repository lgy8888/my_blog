<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.0" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.2" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://vuepress-theme-hope-docs-demo.netlify.app/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html"><meta property="og:site_name" content="林光远的个人笔记"><meta property="og:description" content="日志 重做日志(redo log) 说过的话就一定要办到 redo日志概念 redo日志的定义 redo日志是什么？ 事务的ACID中有一个是持久性，redo日志可以保证事务的持久性 redo日志会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来 redo日志的意义 为什么需要redo日志..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="LGYNB"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"","image":[""],"dateModified":null,"author":[{"@type":"Person","name":"LGYNB","url":"/"}]}</script><link rel="icon" href="/my_blog/favicon.ico"><title>林光远的个人笔记</title><meta name="description" content="日志 重做日志(redo log) 说过的话就一定要办到 redo日志概念 redo日志的定义 redo日志是什么？ 事务的ACID中有一个是持久性，redo日志可以保证事务的持久性 redo日志会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来 redo日志的意义 为什么需要redo日志...">
    <link rel="preload" href="/my_blog/assets/style-ERUp4lUP.css" as="style"><link rel="stylesheet" href="/my_blog/assets/style-ERUp4lUP.css">
    <link rel="modulepreload" href="/my_blog/assets/app-OTaO6_y0.js"><link rel="modulepreload" href="/my_blog/assets/日志.html-HmoE6Tqn.js"><link rel="modulepreload" href="/my_blog/assets/日志.html-KyUP1Nz-.js"><link rel="modulepreload" href="/my_blog/assets/plugin-vue_export-helper-x3n3nnut.js">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand vp-brand" href="/my_blog/"><img class="vp-nav-logo" src="/my_blog/logo.png" alt="林光远的个人笔记"><!----><span class="vp-site-name hide-in-pad">林光远的个人笔记</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a aria-label="后端技术" class="vp-link nav-link active nav-link active" href="/my_blog/backEnd/"><span class="font-icon icon iconfont icon-back-stage" style=""></span>后端技术<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="Web开发" class="vp-link nav-link nav-link" href="/my_blog/webDevelop/"><span class="font-icon icon iconfont icon-config" style=""></span>Web开发<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="AI技术" class="vp-link nav-link nav-link" href="/my_blog/ai/"><span class="font-icon icon iconfont icon-function" style=""></span>AI技术<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="数据结构与算法" class="vp-link nav-link nav-link" href="/my_blog/coding/"><span class="font-icon icon iconfont icon-calculate" style=""></span>数据结构与算法<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="项目经历" class="vp-link nav-link nav-link" href="/my_blog/projects/"><span class="font-icon icon iconfont icon-code" style=""></span>项目经历<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/lgy8888/my_blog.git" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索本站" autocomplete="off" spellcheck="false" value><!----></form><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-cache" style=""></span><span class="vp-sidebar-title">Redis</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><span class="font-icon icon iconfont icon-mysql" style=""></span><span class="vp-sidebar-title">MySQL</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a aria-label="SQL基础" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/SQL%E5%9F%BA%E7%A1%80.html"><span class="font-icon icon iconfont icon-write" style=""></span>SQL基础<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="SQL原理" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/SQL%E5%8E%9F%E7%90%86.html"><span class="font-icon icon iconfont icon-write" style=""></span>SQL原理<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="数据类型" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"><span class="font-icon icon iconfont icon-write" style=""></span>数据类型<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="数据库设计" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1.html"><span class="font-icon icon iconfont icon-write" style=""></span>数据库设计<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="逻辑架构" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.html"><span class="font-icon icon iconfont icon-write" style=""></span>逻辑架构<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="存储引擎" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html"><span class="font-icon icon iconfont icon-write" style=""></span>存储引擎<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="索引" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E7%B4%A2%E5%BC%95.html"><span class="font-icon icon iconfont icon-write" style=""></span>索引<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="事务" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E4%BA%8B%E5%8A%A1.html"><span class="font-icon icon iconfont icon-write" style=""></span>事务<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="日志" class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active nav-link active vp-sidebar-link vp-sidebar-page active" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html"><span class="font-icon icon iconfont icon-write" style=""></span>日志<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="重做日志(redo log)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#重做日志-redo-log"><!---->重做日志(redo log)<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="redo日志概念" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#redo日志概念"><!---->redo日志概念<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="redo日志格式" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#redo日志格式"><!---->redo日志格式<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Mini-Transaction" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#mini-transaction"><!---->Mini-Transaction<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="redo执行流程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#redo执行流程"><!---->redo执行流程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="LSN" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#lsn"><!---->LSN<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="checkpoint" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#checkpoint"><!---->checkpoint<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="崩溃恢复" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#崩溃恢复"><!---->崩溃恢复<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="redo全流程总结" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#redo全流程总结"><!---->redo全流程总结<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="回滚日志(undo log)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#回滚日志-undo-log"><!---->回滚日志(undo log)<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="事务回滚" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#事务回滚"><!---->事务回滚<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="事务ID" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#事务id"><!---->事务ID<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="undo日志的格式" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#undo日志的格式"><!---->undo日志的格式<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="undo日志的存放" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#undo日志的存放"><!---->undo日志的存放<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="回滚段" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#回滚段"><!---->回滚段<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="回滚事务" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#回滚事务"><!---->回滚事务<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="慢查询日志(slow query log)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#慢查询日志-slow-query-log"><!---->慢查询日志(slow query log)<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="慢查询日志操作" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#慢查询日志操作"><!---->慢查询日志操作<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="慢查询日志分析工具" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#慢查询日志分析工具"><!---->慢查询日志分析工具<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="查看SQL执行成本" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#查看sql执行成本"><!---->查看SQL执行成本<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="归档日志(bin log)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#归档日志-bin-log"><!---->归档日志(bin log)<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="binlog操作" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#binlog操作"><!---->binlog操作<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="日志总结(redo/undo/binlog)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#日志总结-redo-undo-binlog"><!---->日志总结(redo/undo/binlog)<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="三种日志简介" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#三种日志简介"><!---->三种日志简介<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="undo日志的作用" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#undo日志的作用"><!---->undo日志的作用<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="BufferPool的作用" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#bufferpool的作用"><!---->BufferPool的作用<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="redo日志的作用" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#redo日志的作用"><!---->redo日志的作用<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="binlog的作用" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#binlog的作用"><!---->binlog的作用<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="两阶段提交" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#两阶段提交"><!---->两阶段提交<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="更新语句的执行过程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html#更新语句的执行过程"><!---->更新语句的执行过程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a aria-label="锁" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E9%94%81.html"><span class="font-icon icon iconfont icon-write" style=""></span>锁<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="性能调优" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98.html"><span class="font-icon icon iconfont icon-write" style=""></span>性能调优<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-java" style=""></span><span class="vp-sidebar-title">Java</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-OS" style=""></span><span class="vp-sidebar-title">OS</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!----></h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="/" target="_blank" rel="noopener noreferrer">LGYNB</a></span><span property="author" content="LGYNB"></span></span><!----><!----><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 112 分钟</span><meta property="timeRequired" content="PT112M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#重做日志-redo-log">重做日志(redo log)</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#redo日志概念">redo日志概念</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#redo日志格式">redo日志格式</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#mini-transaction">Mini-Transaction</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#redo执行流程">redo执行流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#lsn">LSN</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#checkpoint">checkpoint</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#崩溃恢复">崩溃恢复</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#redo全流程总结">redo全流程总结</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#回滚日志-undo-log">回滚日志(undo log)</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#事务回滚">事务回滚</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#事务id">事务ID</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#undo日志的格式">undo日志的格式</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#undo日志的存放">undo日志的存放</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#回滚段">回滚段</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#回滚事务">回滚事务</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#慢查询日志-slow-query-log">慢查询日志(slow query log)</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#慢查询日志操作">慢查询日志操作</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#慢查询日志分析工具">慢查询日志分析工具</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#查看sql执行成本">查看SQL执行成本</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#归档日志-bin-log">归档日志(bin log)</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#binlog操作">binlog操作</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#日志总结-redo-undo-binlog">日志总结(redo/undo/binlog)</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#三种日志简介">三种日志简介</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#undo日志的作用">undo日志的作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#bufferpool的作用">BufferPool的作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#redo日志的作用">redo日志的作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#binlog的作用">binlog的作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#两阶段提交">两阶段提交</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#更新语句的执行过程">更新语句的执行过程</a></li><!----><!--]--></ul></li><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><p>日志</p><h2 id="重做日志-redo-log" tabindex="-1"><a class="header-anchor" href="#重做日志-redo-log" aria-hidden="true">#</a> 重做日志(redo log)</h2><blockquote><p>说过的话就一定要办到</p></blockquote><h3 id="redo日志概念" tabindex="-1"><a class="header-anchor" href="#redo日志概念" aria-hidden="true">#</a> redo日志概念</h3><h4 id="redo日志的定义" tabindex="-1"><a class="header-anchor" href="#redo日志的定义" aria-hidden="true">#</a> redo日志的定义</h4><blockquote><p>redo日志是什么？</p></blockquote><p>事务的ACID中有一个是持久性，redo日志可以保证事务的持久性</p><p>redo日志会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来</p><h4 id="redo日志的意义" tabindex="-1"><a class="header-anchor" href="#redo日志的意义" aria-hidden="true">#</a> redo日志的意义</h4><blockquote><p><strong>为什么需要redo日志</strong></p></blockquote><p>redo日志是用来保证事务的持久性的</p><blockquote><p>如何保证事务的持久性？</p></blockquote><p>保证数据持久性最容易想到的方法就是：在事务提交的时候就将缓冲区中脏页刷入磁盘</p><p>但是这个方法有两个问题</p><ul><li>刷新一个完整的页太浪费了 <ul><li>有时候修改的仅仅只是页面中的一条记录，而InnoDB每次都得以页为单位来进行磁盘I/O</li><li>也就是事务提交时需要将修改了的页面从内存刷到磁盘</li><li>如果只改了一条记录就需要刷一整页那就太浪费了</li></ul></li><li>随机I/O刷盘速度较慢 <ul><li>一个事务可能包含很多语句，一个语句也可能修改多个页面</li><li>而这个多个页面可能都不是相邻的</li><li>这也就意味着刷盘的时候需要进行很多随机I/O</li></ul></li></ul><blockquote><p>怎么解决这个问题？</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231229160313032.png" alt="image-20231229160313032" tabindex="0" loading="lazy"><figcaption>image-20231229160313032</figcaption></figure><p>不要用刷盘来保证事务的持久性，只需要将修改的操作记录到一个日志里面，在事务提交的时候将日志刷入磁盘</p><p>即使之后系统崩溃了，重启之后只要按照上述内容所记录的步骤重新更新一下数据页</p><p>那么该事务对数据库中所做的修改又可以被恢复出来，也就意味着满足持久性的要求。</p><p><strong>这个日志就是redo-log，重做日志，也叫redo日志</strong></p><h4 id="redo日志的好处" tabindex="-1"><a class="header-anchor" href="#redo日志的好处" aria-hidden="true">#</a> redo日志的好处</h4><ul><li><strong>redo 日志占用的空间非常小</strong><ul><li>存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小的</li></ul></li><li><strong>redo 日志是顺序写入磁盘的</strong><ul><li>在执行事务的过程中，每执行一条语句，就可能产生若干条redo 日志</li><li>这些日志是按照产生的顺序写入磁盘的，也就是使用顺序I/O</li></ul></li></ul><h4 id="redo日志的组成" tabindex="-1"><a class="header-anchor" href="#redo日志的组成" aria-hidden="true">#</a> redo日志的组成</h4><ul><li><strong>内存中</strong>：<code>redo_log_buffer</code>redo日志的缓冲区，容易丢失</li><li><strong>磁盘中</strong>：<code>redo_log_file</code>redo日志的文件，是持久的，不易丢失</li></ul><h3 id="redo日志格式" tabindex="-1"><a class="header-anchor" href="#redo日志格式" aria-hidden="true">#</a> redo日志格式</h3><blockquote><p>redo日志通用结构</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231229144616760.png" alt="image-20231229144616760" tabindex="0" loading="lazy"><figcaption>image-20231229144616760</figcaption></figure><ul><li><code>type</code> ：该条redo 日志的类型 <ul><li>在MySQL 5.7.21 中，InnoDB 一共为 redo 日志设计了53种不同的类型</li></ul></li><li><code>space ID</code> ：表空间ID</li><li><code>page number</code> ：页号</li><li><code>data</code> ：该条redo 日志的具体内容</li></ul><h4 id="简单的redo日志类型" tabindex="-1"><a class="header-anchor" href="#简单的redo日志类型" aria-hidden="true">#</a> 简单的redo日志类型</h4><blockquote><p>row_id的赋值过程</p></blockquote><ul><li>服务器会在内存中维护一个全局变量，每当向某个包含隐藏的row_id 列的表中插入一条记录时，就会把该变量的值当作新记录的row_id 列的值，并且把该变量自增1</li><li>每当这个变量的值为256的倍数时，就会将该变量的值刷新到系统表空间的页号为7 的页面中一个称之为Max Row ID 的属性处</li><li>当系统启动时，会将上边提到的Max Row ID 属性加载到内存中，将该值加上256之后赋值给我们前边提到的 全局变量（因为在上次关机时该全局变量的值可能大于Max Row ID 属性值）</li></ul><p>Max Row Id属性占用8个字节，当某个事务向某个包含row_id的表插入记录，并且刚好为该记录分配的row_id值为256的倍数时，就会向系统表空间中页号为7的页面的相应偏移量处写入8个字节的值</p><p>这个写入实际上是在buffer_pool中完成的，InnoDB需要为这个页面修改记录一条redo日志，以便在系统奔溃后能将已经提交的该事务对该页面所做的修改恢复出来</p><blockquote><p><strong>物理日志</strong></p></blockquote><p>redo 日志中只需要记录在<strong>某个页面的某个偏移量处修改了几个字节的值</strong>和<strong>具体被修改的内容</strong></p><p>InnoDB把这种极其简单的redo 日志称之为物理日志，并且根据在页面中写入数据的多少划分了几种不同的redo 日志类型：</p><ul><li>MLOG_1BYTE （ type 字段对应的十进制数字为1 ）：表示在页面的某个偏移量处写入1个字节</li><li>MLOG_2BYTE （ type 字段对应的十进制数字为2 ）：表示在页面的某个偏移量处写入2个字节</li><li>MLOG_4BYTE （ type 字段对应的十进制数字为4 ）：表示在页面的某个偏移量处写入4个字节</li><li>MLOG_8BYTE （ type 字段对应的十进制数字为8 ）：表示在页面的某个偏移量处写入8个字节</li><li>MLOG_WRITE_STRING （ type 字段对应的十进制数字为30 ）：表示在页面的某个偏移量处写入一串数据。</li></ul><blockquote><p><strong>MLOG_8TYPE的redo日志结构</strong></p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231229150333244.png" alt="image-20231229150333244" tabindex="0" loading="lazy"><figcaption>image-20231229150333244</figcaption></figure><h4 id="复杂的redo日志类型" tabindex="-1"><a class="header-anchor" href="#复杂的redo日志类型" aria-hidden="true">#</a> 复杂的redo日志类型</h4><blockquote><p><strong>一条语句会更新多少牵扯多少？</strong></p></blockquote><p>执行一条语句会修改非常多的页面，包括系统数据页面和用户数据页面（用户数据就是聚簇索引和二级索引对应的B+树）</p><p>以INSERT语句对用户数据页面的更新为例</p><ul><li>表中包含多少索引，一条INSERT语句就需要更新多少棵B+树</li><li>针对某一棵B+ 树来说 <ul><li>可能更新叶子节点页面</li><li>可能更新内节点页面</li><li>可能创建新的页面</li></ul></li><li>针对叶子节点页面来说 <ul><li>一定更新next_record属性 <ul><li>数据页里的记录是按照索引列从小到大的顺序组成一个单向链表的，每插入一条记录，就需要更新上一条记录的记录头信息中的next_record属性来维护这个单向链表</li></ul></li><li>可能更新Page Directory 中的槽信息</li><li>可能更新Page Header中的各种页面统计信息 <ul><li>比如PAGE_N_DIR_SLOTS 表示的槽数量可能会更改</li><li>PAGE_HEAP_TOP代表的还未使用的空间最小地址可能会更改</li><li>PAGE_N_HEAP 代表的本页面中的记录数量可能会更改，各种信息都可能会被修改。</li></ul></li><li>······</li></ul></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231229151821996.png" alt="image-20231229151821996" tabindex="0" loading="lazy"><figcaption>image-20231229151821996</figcaption></figure><blockquote><p><strong>这么复杂的修改，要怎么记录到redo日志里面？</strong></p></blockquote><p>如果用简单的物理日志来记录</p><ul><li>方案一：在每个修改的地方都记录一条redo 日志。 <ul><li>也就是如上图所示，有多少个加粗的块，就写多少条物理redo 日志。</li><li>因为被修改的地方是在太多了，可能记录的redo 日志占用的空间都比整个页面占的空间都多了</li></ul></li><li>方案二：将整个页面的第一个被修改的字节到最后一个修改的字节之间所有的数据当成是一条物理redo日志中的具体数据。 <ul><li>第一个被修改的字节到最后一个修改的字节之间仍然有许多没有修改过的数据，</li><li>我们把这些没有修改的数据也加入到redo 日志中去岂不是太浪费了</li></ul></li></ul><blockquote><p>如何解决这些问题</p></blockquote><p>InnoDB提出了一些新的redo日志类型</p><ul><li>MLOG_REC_INSERT （对应的十进制数字为9 ）：表示插入一条使用非紧凑行格式（Redundant）的记录</li><li>MLOG_COMP_REC_INSERT （对应的十进制数字为38 ）：表示插入一条使用紧凑行格式的记录</li><li>MLOG_COMP_PAGE_CREATE （ type 字段对应的十进制数字为58 ）：表示创建一个存储紧凑行格式记录的页面</li><li>MLOG_COMP_REC_DELETE （ type 字段对应的十进制数字为42 ）：表示删除一条使用紧凑行格式记录</li><li>MLOG_COMP_LIST_START_DELETE （ type 字段对应的十进制数字为44 ）：表示从某条给定记录开始删除页面中的一系列使用紧凑行格式记录</li><li>MLOG_COMP_LIST_END_DELETE （ type 字段对应的十进制数字为43 ）：表示结束删除页面中的一系列使用紧凑行格式的记录 <ul><li>与MLOG_COMP_LIST_START_DELETE类型的redo 日志呼应</li></ul></li><li>MLOG_ZIP_PAGE_COMPRESS （ type 字段对应的十进制数字为51 ）：表示压缩一个数据页</li></ul><blockquote><p><strong>这些日志是什么意思？</strong></p></blockquote><p>这些类型的redo 日志既包含物理层面的意思，也包含逻辑层面的意思，具体指：</p><ul><li>物理层面：这些日志都指明了对哪个表空间的哪个页进行了修改。</li><li>逻辑层面：在系统奔溃重启时，并不能直接根据这些日志里的记载，将页面内的某个偏移量处恢复成某个数据，而是需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复成系统奔溃前的样子。</li></ul><blockquote><p>怎么理解物理层面和逻辑层面什么意思？</p></blockquote><p>以类型为MLOG_COMP_REC_INSERT 这个代表插入一条使用紧凑行格式的记录时的redo 日志为例</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231229154027186.png" alt="image-20231229154027186" tabindex="0" loading="lazy"><figcaption>image-20231229154027186</figcaption></figure><ul><li><code>n_uniques</code>：表示该记录需要前几个字段才能标识其唯一性 <ul><li>聚簇索引中的记录 ——&gt; 主键列数</li><li>二级索引中的记录 ——&gt; 索引列数 + 主键列数</li><li>当插入一条记录时就可以按照记录的前<code>n_uniques</code> 个字段进行排序</li></ul></li><li><code>field1_len ~ fieldn_len</code> ：代表着该记录若干个字段占用存储空间的大小 <ul><li>跟行记录中的变长字段长度列表不同的时，这里不管该字段的类型是固定长度大小的（比如INT ），还是可变长度大小（比如VARCHAR(M) ）的，该字段占用的大小始终要写入redo 日志中</li></ul></li><li><code>offset</code> ：代表的是该记录的前一条记录在页面中的地址。 <ul><li><code>offset</code>用于修改上一个记录的记录头信息中的<code>next_record</code>属性</li></ul></li><li><code>end_seg_len</code>：用于间接的计算出一条记录占用存储空间的总大小 <ul><li>这个字段就是为了节省redo 日志存储空间而提出来的</li></ul></li></ul><p>上面的日志格式是物理层面的，记录了新插入数据的各种信息</p><p>重启的时候服务器会恢复redo日志记录的操作，而这些操作恢复完之后，页面包含的各种信息也就自然而然的补全了，只要物理层面的信息不要出错，这些计算出来的页面信息也就不会有问题</p><h3 id="mini-transaction" tabindex="-1"><a class="header-anchor" href="#mini-transaction" aria-hidden="true">#</a> Mini-Transaction</h3><h4 id="以组的形式写入redo日志" tabindex="-1"><a class="header-anchor" href="#以组的形式写入redo日志" aria-hidden="true">#</a> 以组的形式写入redo日志</h4><blockquote><p><strong>什么是以组的形式写入redo日志？</strong></p></blockquote><p>一条INSERT语句可能会修改多个页面</p><ul><li>可能修改系统表的数据页</li><li>可能修改聚簇索引B+树里面的页</li><li>可能修改二级索引B+树里面的页</li><li>可能还有其他的页需要修改</li></ul><p>InnoDB将<strong>执行语句过程中产生的redo-log划分为多个不可分割的组</strong></p><ul><li>更新Max Row ID 属性时产生的redo 日志是不可分割的。</li><li>向聚簇索引对应B+ 树的页面中插入一条记录时产生的redo 日志是不可分割的。</li><li>向某个二级索引对应B+ 树的页面中插入一条记录时产生的redo 日志是不可分割的。</li><li>还有其他的一些对页面的访问操作时产生的redo 日志是不可分割的</li></ul><blockquote><p><strong>乐观插入</strong></p></blockquote><p>B+树中数据页的剩余空间充足，足够容纳一条待插入记录</p><p>直接将记录插入数据页中，然后记录一条MLOG_COMP_REC_INSERT的redo日志就好了</p><p>其实乐观插入也会产生多条redo日志，但是总体比悲观插入少得多</p><blockquote><p><strong>悲观插入</strong></p></blockquote><p>B+树中数据页的剩余空间不足，插入新记录需要页分裂</p><p>页分裂：新建一个叶子节点，然后把原先数据页中的一部分记录复制到这个新的数据页中，然后再把记录插入进去，把这个叶子节点插入到叶子节点链表中，最后还要在内节点中添加一条目录项记录指向这个新创建的页面。</p><p>页分裂对多个页面造成了修改，也就得记录多条redo日志，总共有二三十条</p><blockquote><p><strong>为什么要以组的形式写入redo日志？</strong></p></blockquote><p>InnoDB认为<strong>向某个索引对应的B+树插入一条记录的过程是原子的</strong></p><p>所以InnoDB规定<strong>在执行这些需要保证原子性的操作时必须以组的形式来记录的redo 日志</strong></p><p>在进行系统奔溃重启恢复时，针对某个组中的redo 日志，<strong>要么把全部的日志都恢复掉，要么一条也不恢复</strong></p><blockquote><p><strong>怎么保证记录redo日志时的原子性？</strong></p></blockquote><p><strong>多条redo日志</strong>：例如向某个索引对应的B+树进行一次悲观插入</p><ul><li>在该组中的最后一条redo日志后面加上一个特殊类型的redo日志</li><li>该类型名称为：MLOG_MULTI_REC_END，type字段对应的十进制数字为31，该类型的redo日志结构只有一个type字段</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230003329405.png" alt="image-20231230003329405" tabindex="0" loading="lazy"><figcaption>image-20231230003329405</figcaption></figure><ul><li>在系统恢复的时候，只有解析到类型为MLOG_MULTI_REC_END的redo日志，才会认为解析到了一组完整的redo日志，才会进行恢复，否则就放弃前面解析到的redo日志</li></ul><p><strong>单条redo日志</strong>：例如更新Max Row ID数据产生的日志</p><ul><li>InnoDB为了省空间，不复用多条redo日志的情况（在最后一条日志后面加一个标识结束作用的特殊日志）</li><li>redo日志结构中的type字段占用8个字节，但是redo日志的类型最多也就几十种，连127都达不到，所以用7个比特位就足以包括所有的redo日志类型了，这样就可以省出<strong>一个比特位来表示该需要保证原子性的操作只产生单一的一条redo 日志</strong></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230003823511.png" alt="image-20231230003823511" tabindex="0" loading="lazy"><figcaption>image-20231230003823511</figcaption></figure><ul><li>如果type 字段的第一个比特位为1 ，代表该需要保证原子性的操作只产生了单一的一条redo 日志</li><li>否则表示该需要保证原子性的操作产生了一系列的redo 日志。</li></ul><h4 id="mini-transaction概念" tabindex="-1"><a class="header-anchor" href="#mini-transaction概念" aria-hidden="true">#</a> Mini-Transaction概念</h4><p>MySQL将<strong>对底层页面中的一次原子访问的过程称之为一个Mini-Transaction，简称mtr</strong></p><ul><li>修改一次Max Row ID的值算是一次mtr</li><li>向某个索引对应的B+树种插入一条记录的过程也算是一次mtr</li></ul><p>一个mtr可以包含一组redo日志，也可以只有一个redo日志</p><p>在进行崩溃恢复的时候一个mtr作为一个不可分割的整体进行恢复</p><p>一个事务可以包含若干条语句，每一个语句又是由多个mtr组成，每一个mtr又包含多个redo日志</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230004238438.png" alt="image-20231230004238438" tabindex="0" loading="lazy"><figcaption>image-20231230004238438</figcaption></figure><h3 id="redo执行流程" tabindex="-1"><a class="header-anchor" href="#redo执行流程" aria-hidden="true">#</a> redo执行流程</h3><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231229162124030.png" alt="image-20231229162124030" tabindex="0" loading="lazy"><figcaption>image-20231229162124030</figcaption></figure><ol><li>先将数据页从磁盘中读入内存中的buffer pool</li><li>写事务修改内存中的数据页，并将其标记为脏页</li><li>事务执行过程中各个mtr生成的redo日志们存在一个地方，一个mtr执行完毕就将这个mtr生成的redo日志们写入redo log buffer</li><li>当事务commit时，将redo log buffer里面的内容刷入磁盘中的redo log file <ul><li>redo log file是采用追加的方式写入的</li></ul></li><li>定期将buffer pool里面的脏页刷入磁盘</li></ol><blockquote><p>Write-Ahead Log（预先日志持久化）</p></blockquote><p>在持久化一个数据页之前，先将内存中相应的日志页持久化</p><h4 id="redo日志写入内存" tabindex="-1"><a class="header-anchor" href="#redo日志写入内存" aria-hidden="true">#</a> redo日志写入内存</h4><h5 id="redo-log-block" tabindex="-1"><a class="header-anchor" href="#redo-log-block" aria-hidden="true">#</a> redo log block</h5><blockquote><p>redo-log存在哪里？</p></blockquote><p>为了更好的进行系统崩溃恢复，InnoDB将mtr生成的redo日志都放在了大小为512字节的页中</p><p>与表空间中<code>16k</code>的页做区分，将存储redo日志的页称为block</p><blockquote><p>redo log block 示意图</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230005410731.png" alt="image-20231230005410731" tabindex="0" loading="lazy"><figcaption>image-20231230005410731</figcaption></figure><p><code>log block header</code> 的几个属性的意思分别如下：</p><ul><li>LOG_BLOCK_HDR_NO ：每一个block都有一个大于0的唯一标号，本属性就表示该标号值。</li><li>LOG_BLOCK_HDR_DATA_LEN ：表示block中已经使用了多少字节，初始值为12 （因为log block body 从第12个字节处开始） <ul><li>随着往block中写入的redo日志越来也多，本属性值也跟着增长。</li><li>如果log block body已经被全部写满，那么本属性的值被设置为512 。</li></ul></li><li>LOG_BLOCK_FIRST_REC_GROUP ：一条redo 日志也可以称之为一条redo 日志记录（ redo log record ） <ul><li>一个mtr 会生产多条redo 日志记录</li><li>这些redo 日志记录被称之为一个redo 日志记录组（ redo logrecord group ）</li><li>LOG_BLOCK_FIRST_REC_GROUP 就代表该block中第一个mtr 生成的redo 日志记录组的偏移量 <ul><li>也就是这个block里第一个mtr 生成的第一条redo 日志的偏移量</li></ul></li></ul></li><li>LOG_BLOCK_CHECKPOINT_NO ：表示checkpoint的序号</li></ul><p><code>log block trailer</code> 中属性的意思如下：</p><ul><li>LOG_BLOCK_CHECKSUM ：表示block的校验值，用于正确性校验</li></ul><h5 id="redo日志缓冲区" tabindex="-1"><a class="header-anchor" href="#redo日志缓冲区" aria-hidden="true">#</a> redo日志缓冲区</h5><p>写数据页的时候需要先写入buffer pool缓冲区</p><p>写redo日志页的时候也需要先写入缓冲区，这个缓冲区叫redo log buffer，redo日志缓冲区</p><p>这片缓冲区被划分为多个连续的redo log block</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230020551490.png" alt="image-20231230020551490" tabindex="0" loading="lazy"><figcaption>image-20231230020551490</figcaption></figure><h5 id="redo日志写入缓冲区" tabindex="-1"><a class="header-anchor" href="#redo日志写入缓冲区" aria-hidden="true">#</a> redo日志写入缓冲区</h5><p>向缓冲区中写入redo日志的过程是顺序追加入block中的空闲空间的</p><blockquote><p>如何知道应该写在哪个block的哪个地方？</p></blockquote><p>InnoDB提供一个全局变量叫buf_free，指明redo日志应该写入log buffer的哪个位置</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230202752426.png" alt="image-20231230202752426" tabindex="0" loading="lazy"><figcaption>image-20231230202752426</figcaption></figure><p>一个mtr会生成许多条redo日志，而这些redo日志又是不可分割的整体</p><p>所以并不是每生成一条redo日志就将其插入log buffer中</p><p>在每个mtr运行的过程中，产生的日志会先暂时存到一个地方</p><p>当该mtr结束的时候，将这过程中产生的一组redo日志全部到到log buffer中</p><p>一个事务由多个mtr组成，而不同的事务之间可能是并发执行的，所以mtr的插入可能是交替进行的</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230203400562.png" alt="image-20231230203400562" tabindex="0" loading="lazy"><figcaption>image-20231230203400562</figcaption></figure><h4 id="redo日志刷入磁盘" tabindex="-1"><a class="header-anchor" href="#redo日志刷入磁盘" aria-hidden="true">#</a> redo日志刷入磁盘</h4><h5 id="redo-log的刷盘策略" tabindex="-1"><a class="header-anchor" href="#redo-log的刷盘策略" aria-hidden="true">#</a> redo-log的刷盘策略</h5><blockquote><p>redo log 的刷盘策略由 <code>innodb_flush_log_at_trx_commit</code> 配置项决定</p></blockquote><table><thead><tr><th>配置项</th><th>刷盘时机</th></tr></thead><tbody><tr><td>0</td><td>表示每次事务提交时不进行刷盘操作（系统默认master thread每隔1s进行一次redo日志的同步）</td></tr><tr><td>1</td><td>表示每次事务提交时都将进行同步，刷盘操作（ 默认值）</td></tr><tr><td>2</td><td>表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件</td></tr></tbody></table><p>MySQL后台有个线程专门负责将redo log buffer中的内容刷入磁盘</p><ul><li>这个线程每隔1s就会将redo log buffer里面的内容写到page cache中，然后调用fsync刷入磁盘</li><li>所以无论选择哪种刷盘策略，最多就会丢失1s的数据</li></ul><blockquote><p><code>innodb_flush_log_at_trx_commit = 1</code></p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231229162857832.png" alt="image-20231229162857832" tabindex="0" loading="lazy"><figcaption>image-20231229162857832</figcaption></figure><blockquote><p><code>innodb_flush_log_at_trx_commit = 2</code></p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231229162949860.png" alt="image-20231229162949860" tabindex="0" loading="lazy"><figcaption>image-20231229162949860</figcaption></figure><blockquote><p><code>innodb_flush_log_at_trx_commit = 0</code></p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231229163015175.png" alt="image-20231229163015175" tabindex="0" loading="lazy"><figcaption>image-20231229163015175</figcaption></figure><blockquote><p><strong>三种策略的应用场景</strong></p></blockquote><p>这三个参数的数据安全性和写入性能的比较如下：</p><ul><li>数据安全性：参数 1 &gt; 参数 2 &gt; 参数 0</li><li>写入性能：参数 0 &gt; 参数 2&gt; 参数 1</li></ul><p>所以，数据安全性和写入性能是熊掌不可得兼的，<strong>要不追求数据安全性，牺牲性能；要不追求性能，牺牲数据安全性</strong>。</p><ul><li>在一些对数据安全性要求比较高的场景中，显然 <code>innodb_flush_log_at_trx_commit</code> 参数需要设置为 1。</li><li>在一些可以容忍数据库崩溃时丢失 1s 数据的场景中，我们可以将该值设置为 0，这样可以明显地减少日志同步到磁盘的 I/O 操作。</li><li>安全性和性能折中的方案就是参数 2，虽然参数 2 没有参数 0 的性能高，但是数据安全性方面比参数 0 强，因为参数 2 只要操作系统不宕机，即使数据库崩溃了，也不会丢失数据，同时性能方便比参数 1 高。</li></ul><h5 id="redo日志文件组" tabindex="-1"><a class="header-anchor" href="#redo日志文件组" aria-hidden="true">#</a> redo日志文件组</h5><p>MySQL 的数据目录（使用SHOW VARIABLES LIKE &#39;datadir&#39; 查看）下默认有两个名为<code>ib_logfile0</code> 和<code>ib_logfile1</code> 的文件</p><p>log buffer 中的日志默认情况下就是刷新到这两个磁盘文件中</p><blockquote><p>几个启动参数来调节日志文件</p></blockquote><ul><li><code>innodb_log_group_home_dir</code><ul><li>该参数指定了redo 日志文件所在的目录，默认值就是当前的数据目录。</li></ul></li><li><code>innodb_log_file_size</code><ul><li>该参数指定了每个redo 日志文件的大小，在MySQL 5.7.21 这个版本中的默认值为48MB</li></ul></li><li><code>innodb_log_files_in_group</code><ul><li>该参数指定redo 日志文件的个数，默认值为2，最大值为100。</li></ul></li></ul><blockquote><p>日志文件不止一个，要怎么管理？</p></blockquote><p>磁盘上的redo 日志文件不只一个，而是以一个日志文件组的形式出现的。这些文件以<code>ib_logfile[数字]</code> （ 数字可以是0 、1 、2 ...）的形式进行命名。</p><p>在将redo 日志写入日志文件组时，是从<code>ib_logfile0</code> 开始写，如果ib_logfile0 写满了，就接着<code>ib_logfile1</code> 写</p><p>同理， <code>ib_logfile1</code> 写满了就去写<code>ib_logfile2</code> ，依此类推。写满了就回去继续写<code>ib_logfile0</code></p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230204912172.png" alt="image-20231230204912172" tabindex="0" loading="lazy"><figcaption>image-20231230204912172</figcaption></figure><h5 id="redo日志文件格式" tabindex="-1"><a class="header-anchor" href="#redo日志文件格式" aria-hidden="true">#</a> redo日志文件格式</h5><p>redo日志文件是由若干个512字节的block组成，<strong>将log buffer中的redo日志刷入磁盘的本质就是将block的镜像写入日志文件中</strong></p><p>redo 日志文件组中的每个文件大小都一样，格式也一样，都是由两部分组成：</p><ul><li>前2048个字节，也就是前4个block是用来存储一些管理信息的。</li><li>从第2048字节往后是用来存储 log buffer 中的block镜像的</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230210031077.png" alt="image-20231230210031077" tabindex="0" loading="lazy"><figcaption>image-20231230210031077</figcaption></figure><blockquote><p>前面的管理信息是存什么的？</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230210119686.png" alt="image-20231230210119686" tabindex="0" loading="lazy"><figcaption>image-20231230210119686</figcaption></figure><ul><li><code>log file header</code> ：描述该redo 日志文件的一些整体属性</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230210148346.png" alt="image-20231230210148346" tabindex="0" loading="lazy"><figcaption>image-20231230210148346</figcaption></figure><table><thead><tr><th>属性名</th><th>长度</th><th>描述</th></tr></thead><tbody><tr><td>LOG_HEADER_FORMAT</td><td>4</td><td>redo 日志的版本，在MySQL5.7.21 中该值永远为1</td></tr><tr><td>LOG_HEADER_PAD1</td><td>4</td><td>做字节填充用的</td></tr><tr><td>LOG_HEADER_START_LSN</td><td>8</td><td>标记本redo 日志文件开始的LSN值，也就是文件偏移量为2048字节初对应的LSN值</td></tr><tr><td>LOG_HEADER_CREATOR</td><td>32</td><td>一个字符串，标记这个redo 日志文件的创建者是谁。</td></tr><tr><td>LOG_BLOCK_CHECKSUM</td><td>4</td><td>本block的校验值，所有block都有</td></tr></tbody></table><ul><li><code>checkpoint1</code> ：记录关于checkpoint 的一些属性1</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230210512348.png" alt="image-20231230210512348" tabindex="0" loading="lazy"><figcaption>image-20231230210512348</figcaption></figure><table><thead><tr><th>属性名</th><th>长度</th><th>描述</th></tr></thead><tbody><tr><td>LOG_CHECKPOINT_NO</td><td>8</td><td>服务器做 checkpoint 的编号，每做一次checkpoint ，该值就加1。</td></tr><tr><td>LOG_CHECKPOINT_LSN</td><td>8</td><td>服务器做 checkpoint 结束时对应的LSN 值，系统奔溃恢复时将从该值开始。</td></tr><tr><td>LOG_CHECKPOINT_OFFSET</td><td>8</td><td>上个属性中的LSN 值在redo 日志文件组中的偏移量</td></tr><tr><td>LOG_CHECKPOINT_LOG_BUF_SIZE</td><td>8</td><td>服务器在做 checkpoint 操作时对应的 log buffer 的大小</td></tr><tr><td>LOG_BLOCK_CHECKSUM</td><td>4</td><td>本block的校验值，所有block都有</td></tr></tbody></table><ul><li><code>checkpoint2</code> ：结构和checkpoint1 一样</li></ul><h3 id="lsn" tabindex="-1"><a class="header-anchor" href="#lsn" aria-hidden="true">#</a> LSN</h3><h4 id="lsn定义" tabindex="-1"><a class="header-anchor" href="#lsn定义" aria-hidden="true">#</a> LSN定义</h4><blockquote><p><strong>LSN是什么？</strong></p></blockquote><p><strong>Log Sequeue Number，日志序列号，简称LSN，InnoDB的一个全局变量，用来记录写入的redo日志量</strong>，默认为8704</p><p><strong>每一组由mtr生成的redo日志都有一个唯一的LSN值与其对应</strong>，LSN值越小，说明redo日志产生的越早。</p><p>LSN相当于以mtr为单位的一组不可分割的redo日志的自增主键，可以通过LSN值快速定位到同一个mtr的日志。</p><blockquote><p><strong>LSN是怎么计算的？</strong></p></blockquote><p>在统计lsn 的增长量时，是按照实际写入的日志量加上占用的log block header 和log block trailer 来计算的</p><ul><li>系统初始化log buffer时 <ul><li>LSN的值为8704 + 第一个block的log block header长度</li></ul></li><li>某个mtr产生的日志较小，一个block能容纳 <ul><li>LSN的值为8704 + 第一个block的log block header长度 + redo日志长度</li></ul></li><li>某个mtr产生的日志较大，一个block无法容纳 <ul><li>LSN的值为8704 + 第一个block的log block header长度 + 第一个block中存放的redo日志长度 + 第一个block的log block trailer长度 + 第二个block的log block header长度 + 第二个block中存放的redo日志长度</li></ul></li></ul><h4 id="flushed-to-disk-lsn" tabindex="-1"><a class="header-anchor" href="#flushed-to-disk-lsn" aria-hidden="true">#</a> flushed_to_disk_lsn</h4><blockquote><p><strong>flushed_to_disk_lsn是什么？</strong></p></blockquote><p>redo 日志是首先写到 log buffer 中，之后才会被刷新到磁盘上的redo 日志文件</p><p><strong>标记日志位置的全局变量</strong></p><ul><li><code>buf_free</code>：标记当前redo日志写到的位置</li><li><code>buf_next_to_write</code>：标记已经被刷盘的日志的位置</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230211601667.png" alt="image-20231230211601667" tabindex="0" loading="lazy"><figcaption>image-20231230211601667</figcaption></figure><p><strong>统计日志的数量</strong></p><ul><li><code>Log Sequeue Number（LSN）</code>：表示系统中写入的 redo日志量 <ul><li>这里面包括了写入log buffer但没有刷盘的，也包括了已经刷盘的日志</li></ul></li><li><code>flushed_to_disk_lsn</code>：表示刷新到磁盘中的 redo 日志量</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230212800660.png" alt="image-20231230212800660" tabindex="0" loading="lazy"><figcaption>image-20231230212800660</figcaption></figure><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230212811634.png" alt="image-20231230212811634" tabindex="0" loading="lazy"><figcaption>image-20231230212811634</figcaption></figure><h4 id="flush链表中的lsn" tabindex="-1"><a class="header-anchor" href="#flush链表中的lsn" aria-hidden="true">#</a> flush链表中的LSN</h4><p>一个mtr 代表一次对底层页面的原子访问，在访问过程中可能会产生一组不可分割的redo 日志</p><p>在mtr 结束时，会把这一组redo 日志写入到log buffer 中。</p><p>mtr结束后，把在mtr执行过程中修改过的页面标为脏页并加入到Buffer Pool的flush链表</p><blockquote><p>flush链表长啥样？</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230213123938.png" alt="image-20231230213123938" tabindex="0" loading="lazy"><figcaption>image-20231230213123938</figcaption></figure><p>flush链表中的脏页是按照页面的第一次修改时间从大到小进行排序的</p><ul><li><code>oldest_modification</code> ：如果某个页面被加载到Buffer Pool 后进行第一次修改，那么就将修改该页面的mtr 开始时对应的lsn 值写入这个属性。</li><li><code>newest_modification</code> ：每修改一次页面，都会将修改该页面的mtr 结束时对应的lsn 值写入这个属性。也就是说该属性表示页面最近一次修改后对应的系统lsn 值</li></ul><blockquote><p>例子</p></blockquote><ul><li>系统第一次启动后，向log buffer 中写入了mtr_1 、mtr_2 、mtr_3 这三个mtr 产生的redo 日志，假设</li><li>这三个mtr 开始和结束时对应的lsn值以及其修改了哪些页面如下： <ul><li>mtr_1 ：8716 ～ 8916，修改页a</li><li>mtr_2 ：8916 ～ 9948，修改页b和页c</li><li>mtr_3 ：9948 ～ 10000，修改页b和页d</li></ul></li></ul><blockquote><p>mtr_1结束后的flush链表</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230213944438.png" alt="image-20231230213944438" tabindex="0" loading="lazy"><figcaption>image-20231230213944438</figcaption></figure><blockquote><p>mtr_2结束后的flush链表</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230213956259.png" alt="image-20231230213956259" tabindex="0" loading="lazy"><figcaption>image-20231230213956259</figcaption></figure><blockquote><p>mtr_3结束后的flush链表</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230214019175.png" alt="image-20231230214019175" tabindex="0" loading="lazy"><figcaption>image-20231230214019175</figcaption></figure><p>flush链表中的脏页按照修改发生的时间顺序进行排序，也就是按照<code>oldest_modification</code>代表的LSN值进行排序，被多次更新的页面不会重复插入到flush链表中，但是会更新<code>newest_modification</code>属性的值。</p><h3 id="checkpoint" tabindex="-1"><a class="header-anchor" href="#checkpoint" aria-hidden="true">#</a> checkpoint</h3><h4 id="checkpoint定义" tabindex="-1"><a class="header-anchor" href="#checkpoint定义" aria-hidden="true">#</a> checkpoint定义</h4><blockquote><p>为什么要有checkpoint？</p></blockquote><p><strong>redo日志文件组的容量是有限的，采用循环的方式向redo日志文件组中写数据会产生覆盖，checkpoint就可以解决这个问题</strong></p><p>redo日志只是为了系统奔溃后恢复脏页用的，如果对应的脏页已经刷新到了磁盘，也就是说即使现在系统奔溃，那么在重启后也用不着 使用redo日志恢复该页面了，所以该redo日志也就没有存在的必要了，那么它占用的磁盘空间就可以被后续的redo日志所重用。</p><p>也就是说：<strong>判断某些redo日志占用的磁盘空间是否可以覆盖的依据</strong>就是<strong>它对应的脏页是否已经刷新到磁盘里</strong>。</p><blockquote><p>沿用LSN中的例子解释为什么需要checkpoint？</p></blockquote><p>此时 mtr_3 刚结束，只写入 log buffer，还没刷入磁盘</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230214134791.png" alt="image-20231230214134791" tabindex="0" loading="lazy"><figcaption>image-20231230214134791</figcaption></figure><p>内存中有三个mtr的redo日志，磁盘中只有两个mtr的redo日志</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230214414849.png" alt="image-20231230214414849" tabindex="0" loading="lazy"><figcaption>image-20231230214414849</figcaption></figure><p>虽然mtr_1 和mtr_2 生成的redo 日志都已经被写到了磁盘上，但是它们修改的脏页仍然留在Buffer Pool 中，所以它们生成的redo 日志在磁盘上的空间是不可以被覆盖的</p><p>随着系统的运行，如果页a 被刷新到了磁盘，那么它对应的控制块就会从flush链表中移除</p><p>此时flush链表中只剩脏页b脏页c脏页d，mtr_1修改的脏页a已经被刷入磁盘了</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230214618107.png" alt="image-20231230214618107" tabindex="0" loading="lazy"><figcaption>image-20231230214618107</figcaption></figure><p>内存跟磁盘中的redo日志没有变化</p><p>但是mtr_1的redo日志已经没有存在的必要了，因为它产生的变化已经被持久化了，所以mtr_1产生的redo日志就可以被覆盖了</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230214645562.png" alt="image-20231230214645562" tabindex="0" loading="lazy"><figcaption>image-20231230214645562</figcaption></figure><p>InnoDB 提出了一个全局变量 <strong><code>checkpoint_lsn</code> 来代表当前系统中可以被覆盖的redo 日志总量是多少</strong>，这个变量初始值也是8704 。</p><p>页a 被刷新到了磁盘， mtr_1 生成的redo 日志就可以被覆盖了</p><p>这时候就需要进行一个增加 <code>checkpoint_lsn</code> 的操作，这个过程称之为做一次checkpoint</p><h4 id="checkpoint执行过程" tabindex="-1"><a class="header-anchor" href="#checkpoint执行过程" aria-hidden="true">#</a> checkpoint执行过程</h4><p>一次checkpoint 可以分为两个步骤：</p><ol><li><p><strong>计算一下当前系统中可以被覆盖的redo 日志对应的lsn 值最大是多少</strong></p><ul><li>redo 日志可以被覆盖，意味着它对应的脏页被刷到了磁盘 <ul><li>只要我们<strong>找出当前系统中被最早修改的脏页对应的<code>oldest_modification</code> 值（flush链表的尾部）</strong></li><li>那么，<strong>凡是在系统lsn值小于该节点的oldest_modification值时产生的redo日志都是可以被覆盖掉的</strong></li><li>我们就<strong>把该脏页的<code>oldest_modification</code> 赋值给<code>checkpoint_lsn</code></strong> 。</li></ul></li><li>比方说当前系统中页a 已经被刷新到磁盘，那么flush链表的尾节点就是页c <ul><li>该节点就是当前系统中最早修改的脏页了，它的<code>oldest_modification</code> 值为8916，我们就把8916赋值给<code>checkpoint_lsn</code></li><li>也就是说在redo日志对应的lsn值小于8916时就可以被覆盖掉</li></ul></li></ul></li><li><p><strong>将<code>checkpoint_lsn</code> 、对应的redo 日志文件组偏移量、此次checkpint 的编号写到日志文件的管理信息</strong>（就是checkpoint1 或者checkpoint2 ）中</p><ul><li>InnoDB 维护了一个目前系统做了多少次checkpoint 的变量<code>checkpoint_no</code> ，每做一次checkpoint ，该变量的值就加1。 <ul><li>该值就相当于checkpoint操作的自增主键</li></ul></li><li>计算一个lsn 值对应的redo 日志文件组偏移量是很容易的，所以可以计算得到该<code>checkpoint_lsn</code> 在redo 日志文件组中对应的偏移量<code>checkpoint_offset</code> ，然后把这三个值都写到redo 日志文件组的管理信息中。</li><li>每一个redo 日志文件都有2048 个字节的管理信息，但是上述关于checkpoint 的信息只会被写到日志文件组的第一个日志文件的管理信息中。当<code>checkpoint_no</code> 的值是偶数时，就写到<code>checkpoint1</code> 中，是奇数时，就写到<code>checkpoint2</code> 中。</li></ul><blockquote><p>此时磁盘中的redo日志文件状况</p></blockquote></li></ol><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230215546371.png" alt="image-20231230215546371" tabindex="0" loading="lazy"><figcaption>image-20231230215546371</figcaption></figure><blockquote><p>简单总结</p></blockquote><ol><li>找到flush链表的最后一个脏页，取出其LSN值（<code>oldest_modification</code>）</li><li>将这个LSN值赋给<code>checkpoint_lsn</code></li><li>将<code>checkpoint_no</code>，<code>checkpoint_lsn</code>和<code>checkpoint_offset</code>记录到日志文件组的第一个日志文件里面</li></ol><blockquote><p><strong>什么时候进行checkpoint？</strong></p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230225114466.png" alt="image-20231230225114466" tabindex="0" loading="lazy"><figcaption>image-20231230225114466</figcaption></figure><p>如果 <code>write pos</code> 追上 <code>checkpoint</code> ，表示日志文件组满了，这时候不能再写入新的 redo log记录</p><p>MySQL 得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230225135296.png" alt="image-20231230225135296" tabindex="0" loading="lazy"><figcaption>image-20231230225135296</figcaption></figure><blockquote><p><strong>系统频繁修改页面时怎么办？</strong></p></blockquote><p>一般情况下都是后台的线程在对LRU链表和flush链表进行刷脏操作，这主要因为刷脏操作比较慢，不想影响用户线程处理请求。</p><p>但是如果当前系统修改页面的操作十分频繁，这样就导致写日志操作十分频繁，系统lsn 值增长过快。</p><p>如果后台的刷脏操作不能将脏页刷出，那么系统无法及时做checkpoint</p><p>可能就需要用户线程同步的从flush链表中把那些最早修改的脏页（ oldest_modification 最小的脏页）刷新到磁盘</p><p>这样这些脏页对应的redo 日志就没用了，然后就可以去做checkpoint 了。</p><h3 id="崩溃恢复" tabindex="-1"><a class="header-anchor" href="#崩溃恢复" aria-hidden="true">#</a> 崩溃恢复</h3><h4 id="确定恢复的起点" tabindex="-1"><a class="header-anchor" href="#确定恢复的起点" aria-hidden="true">#</a> 确定恢复的起点</h4><p><code>checkpoint_lsn</code> ：代表当前系统中可以被覆盖的redo 日志总量是多少</p><ul><li><code>checkpoint_lsn</code>之前的redo日志：对应的脏页已经被刷盘了，那也就不用恢复它们了</li><li><code>checkpoint_lsn</code>之后的redo日志：它们对应的脏页可能已经被刷盘，可能没有</li></ul><p><strong>所以checkpoint_lsn就是崩溃恢复的起点</strong></p><blockquote><p>不是有两个block记录了chekpoint的信息吗？</p></blockquote><p>redo日志文件组的第一个文件的管理信息中有两个block都存储了<code>checkpoint_lsn</code> 的信息，要选取最近发生的那次<code>checkpoint</code>的信息</p><ul><li><p>衡量checkpoint 发生时间早晚的信息就是<code>checkpoint_no</code></p><ul><li><p>将<code>checkpoint1</code> 和<code>checkpoint2</code> 这两个block中的<code>checkpoint_no</code> 值读出来比一下大小</p></li><li><p>哪个的<code>checkpoint_no</code> 值更大，说明哪个block存储的就是最近的一次<code>checkpoint</code> 信息。</p></li></ul></li></ul><p>这样就能拿到最近发生的<code>checkpoint</code> 对应的<code>checkpoint_lsn</code> 值以及它在redo 日志文件组中的偏移量<code>checkpoint_offset</code> 。</p><h4 id="确定恢复的终点" tabindex="-1"><a class="header-anchor" href="#确定恢复的终点" aria-hidden="true">#</a> 确定恢复的终点</h4><p>写入redo日志的时候是按顺序写入的，所以前面的block都是满的，只有最后一个block不是满的</p><p>普通block的<code>log block header</code> 部分有一个称之为<code>LOG_BLOCK_HDR_DATA_LEN</code> 的属性</p><ul><li>该属性值记录了当前block里使用了多少字节的空间。</li><li>对于被填满的block来说，该值永远为512 。</li><li>如果该属性的值不为512 ，那么就是它了，它就是此次奔溃恢复中需要扫描的最后一个block</li></ul><h4 id="恢复的过程" tabindex="-1"><a class="header-anchor" href="#恢复的过程" aria-hidden="true">#</a> 恢复的过程</h4><p>确定了恢复的起点和恢复的终点之后，就可以按照截出来的这些redo日志来进行故障恢复了</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230222722494.png" alt="image-20231230222722494" tabindex="0" loading="lazy"><figcaption>image-20231230222722494</figcaption></figure><blockquote><p><strong>按顺序扫描</strong></p></blockquote><p>最简单的方法，但是会造成大量读取页面时造成的随机I/O</p><blockquote><p><strong>使用哈希表</strong></p></blockquote><ol><li>根据redo日志中记录的space ID和page number属性计算出散列值</li><li>将同一表空间中的相同页面的redo日志放在一起，按照生成的先后顺序用链表连接起来</li><li>遍历哈希表进行故障恢复</li></ol><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231230222949473.png" alt="image-20231230222949473" tabindex="0" loading="lazy"><figcaption>image-20231230222949473</figcaption></figure><ul><li>对同一个页面进行修改的redo日志都被放到了同一个哈希槽中 <ul><li>这样可以一次性的将一个页面修复好，可以避免很多重复读取页面的随机I/O</li></ul></li><li>同一个页面的redo日志是按照生成时间形成链表的 <ul><li>避免出现时序性错误</li></ul></li></ul><blockquote><p><strong>跳过已经刷新到磁盘的页面</strong></p></blockquote><p>每个页面都有一个<code>File Header</code> ，在<code>File Header</code> 里有一个<code>FIL_PAGE_LSN</code> 的属性</p><p>该属性记载了最近一次修改页面时对应的LSN 值（其实就是页面控制块中的<code>newest_modification</code> 值）。</p><p>对于磁盘中数据页的File Header中的FIL_PAGE_LSN属性记录的LSN值来说</p><ul><li><p>如果比<code>checkpoint_lsn</code>小，说明checkpoint之前该页被修改过，也就是有针对该页的操作被刷盘了</p></li><li><p>如果比<code>checkpoint_lsn</code>大，说明checkpoint之后该页被修改过，也就是有针对该页的操作被刷盘了</p></li></ul><p>结论就是，当页面中的<code>File Header</code>中的<code>FIL_PAGE_LSN</code> 的属性记录的LSN值比checkpoint_lsn大，说明该页已经刷盘了，凡是符合这种情况的页面就不需要再恢复了</p><h3 id="redo全流程总结" tabindex="-1"><a class="header-anchor" href="#redo全流程总结" aria-hidden="true">#</a> redo全流程总结</h3><ol><li><strong>执行一个读写事务之前，会先记录redo日志</strong><ol><li>redo日志会以组（mtr）的形式写入，保证每个mtr的原子性 <ul><li>如果一个mtr生成了多条redo日志，则在该mtr的最后一条redo日志之后加一条特殊的redo日志，标识一组日志的结束</li><li>如果一个mtr只有一条redo日志，则将该日志的头部表示日志类型的字段的首位改为1，表示这是单独的一条redo日志</li></ul></li><li>redo日志会先写入内存中的redo log buffer缓冲区，以block的形式存储在该缓冲区中 <ul><li>redo日志是按顺序追加到buffer的block里面的</li><li>block里面有两个全局变量（相当于头尾指针） <ul><li><code>buf_next_to_write</code>：用来标记已经被刷盘的日志的位置（头）</li><li><code>buf_free</code>：用来标识当前redo日志写到的位置（尾）</li></ul></li></ul></li></ol></li><li><strong>读写事务提交之后，会按照redo日志的刷盘策略判断是否进行刷盘</strong><ul><li>有个配置项可以控制刷盘策略 <ul><li>配置项为0表示不进行刷盘</li><li>配置项为1表示提交后刷盘（默认）</li><li>配置项为2表示刷入page cache，具体刷入磁盘由操作系统控制</li></ul></li><li>MySQL后台有个线程也会进行日志刷盘，每秒刷一次</li><li>三种配置的比较 <ul><li>数据安全性：1 &gt; 2 &gt; 0 <ul><li>数据库崩溃：0 会丢失1s内的数据</li><li>操作系统崩溃：0 和2 都会丢失1s内的数据</li></ul></li><li>速度：0 &gt; 2 &gt; 1</li></ul></li></ul></li><li><strong>将redo日志刷入磁盘</strong><ol><li>redo日志在磁盘中是以日志文件组的形式存放 <ul><li>几个日志文件形成一个环形链表（默认两个），redo日志以追加的形式往里面写</li><li>redo日志刷盘就是将内存中的block的镜像刷入日志文件中真实数据部分（文件里面分管理信息和真实数据两部分）</li></ul></li><li>如果没空间了，也就是写入的位置和checkpoint_lsn的位置重合了，就进行一次checkpoint，标记无用日志 <ol><li>找到buffer pool中flush链表中最后一个元素对应的旧的LSN值（也就是创建造成该脏页的操作日志的序号）</li><li>将这个序号赋给<code>checkpoint_lsn</code>，作为checkpoint的结束位置，也就是在这个LSN之前的所有日志都是可以覆盖的</li><li>最后在磁盘中日志文件组的第一个日志文件里面记录<code>checkpoint_no</code>、<code>checkpoint_lsn</code>和<code>checkpoint_offset</code></li></ol></li></ol></li><li><strong>数据库崩溃</strong></li><li><strong>数据库重启恢复</strong><ol><li>找到日志文件中最大的<code>checkpoint_lsn</code>，也就是最近一次checkpoint标记的位置，作为恢复的起点</li><li>找到存放日志的block中没存满的那个，作为恢复的终点</li><li>执行数据恢复 <ul><li>可以使用哈希表将同个表空间的同一页面的日志整理起来，统一恢复，减少重复的页面随机I/O</li><li>可以通过对比页面上记录的最后一次修改的LSN和checkpoint_lsn来判断该页是否已经刷入磁盘 <ul><li>如果页面最后一次修改的LSN大于checkpoint_lsn，说明在checkpoint之后磁盘中的该页被修改过，意思就是针对该页的修改操作已经刷盘了，所以也就不需要再恢复了</li></ul></li></ul></li></ol></li></ol><h2 id="回滚日志-undo-log" tabindex="-1"><a class="header-anchor" href="#回滚日志-undo-log" aria-hidden="true">#</a> 回滚日志(undo log)</h2><h3 id="事务回滚" tabindex="-1"><a class="header-anchor" href="#事务回滚" aria-hidden="true">#</a> 事务回滚</h3><blockquote><p><strong>什么是回滚？</strong></p></blockquote><p>事务需要保证原子性，事务中的操作要么全部完成，要么全部不完成</p><p>但是多条语句事务执行的过程中可能会出现某些问题</p><ul><li>事务执行过程中可能会遇到错误</li><li>程序员可以手动ROLLBACK回滚</li></ul><p>这些情况会导致事务执行一半就结束，而事务在执行的过程中已经改变了许多东西了</p><p>为了保证事务的原子性，需要将这些改变的东西还原，这个过程就叫回滚（rollback），这可以让这个事务什么都没做一样，符合原子性</p><blockquote><p><strong>如何实现回滚？</strong></p></blockquote><p>每当我们要进行写操作的时候，都要留一手——将回滚时需要的东西记录下来</p><ul><li>你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。</li><li>你删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。</li><li>你修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好</li></ul><p>InnoDB将这些为了回滚而记录的东西称为撤销日志（undo-log），也就是undo日志</p><p>查询操作并不会修改任何的用户记录，所以在查询操作执行的时候，并不需要记录相应的undo日志</p><p>真实的undo日志也没有上面讲的那么简单，与redo日志一样，不同操作产生的undo日志都是不一样的</p><h3 id="事务id" tabindex="-1"><a class="header-anchor" href="#事务id" aria-hidden="true">#</a> 事务ID</h3><h4 id="事务分配id的时机" tabindex="-1"><a class="header-anchor" href="#事务分配id的时机" aria-hidden="true">#</a> 事务分配ID的时机</h4><p>一个事务可以是只读事务，也可以是读写事务</p><blockquote><p>事务ID在什么时候会被分配呢？（针对MySQL5.7版本）</p></blockquote><p>某个事务执行过程中对表进行了增、删、改操作，InnoDB就会给它分配一个独一无二的事务ID</p><ul><li>对于只读事务来说，只有在它第一次对某个用户创建的临时表执行增删改的时候才会被分配事务ID，否则是不分配的 <ul><li>SELECT语句用到内部临时表时不会为它分配事务ID</li></ul></li><li>对于读写事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增删改的时候才会杯分配事务ID，否则也是不分配的 <ul><li>一个读写事务中全是查询语句，并没有执行增删改的语句，这个事务并不会被分配一个事务id</li></ul></li></ul><h4 id="事务id的生成" tabindex="-1"><a class="header-anchor" href="#事务id的生成" aria-hidden="true">#</a> 事务ID的生成</h4><p>事务ID的分配策略和<code>row_id</code>大致类似</p><ol><li>服务器会在内存中维护一个全局变量，每当需要为某个事务分配一个事务id 时，就会把该变量的值当作事务id 分配给该事务，并且把该变量自增1。</li><li>每当这个变量的值为256 的倍数时，就会将该变量的值刷新到系统表空间的页号为5 的页面中一个称之为<code>Max Trx ID</code> 的属性处，这个属性占用8 个字节的存储空间。</li><li>当系统下一次重新启动时，会将上边提到的<code>Max Trx ID</code> 属性加载到内存中，将该值加上256之后赋值给我们前边提到的全局变量（因为在上次关机时该全局变量的值可能大于<code>Max Trx ID</code> 属性值）</li></ol><p>按照<code>row_id</code>那套方法，可以保证得到的事务id值是个递增的数字——&gt;<code>日志/redo日志/redo日志格式/简单的redo日志类型</code></p><h4 id="trx-id-隐藏列" tabindex="-1"><a class="header-anchor" href="#trx-id-隐藏列" aria-hidden="true">#</a> trx_id 隐藏列</h4><p>聚簇索引的记录除了会保存完整的用户数据以外，而且还会自动添加名为<code>trx_id</code>、<code>roll_pointer</code>的隐藏列，如果用户没有在表中定义主键以及UNIQUE键，还会自动添加一个名为<code>row_id</code>的隐藏列</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240103224023879.png" alt="image-20240103224023879" tabindex="0" loading="lazy"><figcaption>image-20240103224023879</figcaption></figure><h3 id="undo日志的格式" tabindex="-1"><a class="header-anchor" href="#undo日志的格式" aria-hidden="true">#</a> undo日志的格式</h3><blockquote><p>一个事务执行过程中生成的日志和存放</p></blockquote><p>一个事务执行过程中可能会增删改多条记录，也就会会生成多个undo日志。一个增删改操作一般对应一条undo日志，有个别情况会对应两条。</p><p>这些redo日志从0开始编号，根据生成的日志被称为第0号undo日志，第1号undo日志，第2号undo日志等。这些undo日志存放在类型为FIL_PAGE_UNDO_LOG的页面里面。</p><blockquote><p>示例表</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> undo_demo <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    key1 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    col <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">KEY</span> idx_key1 <span class="token punctuation">(</span>key1<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token keyword">Engine</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><code>id</code>：主键列</p></li><li><p><code>key1</code>：普通索引</p></li><li><p><code>col</code>：普通列</p></li><li><p>每个表都会被分配一个<code>table_id</code>，这个表的 <code>table_id</code> 为 138</p></li></ul><h4 id="roll-pointer-隐藏列的含义" tabindex="-1"><a class="header-anchor" href="#roll-pointer-隐藏列的含义" aria-hidden="true">#</a> roll_pointer 隐藏列的含义</h4><p><code>roll_pointer</code>就是一个指针，放在数据页（FIL_PAGE_INDEX）的行记录里面，指向undo日志页（FIL_PAGE_UNDO_LOG）里面对应属于自己的undo日志的头部位置</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240103231012738.png" alt="image-20240103231012738" tabindex="0" loading="lazy"><figcaption>image-20240103231012738</figcaption></figure><p>roll_pointer 本质就是一个指针，指向记录对应的undo日志。</p><h4 id="insert操作对应的undo日志" tabindex="-1"><a class="header-anchor" href="#insert操作对应的undo日志" aria-hidden="true">#</a> INSERT操作对应的undo日志</h4><p>插入分为乐观插入和悲观插入，详见<code>日志/redo日志/Mini-Transation/以组的形式写入redo日志</code></p><p>但是无论怎么插入，最终都是讲这条记录放进一个数据页里面，如果希望回滚这个插入操作，只需要将这条记录删除就好了</p><p>所以<strong>插入操作对应的undo日志中最重要的就是记录这条记录的主键信息</strong></p><p>InnoDB设计了一个类型为TRX_UNDO_INSERT_REC的undo日志</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240103225506367.png" alt="image-20240103225506367" tabindex="0" loading="lazy"><figcaption>image-20240103225506367</figcaption></figure><ul><li><code>undo no</code>是在一个事务中从0开始递增的一个数值，只要事务还没提交，每生成一条undo日志，该日志的<code>undo no</code>就+1</li><li>如果记录中的主键只包含一个列，那么在类型为TRX_UNDO_INSERT_REC 的undo日志中只需要把该列占用的存储空间大小和真实值记录下来</li><li>如果记录中的主键包含多个列（复合主键），那么每个列占用的存储空间大小和对应的真实值都需要记录下来（图中的len 就代表列占用的存储空间大小， value 就代表列的真实值）。</li></ul><p>向一个表中插入记录的时候，事实上是对这个表的聚簇索引和二级索引都插入一条记录。但是插入undo日志的时候只需要考虑聚簇索引插入记录的情况就好了</p><p>聚簇索引和二级索引的记录是一一对应的，在回滚插入操作的时候，只需要知道记录的主键信息，根据主键信息进行删除操作，就能将对应二级索引里面的数据给删掉了</p><blockquote><p>例子</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">BEGIN</span><span class="token punctuation">;</span> <span class="token comment"># 显式开启一个事务，假设该事务的id为100</span>

<span class="token comment"># 插入两条记录</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> undo_demo<span class="token punctuation">(</span>id<span class="token punctuation">,</span> key1<span class="token punctuation">,</span> col<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;AWM&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;狙击枪&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&#39;M416&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;步枪&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240103230306188.png" alt="image-20240103230306188" tabindex="0" loading="lazy"><figcaption>image-20240103230306188</figcaption></figure><ul><li><code>undo no = 0</code>：事务建立来第一个undo日志</li><li><code>&lt;len, value&gt; = &lt;4, 1&gt;</code>：表中的主键只包含一个列（id列），且id列的数据类型为INT，占4个字节，真实值为1，所以记为<code>&lt;4, 1&gt;</code></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240103230313702.png" alt="image-20240103230313702" tabindex="0" loading="lazy"><figcaption>image-20240103230313702</figcaption></figure><ul><li><code>undo no = 1</code>：事务建立来第二个undo日志</li><li><code>&lt;len, value&gt; = &lt;4, 2&gt;</code>：表中的主键只包含一个列（id列），且id列的数据类型为INT，占4个字节，真实值为2，所以记为<code>&lt;4, 2&gt;</code></li></ul><p>为了最大限度的节省undo日志占用的空间，跟redo日志一样，InnoDB会给undo日志中的某些属性进行压缩处理</p><h4 id="delete操作对应的undo日志" tabindex="-1"><a class="header-anchor" href="#delete操作对应的undo日志" aria-hidden="true">#</a> DELETE操作对应的undo日志</h4><blockquote><p>数据页中的两个链表</p></blockquote><p><code>next_record</code>属性将所有记录串成两个单向链表：正常记录链表和垃圾链表</p><ul><li><p>正常记录链表就是没有被删除的记录的<code>next_record</code>组成的链表（delete mask没有被标记的）</p></li><li><p>垃圾链表就是被删除的记录的<code>next_record</code>组成的链表</p></li></ul><p>Page Header 部分有一个称之为PAGE_FREE 的属性，它指向由被删除记录组成的垃圾链表中的头节点。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240104002622274.png" alt="image-20240104002622274" tabindex="0" loading="lazy"><figcaption>image-20240104002622274</figcaption></figure><blockquote><p>DELETE语句的执行过程</p></blockquote><ol><li><code>delete mark</code>操作：将记录的<code>delete_mask</code>标记为1，修改trx_id和roll_pointer等值 <ul><li>现在的状态属于一个中间状态，主要目的是为了实现MVCC</li></ul></li></ol><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240104002750923.png" alt="image-20240104002750923" tabindex="0" loading="lazy"><figcaption>image-20240104002750923</figcaption></figure><ol start="2"><li><code>purge</code>操作：当该删除语句所在的事务提交之后，会有专门的线程来将记录从正常记录链表移到垃圾链表，然后调整一些页面信息 <ul><li>比如页面中的用户记录数量PAGE_N_RECS 、上次插入记录的位置PAGE_LAST_INSERT 、垃圾链表头节点的指针PAGE_FREE 、页面中可重用的字节数量PAGE_GARBAGE 、还有页目录的一些信息等等。</li></ul></li></ol><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240104003007834.png" alt="image-20240104003007834" tabindex="0" loading="lazy"><figcaption>image-20240104003007834</figcaption></figure><blockquote><p>DELETE语句的undo日志</p></blockquote><p>回滚是在事务提交前的，所以DELETE语句只需要回滚第一步，也就是将<code>delete_mask</code>和一些其他值改回原来的样子</p><p>InnoDB设计了TRX_UNDO_DEL_MARK_RECD类型的undo日志</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240104004753576.png" alt="image-20240104004753576" tabindex="0" loading="lazy"><figcaption>image-20240104004753576</figcaption></figure><ul><li>对一条记录进行<code>delete mark</code>操作前，需要将该记录旧的<code>trx_id</code>和<code>roll_pointer</code>隐藏列的值都记到对应的undo日志中 <ul><li>可以通过undo日志的<code>old roll_pointer</code>来找到记录修改之前对应的undo日志</li></ul></li></ul><p>在一个事务中，我们先插入了一条记录，然后又执行对该记录的删除操作</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240104005037831.png" alt="image-20240104005037831" tabindex="0" loading="lazy"><figcaption>image-20240104005037831</figcaption></figure><ul><li>执行完<code>delete mark</code>操作之后，它对应的undo日志和INSERT操作对应的undo日志串成了一个链表，这个链表称为版本链</li><li>与INSERT的undo日志不同，DELETE的undo 日志还多了一个索引列各列信息的内容，也就是说如果某个列被包含在某个索引中，那么它的相关信息就应该被记录到这个索引列各列信息部分 <ul><li>所谓的相关信息包括该列在记录中的位置（用pos 表示），该列占用的存储空间大小（用len 表示），该列实际值（用value 表示）。所以索引列各列信息存储的内容实质上就是&lt;pos, len, value&gt; 的一个列表。</li><li>这部分信息主要是用在事务提交后，对该中间状态记录做真正删除的阶段二，也就是purge 阶段中使用的</li></ul></li></ul><blockquote><p>例子</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">BEGIN</span><span class="token punctuation">;</span> <span class="token comment"># 显式开启一个事务，假设该事务的id为100</span>

<span class="token comment"># 插入两条记录</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> undo_demo<span class="token punctuation">(</span>id<span class="token punctuation">,</span> key1<span class="token punctuation">,</span> col<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;AWM&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;狙击枪&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&#39;M416&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;步枪&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment"># 删除一条记录</span>
<span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> undo_demo <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240104005354301.png" alt="image-20240104005354301" tabindex="0" loading="lazy"><figcaption>image-20240104005354301</figcaption></figure><ul><li>这是该事务中产生的第3条undo日志，所以<code>undo no</code>为2</li><li>将记录中的<code>trx_id</code>和<code>roll_pointer</code>取出来放进undo日志里面的<code>old trx_id</code>和<code>old roll_pointer</code>里面。 <ul><li>这样就可以通过<code>old roll_pointer</code> 属性值找到最近一次对该记录做改动时产生的undo日志。</li></ul></li></ul><h4 id="update操作对应的undo日志" tabindex="-1"><a class="header-anchor" href="#update操作对应的undo日志" aria-hidden="true">#</a> UPDATE操作对应的undo日志</h4><p>在执行UPDATE 语句时， InnoDB 对<strong>更新主键</strong>和<strong>不更新主键</strong>这两种情况有截然不同的处理方案。</p><h5 id="不更新主键" tabindex="-1"><a class="header-anchor" href="#不更新主键" aria-hidden="true">#</a> 不更新主键</h5><p>不更新主键的情况下，又可以分为被更新的列占用的存储空间是否发生变化两种情况</p><blockquote><p><strong>就地更新</strong></p></blockquote><p>就地更新就是直接在原纪录的基础上修改该列的值</p><p>每个列在更新前后占用的存储空间一样大时才能进行就地更新</p><p>有任何一个被更新的列更新前比更新后占用的存储空间大，或者更新前比更新后占用的存储空间小都不能进行就地更新</p><blockquote><p><strong>先删除再插入</strong></p></blockquote><p>在不更新主键的情况下，如果有任何一个被更新的列更新前和更新后占用的存储空间大小不一致，那么就需要先把这条旧的记录从聚簇索引页面中删除掉，然后再根据更新后列的值创建一条新的记录插入到页面中。</p><p>这里的删除不是<code>delete mark</code> 操作，而是真正的删除掉，也就是把这条记录从正常记录链表中移除并加入到垃圾链表中，并且修改页面中相应的统计信息（比如PAGE_FREE 、PAGE_GARBAGE 等这些信息）。</p><p>这里做真正删除操作的线程并不是DELETE 语句中做purge 操作时使用的另外专门的线程，而是由用户线程同步执行真正的删除操作</p><p>真正删除之后紧接着就要根据各个列更新后的值创建的新记录插入。</p><p>这里如果新创建的记录占用的存储空间大小不超过旧记录占用的空间，那么可以直接重用被加入到垃圾链表中的旧记录所占用的存储空间，否则的话需要在页面中新申请一段空间以供新记录使用</p><p>如果本页面内已经没有可用的空间的话，那就需要进行页面分裂操作，然后再插入新记录</p><blockquote><p><strong>不更新主键的UPDATE操作对应的undo日志</strong></p></blockquote><p>针对UPDATE 不更新主键的情况（包括就地更新和先删除旧记录再插入新记录），InnoDB设计了TRX_UNDO_UPD_EXIST_REC 类型的undo日志</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240105002646917.png" alt="image-20240105002646917" tabindex="0" loading="lazy"><figcaption>image-20240105002646917</figcaption></figure><ul><li>总体长得跟的TRX_UNDO_DEL_MARK_REC 类型的undo日志是类似的</li><li><code>n_updated</code> 属性表示本条UPDATE 语句执行后将有几个列被更新，后边跟着的<code>&lt;pos, old_len, old_value&gt;</code>分别表示被更新列在记录中的位置、更新前该列占用的存储空间大小、更新前该列的真实值。</li><li>如果在UPDATE 语句中更新的列包含索引列，那么也会添加索引列各列信息这个部分，否则的话是不会添加这个部分的。</li></ul><blockquote><p>例子</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">BEGIN</span><span class="token punctuation">;</span> <span class="token comment"># 显式开启一个事务，假设该事务的id为100</span>

<span class="token comment"># 插入两条记录</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> undo_demo<span class="token punctuation">(</span>id<span class="token punctuation">,</span> key1<span class="token punctuation">,</span> col<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;AWM&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;狙击枪&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&#39;M416&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;步枪&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment"># 删除一条记录</span>
<span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> undo_demo <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment"># 更新一条记录</span>
<span class="token keyword">UPDATE</span> undo_demo
<span class="token keyword">SET</span> key1 <span class="token operator">=</span> <span class="token string">&#39;M249&#39;</span><span class="token punctuation">,</span> col <span class="token operator">=</span> <span class="token string">&#39;机枪&#39;</span>
<span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于更新的列的大小都没有改动，可以采用就地更新的方式执行</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240105002954234.png" alt="image-20240105002954234" tabindex="0" loading="lazy"><figcaption>image-20240105002954234</figcaption></figure><ul><li>这条undo日志是id 为100 的事务中产生的第4条undo日志，所以它对应的undo no 就是3。</li><li>这条日志的roll_pointer 指向undo no 为1 的那条日志，也就是插入主键值为2 的记录时产生的那条undo日志，也就是最近一次对该记录做改动时产生的undo日志。</li><li>由于本条UPDATE 语句中更新了索引列key1 的值，所以需要记录一下索引列各列信息部分，也就是把主键和key1 列更新前的信息填入。</li></ul><h5 id="更新主键" tabindex="-1"><a class="header-anchor" href="#更新主键" aria-hidden="true">#</a> 更新主键</h5><p>在聚簇索引中，记录是按照主键值的大小连成了一个单向链表的，如果我们更新了某条记录的主键值，意味着这条记录在聚簇索引中的位置将会发生改变</p><p>比如将记录的主键值从1更新为10000，如果还有非常多的记录的主键值分布在1 ~ 10000 之间的话，那么这两条记录在聚簇索引中就有可能离得非常远，甚至中间隔了好多个页面。</p><p>针对UPDATE 语句中更新了记录主键值的这种情况， InnoDB 在聚簇索引中分了两步处理：</p><ol><li>先进行一次DELETE操作 <ul><li>执行一次<code>delete mark</code>操作，然后记录一条类型为TRX_UNDO_DEL_MARK_REC 的undo日志</li><li>等提交之后执行一次<code>purge</code>操作，异步的将中间态的记录转移到垃圾链表中</li></ul></li><li>再进行一次INSERT操作 <ul><li>根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中（需重新定位插入的位置）。</li><li>由于更新后的记录主键值发生了改变，所以需要重新从聚簇索引中定位这条记录所在的位置，然后把它插进去。</li><li>插入完成之后记录一条类型为TRX_UNDO_INSERT_REC 的undo日志</li></ul></li></ol><p>每对一条记录的主键值做改动时，会记录2条undo日志</p><h4 id="undo日志格式总结" tabindex="-1"><a class="header-anchor" href="#undo日志格式总结" aria-hidden="true">#</a> undo日志格式总结</h4><blockquote><p><strong>常用的总共有三种undo日志</strong></p></blockquote><ul><li>TRX_UNDO_INSERT_REC <ul><li>INSERT操作</li><li>修改了主键的UPDATE操作</li><li>没修改主键但是修改的列对应的空间大小改变了的UPDATE操作</li></ul></li><li>TRX_UNDO_DEL_MARK_RECD <ul><li>DELETE操作</li><li>修改了主键的UPDATE操作</li></ul></li><li>TRX_UNDO_UPD_EXIST_REC <ul><li>没修改主键并且对应修改的列的空间大小也没变的UPDATE操作</li></ul></li></ul><blockquote><p><strong>三种写操作对应执行流程</strong></p></blockquote><ul><li><p>INSERT操作会记录一个TRX_UNDO_INSERT_REC类型的undo日志，日志里面存了主键各列的信息，方便回滚的时候根据这个信息去删除对应的记录</p></li><li><p>DELETE操作分为两步</p><ul><li>首先执行<code>delete mark</code>操作，将待删除的记录的删除标记为标为1，代表该记录已经被删除了，此时会记录一个TRX_UNDO_DEL_MARK_RECD类型的undo日志，日志里面有个旧的<code>roll_pointer</code>属性，指向上一个操作这个记录的undo日志，方便回滚的时候可以根据这个回退版本</li><li>等到提交之后，执行<code>purge</code>操作，由一个专门的线程来将正常记录链表中的中间态记录（也就是刚刚被标记为1的记录）给移动到垃圾链表，并维护一些东西</li></ul></li><li><p>UPDATE操作分为两种情况，一种是改了主键，一种是没改主键</p><ul><li>改了主键的UPDATE操作可以拆分为一个DELETE操作和一个INSERT操作 <ul><li>首先执行<code>delete mark</code>操作，随后记录一条TRX_UNDO_DEL_MARK_RECD类型的日志</li><li>然后根据更新后各列的值执行一次针对全属性的INSERT操作，随后记录一条ITRX_UNDO_INSERT_REC类型的日志</li><li>改了主键的UPDATE操作记录了两个undo日志</li></ul></li><li>没改主键的UDPATE操作分为两种 <ul><li>一种是修改的列空间大小没有改变 <ul><li>这种情况下，UPDATE操作会直接在原地进行修改，然后记录一条TRX_UNDO_UPD_EXIST_REC类型的日志，这个日志长得跟DELETE操作对应的日志差不多，多记录了UPDATE操作更新的列数以及更新列的信息</li></ul></li><li>一种是修改的列空间发生了改变 <ul><li>这种情况下，UPDATE操作会先同步的删掉修改的这条记录，然后再根据更新后各列的值执行一次针对全属性的INSERT操作，随后记录一条TRX_UNDO_INSERT_REC类型的日志</li><li>如果对应页的空间不足，还需要进行页分类等操作</li></ul></li></ul></li></ul></li></ul><h3 id="undo日志的存放" tabindex="-1"><a class="header-anchor" href="#undo日志的存放" aria-hidden="true">#</a> undo日志的存放</h3><h4 id="undo页面" tabindex="-1"><a class="header-anchor" href="#undo页面" aria-hidden="true">#</a> undo页面</h4><p>表空间是由多个页面构成，页面默认大小为16kb，这些页面有许多不同的类型</p><ul><li>类型为FIL_PAGE_INDEX 的页面叫索引页，也叫数据页，是用来存储索引的</li><li>类型为FIL_PAGE_TYPE_FSP_HDR 的页面用于存储表空间头部信息的</li><li><strong>类型为FIL_PAGE_UNDO_LOG 的页面叫undo页面，就是专门用来存储undo日志的</strong></li></ul><blockquote><p>undo页面的结构是什么样的？</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240112214033289.png" alt="image-20240112214033289" tabindex="0" loading="lazy"><figcaption>image-20240112214033289</figcaption></figure><ul><li>File Header 和 File Trailer（文件头和文件尾）是每个页面的通用结构</li><li>Undo Page Header存储了该undo页面的独有特征，共有四个属性</li></ul><blockquote><p>Undo Page Header的四个属性是什么？</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240112214139597.png" alt="image-20240112214139597" tabindex="0" loading="lazy"><figcaption>image-20240112214139597</figcaption></figure><ul><li><p>TRX_UNDO_PAGE_TYPE ：表示本页面准备存储什么种类的undo日志</p><ul><li>所有的undo日志类型被分为两个大类：插入undo日志和更新undo日志 <ul><li>TRX_UNDO_INSERT （使用十进制1 表示）：类型为TRX_UNDO_INSERT_REC 的undo日志属于此大类，一般由INSERT 语句产生，或者在UPDATE 语句中有更新主键的情况也会产生此类型的undo日志。</li><li>TRX_UNDO_UPDATE （使用十进制2 表示）：除了类型为TRX_UNDO_INSERT_REC 的undo日志，其他类型的undo日志都属于这个大类，比如TRX_UNDO_DEL_MARK_REC 、TRX_UNDO_UPD_EXIST_REC，一般由DELETE 、UPDATE 语句产生的undo日志属于这个大类。</li></ul></li><li>不同大类的undo日志不能混着存储 <ul><li>例如：一个Undo页面的TRX_UNDO_PAGE_TYPE 属性值为TRX_UNDO_INSERT ，那么这个页面就只能存储类型为TRX_UNDO_INSERT_REC 的undo日志，其他类型的undo日志就不能放到这个页面中了。</li></ul></li></ul></li><li><p>TRX_UNDO_PAGE_START ：表示第一条undo日志在本页面中的起始偏移量，意思是当前页面中是从什么位置开始存储undo日志</p></li><li><p>TRX_UNDO_PAGE_FREE ：与TRX_UNDO_PAGE_START 对应，表示当前页面中存储的最后一条undo 日志结束时的偏移量，意思是从这个位置开始，可以继续写入新的undo日志</p></li><li><p>TRX_UNDO_PAGE_NODE ：代表一个List Node 结构，链表的普通节点，用于连接不同的Undo日志</p></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240112214531574.png" alt="image-20240112214531574" tabindex="0" loading="lazy"><figcaption>image-20240112214531574</figcaption></figure><h4 id="通用链表结构" tabindex="-1"><a class="header-anchor" href="#通用链表结构" aria-hidden="true">#</a> 通用链表结构</h4><blockquote><p>上面提到的链表是指什么链表？List Node 结构是什么样的？</p></blockquote><p>写入undo日志的过程中会使用到多个链表，很多链表都有相同的节点结构</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240112214816256.png" alt="image-20240112214816256" tabindex="0" loading="lazy"><figcaption>image-20240112214816256</figcaption></figure><ul><li>在某个表空间内，我们可以通过一个页的页号和在页内的偏移量来唯一定位一个节点的位置，这两个信息也就相当于指向这个节点的一个指针，所以这四个属性其实就是两根指针，一根指向前一个节点，一根指向后一个节点</li></ul><blockquote><p>如何管理这些链表节点？</p></blockquote><p>InnoDB设计了一个基节点的结构，这个结构存储了这条链表的长度（总共几个节点），头节点指针，尾节点指针</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240112215153422.png" alt="image-20240112215153422" tabindex="0" loading="lazy"><figcaption>image-20240112215153422</figcaption></figure><blockquote><p>链表的总结构</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240112215214916.png" alt="image-20240112215214916" tabindex="0" loading="lazy"><figcaption>image-20240112215214916</figcaption></figure><h4 id="undo页面链表" tabindex="-1"><a class="header-anchor" href="#undo页面链表" aria-hidden="true">#</a> undo页面链表</h4><h5 id="单个事务中的undo页面链表" tabindex="-1"><a class="header-anchor" href="#单个事务中的undo页面链表" aria-hidden="true">#</a> 单个事务中的undo页面链表</h5><p>单个事务执行过程中最多会产生4个以undo页面为节点的链表</p><blockquote><p>为什么会有链表？为什么是4个链表？</p></blockquote><ul><li>事务可能包括多个语句，一个语句可能对多个对象进行改动，一个改动就需要记录1或2条undo日志</li><li>事务执行过程中就可能产生多个undo日志，这些日志放在多个页面中，通过TRX_UNDO_PAGE_NODE 属性就可以连在一起形成链表</li><li>事务里面可能插入删除更新语句混着执行，也就会产生两种不同的undo日志</li><li>事务可能修改了普通表的内容，可能修改了临时表的内容， 所以还得分出普通表和临时表</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240112223022417.png" alt="image-20240112223022417" tabindex="0" loading="lazy"><figcaption>image-20240112223022417</figcaption></figure><blockquote><p>如何分配这四个链表？</p></blockquote><p>事务一开始并不会一次性分配这四个链表</p><p>按需分配，什么时候需要再分配，不需要就不分配</p><ol><li>刚开启事务时，一个undo链表都不会分配</li><li>当事务执行过程中有向普通表中插入记录，或执行了更新普通表主键的操作时，就为其分配一个普通表的insert undo链表</li><li>当时事务执行过程中有删除豁更新普通表的记录时，就为其分配一个普通表的update undo链表</li><li>当事务执行过程中有向临时表中插入记录，或执行了更新普通表主键的操作时，就为其分配一个临时表的insert undo链表</li><li>当时事务执行过程中有删除豁更新临时表的记录时，就为其分配一个临时表的update undo链表</li></ol><h5 id="多个事务中的undo页面链表" tabindex="-1"><a class="header-anchor" href="#多个事务中的undo页面链表" aria-hidden="true">#</a> 多个事务中的undo页面链表</h5><p>不同事务执行过程中产生的undo 日志需要被写入到不同的undo 页面链表中</p><blockquote><p>例如</p></blockquote><p>事务trx1 对普通表做了DELETE 操作，对临时表做了INSERT 和UPDATE 操作</p><p>InnoDB 会为trx1 分配3个链表</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240113131736948.png" alt="image-20240113131736948" tabindex="0" loading="lazy"><figcaption>image-20240113131736948</figcaption></figure><p>事务trx 2 对普通表做了INSERT 、UPDATE 和DELETE 操作，没有对临时表做改动。</p><p>InnoDB 会为trx 2 分配2个链表</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240113131815608.png" alt="image-20240113131815608" tabindex="0" loading="lazy"><figcaption>image-20240113131815608</figcaption></figure><h4 id="undo日志的具体写入过程" tabindex="-1"><a class="header-anchor" href="#undo日志的具体写入过程" aria-hidden="true">#</a> undo日志的具体写入过程</h4><p>undo页面链表的第一个页面存储了额外的一些属性</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240113132902087.png" alt="image-20240113132902087" tabindex="0" loading="lazy"><figcaption>image-20240113132902087</figcaption></figure><ul><li><p>Undo Log Segment Header</p><ul><li>InnoDB规定，每个undo页面链表都对应一个段，称为Undo Log Segment，链表中的页面是从这个段里面申请的</li></ul><ul><li>Undo Log Segment Header中包含了该链表对应的段的segment header 信息以及其他的一些关于这个段的信息</li></ul></li><li><p>Undo Log Header</p><ul><li>一个事务需要写入多个undo页面链表，InnoDB规定，同一个事务向一个Undo页面链表中写入的Undo日志算一个组 <ul><li>例如：trx 1 由于会分配3个Undo页面链表，也就会写入3个组的undo日志； trx 2 由于会分配2个Undo页面链表，也就会写入2个组的undo日志</li></ul></li><li>Undo Log Header就是用来记录这个组的一些属性</li></ul></li></ul><p>对于没有被重用的Undo页面链表来说：</p><ul><li>链表的第一个页面，也就是first undo page 在真正写入undo日志前，会填充Undo Page Header 、Undo Log Segment Header 、Undo Log Header 这3个部分，之后才开始正式写入undo日志。</li><li>对于其他的页面来说，也就是normal undo page 在真正写入undo日志前，只会填充Undo Page Header 。</li><li>链表的List Base Node 存放到first undo page 的Undo Log Segment Header 部分</li><li>ListNode 信息存放到每一个Undo页面的undo Page Header 部分</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240113133759902.png" alt="image-20240113133759902" tabindex="0" loading="lazy"><figcaption>image-20240113133759902</figcaption></figure><h3 id="回滚段" tabindex="-1"><a class="header-anchor" href="#回滚段" aria-hidden="true">#</a> 回滚段</h3><h4 id="回滚段的概念" tabindex="-1"><a class="header-anchor" href="#回滚段的概念" aria-hidden="true">#</a> 回滚段的概念</h4><p>一个事务执行过程中可以最多分配4个undo页面链表，同一时刻不同的事务拥有的Undo页面链表是不一样的，所以同一时刻系统中可以有许许多多个undo页面链表存在</p><p>为了更好的管理这些链表，InnoDB设计了一个Rollback Segment Header页面，这个页面中存放了各个undo页面链表第一页的页号，这个页面将这些页号称为undo slot</p><p>可以理解为：每个undo页面链表都是一个班级，链表第一页就相当于班长，找到这个班的班长就可以找到这个班的其他同学。有时学校需要向各个班级下达任务，就需要将班长们召集到一个会议室来开会，Rollback Segment Header就相当于这个会议室</p><p>每个Rollback Segment Header都对应一个段，这个段称为Rollback Segment，称为回滚段。这个段里面目前只有一个页面</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240113140917341.png" alt="image-20240113140917341" tabindex="0" loading="lazy"><figcaption>image-20240113140917341</figcaption></figure><ul><li>TRX_RSEG_MAX_SIZE ：本Rollback Segment 中管理的所有Undo页面链表中的Undo页面数量之和的最大值。</li><li>TRX_RSEG_HISTORY_SIZE ： History 链表占用的页面数量。</li><li>TRX_RSEG_HISTORY ： History 链表的基节点。</li><li>TRX_RSEG_FSEG_HEADER ：本Rollback Segment 对应的10字节大小的Segment Header 结构，通过它可以找到本段对应的INODE Entry 。</li><li>TRX_RSEG_UNDO_SLOTS ：各个Undo页面链表的first undo page 的页号集合，也就是undo slot 集合。 <ul><li>一个页号占用4 个字节，对于16KB 大小的页面来说，这TRX_RSEG_UNDO_SLOTS 部分共存储了1024 个undo slot ，所以共需1024 × 4 = 4096 个字节。</li></ul></li></ul><h4 id="从回滚段中申请undo页面链表" tabindex="-1"><a class="header-anchor" href="#从回滚段中申请undo页面链表" aria-hidden="true">#</a> 从回滚段中申请Undo页面链表</h4><p>初始情况下，未向任何一个事务分配Undo页面链表，回滚段中的所有undo slot都被设置为FIL_NULL，表示该undo slot补指向任何页面</p><blockquote><p>如何分配undo页面链表？</p></blockquote><p>从回滚段的第一个undo slot开始，判断值是否为FIL_NULL</p><ul><li>如果是FIL_NULL，那么从表空间中创建一个段（Undo Log Segment）,从这个段里面申请页面作为待分配的Undo页面链表的第一个页面，然后将undo slot的值设置为这个页面的地址。</li><li>如果不是FIL_NULL，说明该undo slot已经被分配给一个undo页面链表了，也就是说这个undo slot已经被占用了，那就跳到下一个undo slot，直到找到值为FIL_NULL为止</li></ul><p>一个Rollback Segment Header 页面中包含1024 个undo slot ，如果这1024 个undo slot 的值都不为FIL_NULL ，这就意味着这1024 个undo slot 都已经分配完了，此时由于新事务无法再获得新的Undo页面链表，就会回滚这个事务并且给用户报错</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Too many active concurrent transactions
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>事务提交的时候，占用的undo slot怎么办？</p></blockquote><p>当一个事务提交时，它所占用的undo slot 有两种命运：</p><ul><li>如果该undo slot 指向的<strong>Undo页面链表符合被重用的条件</strong>（<u>Undo页面链表只占用一个页面并且已使用空间小于整个页面的3/4</u>） <ul><li><strong>该undo slot 就处于被缓存的状态</strong><ul><li>该Undo页面链表的TRX_UNDO_STATE 属性（该属性在first undo page 的Undo Log Segment Header 部分）会被设置为TRX_UNDO_CACHED 。</li></ul></li><li><strong>被缓存的undo slot 都会被加入到一个链表</strong>，根据对应的Undo页面链表的类型不同，也会被加入到不同的链表： <ul><li>如果对应的Undo页面链表是insert undo链表，则该undo slot 会被加入insert undo cached链表。</li><li>如果对应的Undo页面链表是update undo链表，则该undo slot 会被加入update undo cached链表。</li></ul></li><li>一个回滚段就对应着上述两个cached链表 <ul><li>如果有新事务要分配undo slot 时，<strong>先从对应的cached链表中找</strong>。（先查缓存，再查数据库）</li><li>如果没有被缓存的undo slot ，<strong>才会到回滚段的Rollback Segment Header 页面中再去找</strong>。</li></ul></li></ul></li><li>如果该undo slot 指向的<strong>Undo页面链表不符合被重用的条件</strong><ul><li>如果对应的Undo页面链表是<strong>insert</strong> undo链表 <ul><li>该Undo页面链表的<strong>TRX_UNDO_STATE 属性会被设置为TRX_UNDO_TO_FREE</strong></li><li><strong>释放掉该Undo页面链表对应的段</strong>，也就意味着段中的页面可以被挪作他用</li><li><strong>把该undo slot 的值设置为FIL_NULL</strong></li></ul></li><li>如果对应的Undo页面链表是<strong>update</strong> undo链表 <ul><li>该Undo页面链表的<strong>TRX_UNDO_STATE 属性会被设置为TRX_UNDO_TO_PRUGE</strong></li><li><strong>将该undo slot 的值设置为FIL_NULL</strong></li><li>然后<strong>将本次事务写入的一组undo 日志放到History链表中</strong></li><li><u>需要注意的是，这里并不会将Undo页面链表对应的段给释放掉，因为这些undo 日志还有用</u></li></ul></li></ul></li></ul><h4 id="多个回滚段" tabindex="-1"><a class="header-anchor" href="#多个回滚段" aria-hidden="true">#</a> 多个回滚段</h4><p>一个回滚段只有1024个undo slot，也就是一个回滚段最多只支持1024个事务同时执行，数量明显不够用</p><p>InnoDB定义了128个回滚段，也就是最多支持$128 * 1024=121072$个事务同时执行</p><p>只读事务并不分配undo页面链表，MySQL5.7中默认所有刚开启的事务都是只读事务，只有事务执行过程中对记录做出改动的时候才会自动升级为读写事务</p><p>每个回滚段对应一个Rollback Segment Header页面，这128个回滚段页面的地址存放在系统表空间第5号页面的某个区域</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240113152607526.png" alt="image-20240113152607526" tabindex="0" loading="lazy"><figcaption>image-20240113152607526</figcaption></figure><p>每个8字节的格子构造如下图</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240113152628915.png" alt="image-20240113152628915" tabindex="0" loading="lazy"><figcaption>image-20240113152628915</figcaption></figure><ul><li>4字节大小的Space ID ，代表一个表空间的ID。</li><li>4字节大小的Page number ，代表一个页号。</li></ul><p>也就是说，这格子就相当于一根指针，指向表空间中的某个页面，这个页面就是Rollback Segment Header。不同的回滚段可能分布在不同的表空间中。</p><p>总的来说，在系统表空间的第5 号页面中存储了128个Rollback Segment Header页面地址，每个Rollback Segment Header 就相当于一个回滚段。在Rollback Segment Header 页面中，又包含1024 个undo slot ，每个undo slot 都对应一个Undo页面链表</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240113152820033.png" alt="image-20240113152820033" tabindex="0" loading="lazy"><figcaption>image-20240113152820033</figcaption></figure><h4 id="为事务分配undo页面链表的详细过程" tabindex="-1"><a class="header-anchor" href="#为事务分配undo页面链表的详细过程" aria-hidden="true">#</a> 为事务分配undo页面链表的详细过程</h4><blockquote><p>事务执行过程中对普通表的记录首次做改动</p></blockquote><ol><li><p>分配回滚段</p><ul><li>首先会到系统表空间的第5号页面中分配一个回滚段（获取一个Rollback Segment Header 页面的地址）</li></ul><ul><li>每个事务分配一个回滚段，轮询分配，分完了就从0号回滚段继续分</li></ul></li><li><p>分配undo slot</p><ul><li>分配到回滚段后，查询回滚段的cached链表里面有没有已经缓存了的undo slot，有就分配给这个事务来用</li></ul><ul><li>如果缓存链表中没用可用的undo slot，就去Rollback Segment Header页面中找一个可用的undo slot来分配给该事务</li></ul></li><li><p>分配undo日志段</p><ul><li>如果这个undo slot是从缓存链表中分配的，那么对应的日志段已经分配好了，就不用重新分配了</li><li>如果是新的undo slot，就需要重新分配一个Undo Log Segment，然后从该日志段中申请一个页面作为Undo页面链表的第一个页面</li></ul></li><li><p>写入undo日志</p></li></ol><blockquote><p>如果一个事务执行过程中既对普通表的记录做了改动，又对临时表的记录做了改动怎么办？</p></blockquote><p>如果一个事务在执行过程中既对普通表的记录做了改动，又对临时表的记录做了改动，那么需要为这个记录分配2个回滚段。并发执行的不同事务其实也可以被分配相同的回滚段，只要分配不同的undo slot就可以了。</p><h3 id="回滚事务" tabindex="-1"><a class="header-anchor" href="#回滚事务" aria-hidden="true">#</a> 回滚事务</h3><blockquote><p>示例SQL</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">&quot;Tom&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> <span class="token keyword">user</span> <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">&quot;Sun&quot;</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> <span class="token keyword">user</span> <span class="token keyword">SET</span> id<span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240113164450220.png" alt="image-20240113164450220" tabindex="0" loading="lazy"><figcaption>image-20240113164450220</figcaption></figure><blockquote><p>示例图中省略变长字段长度列表和空值列表，记录头信息仅展示删除标识位</p></blockquote><h4 id="执行insert语句时" tabindex="-1"><a class="header-anchor" href="#执行insert语句时" aria-hidden="true">#</a> 执行INSERT语句时</h4><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240113164429423.png" alt="image-20240113164429423" tabindex="0" loading="lazy"><figcaption>image-20240113164429423</figcaption></figure><ul><li>此时删除位为0，代表该数据可用</li><li>记录一条类型为TRX_UNDO_INSERT_REC的undo日志（undo_no = 0）</li><li>回滚指针指向的该事务的0号undo日志</li></ul><h4 id="执行未更新主键的update语句时" tabindex="-1"><a class="header-anchor" href="#执行未更新主键的update语句时" aria-hidden="true">#</a> 执行未更新主键的UPDATE语句时</h4><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240113164925682.png" alt="image-20240113164925682" tabindex="0" loading="lazy"><figcaption>image-20240113164925682</figcaption></figure><ul><li>此时删除位为0，代表该数据可用</li><li>记录一条类型为TRX_UNDO_UPD_EXIST_REC的undo日志（undo_no = 1） <ul><li>由于更新的新数据长度小于等于原数据，所以该更新操作可以就地更新</li></ul></li><li>回滚指针指向该事务的1号undo日志</li></ul><h4 id="执行更新主键的update语句时" tabindex="-1"><a class="header-anchor" href="#执行更新主键的update语句时" aria-hidden="true">#</a> 执行更新主键的UPDATE语句时</h4><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240113165147440.png" alt="image-20240113165147440" tabindex="0" loading="lazy"><figcaption>image-20240113165147440</figcaption></figure><ul><li>更新主键的更新操作有两个步骤 <ol><li>先进行一次DELETE操作 <ul><li>执行一次<code>delete mark</code>操作，然后记录一条类型为TRX_UNDO_DEL_MARK_REC 的undo日志（undo_no=2）</li><li>等提交之后执行一次<code>purge</code>操作，异步的将中间态的记录转移到垃圾链表中</li></ul></li><li>再进行一次INSERT操作 <ul><li>根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中（需重新定位插入的位置）。</li><li>由于更新后的记录主键值发生了改变，所以需要重新从聚簇索引中定位这条记录所在的位置，然后把它插进去。</li><li>插入完成之后记录一条类型为TRX_UNDO_INSERT_REC 的undo日志（undo_no = 3）</li></ul></li></ol></li></ul><h4 id="利用undo日志回滚事务" tabindex="-1"><a class="header-anchor" href="#利用undo日志回滚事务" aria-hidden="true">#</a> 利用undo日志回滚事务</h4><ol><li>通过undo no=3的日志把id=2的数据删除</li><li>通过undo no=2的日志把id=1的数据的deletemark还原成0</li><li>通过undo no=1的日志把id=1的数据的name还原成Tom</li><li>通过undo no=0的日志把id=1的数据删除</li></ol><h2 id="慢查询日志-slow-query-log" tabindex="-1"><a class="header-anchor" href="#慢查询日志-slow-query-log" aria-hidden="true">#</a> 慢查询日志(slow query log)</h2><p>慢查询日志是用来定位执行慢的 SQL的</p><h3 id="慢查询日志操作" tabindex="-1"><a class="header-anchor" href="#慢查询日志操作" aria-hidden="true">#</a> 慢查询日志操作</h3><h4 id="开启慢查询日志参数" tabindex="-1"><a class="header-anchor" href="#开启慢查询日志参数" aria-hidden="true">#</a> 开启慢查询日志参数</h4><ol><li>开启<code>slow_query_log</code></li></ol><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> slow_query_log<span class="token operator">=</span><span class="token string">&#39;ON&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240120155245278.png" alt="image-20240120155245278" tabindex="0" loading="lazy"><figcaption>image-20240120155245278</figcaption></figure><ul><li>可以看到慢查询日志已经开启，并且存放在<code>/var/lib/mysql/atguigu02-slow.log</code> 文件中</li></ul><ol start="2"><li>查询<code>long_query_time</code>阈值</li></ol><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">&#39;%long_query_time%&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240120155411897.png" alt="image-20240120155411897" tabindex="0" loading="lazy"><figcaption>image-20240120155411897</figcaption></figure><ul><li>可以看到慢查询的时间阈值为10s</li></ul><ol start="3"><li>修改<code>long_query_time</code>阈值</li></ol><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> long_query_time <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="查看慢查询条目" tabindex="-1"><a class="header-anchor" href="#查看慢查询条目" aria-hidden="true">#</a> 查看慢查询条目</h4><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>SHOW GLOBAL STATUS LIKE &#39;%Slow_queries%&#39;;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>查询当前系统中有多少条慢查询记录</li></ul><h4 id="关闭慢查询日志" tabindex="-1"><a class="header-anchor" href="#关闭慢查询日志" aria-hidden="true">#</a> 关闭慢查询日志</h4><blockquote><p><strong>永久性</strong></p></blockquote><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code>[mysqld]
<span class="token key attr-name">slow_query_log</span><span class="token punctuation">=</span><span class="token value attr-value">OFF</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>或者，把slow_query_log一项注释掉 或 删除</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code>[mysqld]
<span class="token comment">#slow_query_log =OFF</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>临时性</strong></p></blockquote><ol><li>停止MySQL慢查询日志功能</li></ol><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> slow_query_log<span class="token operator">=</span><span class="token keyword">off</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2"><li>重启MySQL服务，使用SHOW查询慢查询日志功能信息</li></ol><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">&#39;%slow%&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">&#39;%long_query_time%&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="慢查询日志分析工具" tabindex="-1"><a class="header-anchor" href="#慢查询日志分析工具" aria-hidden="true">#</a> 慢查询日志分析工具</h3><blockquote><p><strong>mysqldumpslow</strong></p></blockquote><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具<code>mysqldumpslow</code></p><h4 id="mysqldumpslow命令" tabindex="-1"><a class="header-anchor" href="#mysqldumpslow命令" aria-hidden="true">#</a> mysqldumpslow命令</h4><ol><li>查看<code>mysqldumpslow</code>的帮助信息</li></ol><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysqldumpslow <span class="token comment">--help</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240120162925744.png" alt="image-20240120162925744" tabindex="0" loading="lazy"><figcaption>image-20240120162925744</figcaption></figure><p><code>mysqldumpslow</code> 命令的具体参数如下：</p><ul><li>-a: 不将数字抽象成N，字符串抽象成S</li><li>-s: 是表示按照何种方式排序： <ul><li>c: 访问次数</li><li>l: 锁定时间</li><li>r: 返回记录</li><li>t: 查询时间</li><li>al:平均锁定时间</li><li>ar:平均返回记录数</li><li>at:平均查询时间 （默认方式）</li><li>ac:平均查询次数</li></ul></li><li>-t: 即为返回前面多少条的数据；</li><li>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</li></ul><h4 id="工作常用命令" tabindex="-1"><a class="header-anchor" href="#工作常用命令" aria-hidden="true">#</a> 工作常用命令</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#得到返回记录集最多的10个SQL</span>
mysqldumpslow <span class="token parameter variable">-s</span> r <span class="token parameter variable">-t</span> <span class="token number">10</span> /var/lib/mysql/atguigu-slow.log

<span class="token comment">#得到访问次数最多的10个SQL</span>
mysqldumpslow <span class="token parameter variable">-s</span> c <span class="token parameter variable">-t</span> <span class="token number">10</span> /var/lib/mysql/atguigu-slow.log

<span class="token comment">#得到按照时间排序的前10条里面含有左连接的查询语句</span>
mysqldumpslow <span class="token parameter variable">-s</span> t <span class="token parameter variable">-t</span> <span class="token number">10</span> <span class="token parameter variable">-g</span> <span class="token string">&quot;left join&quot;</span> /var/lib/mysql/atguigu-slow.log

<span class="token comment">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span>
mysqldumpslow <span class="token parameter variable">-s</span> r <span class="token parameter variable">-t</span> <span class="token number">10</span> /var/lib/mysql/atguigu-slow.log <span class="token operator">|</span> <span class="token function">more</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="查看sql执行成本" tabindex="-1"><a class="header-anchor" href="#查看sql执行成本" aria-hidden="true">#</a> 查看SQL执行成本</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;profiling&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240120163612906.png" alt="image-20240120163612906" tabindex="0" loading="lazy"><figcaption>image-20240120163612906</figcaption></figure><ul><li>默认该功能是关闭的</li></ul><p>设置<code>profiling=&#39;ON&#39;</code>来开启SHOW PROFILE</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SET</span> profiling <span class="token operator">=</span> <span class="token string">&#39;ON&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240120163713786.png" alt="image-20240120163713786" tabindex="0" loading="lazy"><figcaption>image-20240120163713786</figcaption></figure><p>执行查询语句后，查看当前会话有哪些profiles</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> profiles<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240120163758383.png" alt="image-20240120163758383" tabindex="0" loading="lazy"><figcaption>image-20240120163758383</figcaption></figure><ul><li>可以看到当前会话一共有两个查询</li></ul><p>去掉复数s可以查看最近一次查询的开销</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> prifile<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240120163848828.png" alt="image-20240120163848828" tabindex="0" loading="lazy"><figcaption>image-20240120163848828</figcaption></figure><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> profile cpu<span class="token punctuation">,</span>block io <span class="token keyword">for</span> query <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240120163907868.png" alt="image-20240120163907868" tabindex="0" loading="lazy"><figcaption>image-20240120163907868</figcaption></figure><h4 id="show-profile常用参数" tabindex="-1"><a class="header-anchor" href="#show-profile常用参数" aria-hidden="true">#</a> show profile常用参数</h4><p>① ALL：显示所有的开销信息。</p><p>② BLOCK IO：显示块IO开销。</p><p>③ CONTEXT SWITCHES：上下文切换开销。</p><p>④ CPU：显示CPU开销信息。</p><p>⑤ IPC：显示发送和接收开销信息。</p><p>⑥ MEMORY：显示内存开销信息。</p><p>⑦ PAGE FAULTS：显示页面错误开销信息。</p><p>⑧ SOURCE：显示和Source_function，Source_file，Source_line相关的开销信息。</p><p>⑨ SWAPS：显示交换次数开销信息。</p><h2 id="归档日志-bin-log" tabindex="-1"><a class="header-anchor" href="#归档日志-bin-log" aria-hidden="true">#</a> 归档日志(bin log)</h2><blockquote><p><strong>binlog是什么</strong></p></blockquote><p>binlog即binary log，归档日志，二进制日志文件，也叫作变更日志（update log）。</p><p>它记录了数据库所有执行的DDL 和DML 等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、 show等）。</p><blockquote><p><strong>binlog主要用在哪？</strong></p></blockquote><ul><li>一是用于数据恢复</li><li>二是用于数据复制</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240120164534711.png" alt="image-20240120164534711" tabindex="0" loading="lazy"><figcaption>image-20240120164534711</figcaption></figure><h3 id="binlog操作" tabindex="-1"><a class="header-anchor" href="#binlog操作" aria-hidden="true">#</a> binlog操作</h3><h4 id="查看开启情况" tabindex="-1"><a class="header-anchor" href="#查看开启情况" aria-hidden="true">#</a> 查看开启情况</h4><p>查看记录二进制日志是否开启：在MySQL8中默认情况下，二进制文件是开启的。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;%log_bin%&#39;</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">---------------------------------+----------------------------------+</span>
<span class="token operator">|</span> Variable_name 				  <span class="token operator">|</span> <span class="token keyword">Value</span> 							 <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------------------------------+----------------------------------+</span>
<span class="token operator">|</span> log_bin 						  <span class="token operator">|</span> <span class="token keyword">ON</span> 								 <span class="token operator">|</span>
<span class="token operator">|</span> log_bin_basename				  <span class="token operator">|</span> <span class="token operator">/</span>var<span class="token operator">/</span>lib<span class="token operator">/</span>mysql<span class="token operator">/</span>binlog			 <span class="token operator">|</span>
<span class="token operator">|</span> log_bin_index					  <span class="token operator">|</span> <span class="token operator">/</span>var<span class="token operator">/</span>lib<span class="token operator">/</span>mysql<span class="token operator">/</span>binlog<span class="token punctuation">.</span><span class="token keyword">index</span>		 <span class="token operator">|</span>
<span class="token operator">|</span> log_bin_trust_function_creators <span class="token operator">|</span> <span class="token keyword">OFF</span>								 <span class="token operator">|</span>
<span class="token operator">|</span> log_bin_use_v1_row_events		  <span class="token operator">|</span> <span class="token keyword">OFF</span> 							 <span class="token operator">|</span>
<span class="token operator">|</span> sql_log_bin 					  <span class="token operator">|</span> <span class="token keyword">ON</span> 						   		 <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------------------------------+----------------------------------+</span>
<span class="token number">6</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="日志参数设置" tabindex="-1"><a class="header-anchor" href="#日志参数设置" aria-hidden="true">#</a> 日志参数设置</h4><blockquote><p><strong>永久性（配置文件）</strong></p></blockquote><p>修改MySQL的<code>my.cnf</code> 或<code>my.ini</code> 文件可以设置二进制日志的相关参数：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code>[mysqld]
<span class="token comment">#启用二进制日志</span>
<span class="token key attr-name">log-bin</span><span class="token punctuation">=</span><span class="token value attr-value">atguigu-bin</span>
<span class="token key attr-name">binlog_expire_logs_seconds</span><span class="token punctuation">=</span><span class="token value attr-value">600</span>
<span class="token key attr-name">max_binlog_size</span><span class="token punctuation">=</span><span class="token value attr-value">100M</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果想改变日志文件的目录和名称，可以对my.cnf或my.ini中的log_bin参数修改如下：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code>[mysqld]
<span class="token key attr-name">log-bin</span><span class="token punctuation">=</span><span class="token value attr-value">&quot;/var/lib/mysql/binlog/atguigu-bin&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：新建的文件夹需要使用mysql用户，使用下面的命令即可。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">chown</span> <span class="token parameter variable">-R</span> <span class="token parameter variable">-v</span> mysql:mysql binlog
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p><strong>临时性（命令）</strong></p></blockquote><p>如果不希望通过修改配置文件并重启的方式设置二进制日志的话，还可以使用如下指令</p><ul><li><em>需要注意的是在mysql8中只有会话级别的设置，没有了global级别的设置。</em></li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># global 级别</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">set</span> <span class="token keyword">global</span> sql_log_bin<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
ERROR <span class="token number">1228</span> <span class="token punctuation">(</span>HY000<span class="token punctuation">)</span>: Variable <span class="token string">&#39;sql_log_bin&#39;</span> <span class="token operator">is</span> a <span class="token keyword">SESSION</span> variable <span class="token operator">and</span> can<span class="token punctuation">`</span>t be used
<span class="token keyword">with</span> <span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># session级别</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">SET</span> sql_log_bin<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.01</span> 秒<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="查看日志" tabindex="-1"><a class="header-anchor" href="#查看日志" aria-hidden="true">#</a> 查看日志</h4><blockquote><p>binlog的存在形式</p></blockquote><p>当MySQL创建二进制日志文件时，先创建一个以<code>filename</code>为名称、以<code>.index</code>为后缀的文件，再创建一个以<code>filename</code>为名称、以<code>.000001</code>为后缀的文件</p><p>MySQL服务重新启动一次，以<code>.000001</code>为后缀的文件就会增加一个，并且后缀名按1递增。日志文件的个数与MySQL服务启动的次数相同</p><p>如果日志长度超过了<code>max_binlog_size</code> 的上限（默认是1GB），就会创建一个新的日志文件。</p><blockquote><p>查看日志文件列表及其大小</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">SHOW</span> <span class="token keyword">BINARY</span> LOGS<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">--------------------+-----------+-----------+</span>
<span class="token operator">|</span> Log_name 		     <span class="token operator">|</span> File_size <span class="token operator">|</span> Encrypted <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">--------------------+-----------+-----------+</span>
<span class="token operator">|</span> atguigu<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000001</span> <span class="token operator">|</span> <span class="token number">156</span> 		 <span class="token operator">|</span> <span class="token keyword">No</span>		 <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">--------------------+-----------+-----------+</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看binlog的工具叫做<code>mysqlbinlog</code>，详细使用方法可以去官网看</p><blockquote><p>常见的mysqlbinlog操作</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 可查看参数帮助</span>
mysqlbinlog --no-defaults <span class="token parameter variable">--help</span>

<span class="token comment"># 查看最后100行</span>
mysqlbinlog --no-defaults --base64-output<span class="token operator">=</span>decode-rows <span class="token parameter variable">-vv</span> atguigu-bin.000002 <span class="token operator">|</span>tail-100

<span class="token comment"># 根据position查找</span>
mysqlbinlog --no-defaults --base64-output<span class="token operator">=</span>decode-rows <span class="token parameter variable">-vv</span> atguigu-bin.000002 <span class="token operator">|</span><span class="token function">grep</span> <span class="token parameter variable">-A20</span> <span class="token string">&#39;4939002&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>binlog的格式</strong></p></blockquote><p>查看binlog格式</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;binlog_format&#39;</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">---------------+-------+</span>
<span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------------+-------+</span>
<span class="token operator">|</span> binlog_format <span class="token operator">|</span> <span class="token keyword">ROW</span>   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------------+-------+</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除此之外，binlog还有2种格式，分别是<code>Statement</code>和<code>Mixed</code></p><ul><li><p><code>Statement</code>：每一条会修改数据的sql都会记录在binlog中</p><ul><li>优点：不需要记录每一行的变化，减少了binlog的日志量，节约IO，提高性能</li></ul></li><li><p><code>Row</code>：它不记录sql语句上下文相关信息，仅保存哪条记录被修改</p><ul><li>优点：row level 的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题。</li><li>5.1.5版本的MySQL才开始支持row level的复制</li></ul></li><li><p><code>Mixed</code>：从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。</p></li></ul><h4 id="日志恢复数据" tabindex="-1"><a class="header-anchor" href="#日志恢复数据" aria-hidden="true">#</a> 日志恢复数据</h4><p>mysqlbinlog恢复数据的语法如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>mysqlbinlog <span class="token punctuation">[</span>option<span class="token punctuation">]</span> filename<span class="token operator">|</span>mysql –uuser -ppass<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>使用mysqlbinlog命令来读取<code>filename</code>中的内容，然后使用mysql命令将这些内容恢复到数据库中。</li><li><code>filename</code> ：是日志文件名。</li><li><code>option</code> ：可选项，比较重要的两对option参数是<code>--start-date</code>、<code>--stop-date</code> 和 <code>--start-position</code>、<code>--stop-position</code>。 <ul><li><code>--start-date</code> 和 <code>--stop-date</code> ：可以指定恢复数据库的起始时间点和结束时间点。</li><li><code>--start-position</code>和<code>--stop-position</code> ：可以指定恢复数据的开始位置和结束位置。</li></ul></li></ul><blockquote><p>注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复</p><p>例如<code>atguigu-bin.000001</code>必须在<code>atguigu-bin.000002</code>之前恢复。</p></blockquote><h4 id="其他场景" tabindex="-1"><a class="header-anchor" href="#其他场景" aria-hidden="true">#</a> 其他场景</h4><p>二进制日志可以通过数据库的全量备份和二进制日志中保存的增量信息，完成数据库的无损失恢复。</p><p>但是，如果遇到数据量大、数据库和数据表很多（比如分库分表的应用）的场景，用二进制日志进行数据恢复，是很有挑战性的，因为起止位置不容易管理。</p><p>在这种情况下，一个有效的解决办法是配置主从数据库服务器，甚至是一主多从的架构，把二进制日志文件的内容通过中继日志，同步到从数据库服务器中，这样就可以有效避免数据库故障导致的数据异常等问题</p><h2 id="日志总结-redo-undo-binlog" tabindex="-1"><a class="header-anchor" href="#日志总结-redo-undo-binlog" aria-hidden="true">#</a> 日志总结(redo/undo/binlog)</h2><h3 id="三种日志简介" tabindex="-1"><a class="header-anchor" href="#三种日志简介" aria-hidden="true">#</a> 三种日志简介</h3><ul><li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li><li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li><li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li></ul><h3 id="undo日志的作用" tabindex="-1"><a class="header-anchor" href="#undo日志的作用" aria-hidden="true">#</a> undo日志的作用</h3><blockquote><p>undo log 两大作用</p></blockquote><ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li><li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li></ul><h4 id="事务回滚-rollback" tabindex="-1"><a class="header-anchor" href="#事务回滚-rollback" aria-hidden="true">#</a> 事务回滚(ROLLBACK)</h4><p>每条语句都会用到事务，查询语句是只读事务，增删改语句是读写事务</p><blockquote><p><strong>没有提交事务之前MySQL崩溃了，这时候需要进行回滚，但是要怎么回滚到事务之前的数据呢？</strong></p></blockquote><p>记录下回滚需要的信息，要回滚的时候就通过这些信息实现了</p><p>实现这一机制的就是<strong>回滚日志undo log</strong>，它<strong>保证了事务的原子性（Automicity）</strong></p><p>undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240129170154134.png" alt="image-20240129170154134" tabindex="0" loading="lazy"><figcaption>image-20240129170154134</figcaption></figure><p>每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里</p><ul><li><strong>INSERT：记下新增记录的主键值</strong><ul><li>回滚时通过记录的主键值将其删除</li></ul></li><li><strong>DELETE：记下删除记录的索引信息</strong>（聚簇索引以及其他索引） <ul><li>DELETE操作分为两部分 <ul><li>delete mark：将行记录中的删除标识（<code>delete_mark</code>）标为1</li><li>purge：提交之后再将其移动到垃圾链表</li></ul></li><li>回滚时通过记录的索引将该记录的所有（聚簇索引和二级索引里面的行记录的）<code>delete_mark</code>恢复为0</li></ul></li><li>UPDATE：更新语句分为两种情况，不同情况下记录的日志不一样 <ul><li><strong>不更新主键：记录下修改记录的索引信息，以及修改列之前的信息</strong><ul><li>回滚时通过记录的索引将该记录被修改的信息还原</li></ul></li><li><strong>更新主键：更新了主键的修改语句相当于执行了一次DELETE再执行一次INSERT</strong>，日志的记录按照DELETE和INSERT来记 <ul><li>回滚时按照DELETE和INSERT的回滚来执行</li></ul></li></ul></li></ul><p>undo日志分为两种，<code>insert undo</code>和<code>update undo</code></p><ul><li><p><code>insert undo</code>：作为记录的第一条日志，不用也没有记录上一个版本的日志信息（<code>old_trx_id</code>和<code>old_roll_pointer</code>）</p></li><li><p><code>update undo</code>：这种就需要记录上一版本的日志信息了，有这些信息就可以将所有undo日志串成一个链表（版本链）</p></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240129172332705.png" alt="image-20240129172332705" tabindex="0" loading="lazy"><figcaption>image-20240129172332705</figcaption></figure><h4 id="多版本并发控制-mvcc" tabindex="-1"><a class="header-anchor" href="#多版本并发控制-mvcc" aria-hidden="true">#</a> 多版本并发控制(MVCC)</h4><blockquote><p><strong>undo log 还有一个作用，通过 ReadView + undo log 实现 MVCC（多版本并发控制）</strong></p></blockquote><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们的快照读（普通 select 语句）是通过 Read View + undo log 来实现的，它们的区别在于创建 Read View 的时机不同：</p><ul><li><strong>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View</strong><ul><li>也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致</li><li>因为可能这期间另外一个事务修改了该记录，并提交了事务。</li></ul></li><li><strong>「可重复读」隔离级别是启动事务时生成一个 Read View</strong><ul><li>然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。</li></ul></li></ul><p>这两个<strong>隔离级别实现</strong>是通过 「<strong>事务的 Read View 里的字段</strong><code>(trx_id的最大最小值，创建当前ReadView的事务id，当前活跃的事务id)</code>」 和 「<strong>记录中的两个隐藏列</strong><code>(trx_id 和 roll_pointer)</code>」的<strong>比对</strong></p><p>如果不满足可见行，就会顺着 undo log 版本链里找到满足其可见性的记录，从而控制并发事务访问同一个记录时的行为</p><h3 id="bufferpool的作用" tabindex="-1"><a class="header-anchor" href="#bufferpool的作用" aria-hidden="true">#</a> BufferPool的作用</h3><blockquote><p>BufferPool是用来缓存数据用的</p></blockquote><p>MySQL的数据存在磁盘中，更新一条数据得先从磁盘里面读取该记录，然后在内存中操作该数据</p><p>修改完的数据缓存在BufferPool中，下次就不需要从磁盘中获取了</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240129193718502.png" alt="image-20240129193718502" tabindex="0" loading="lazy"><figcaption>image-20240129193718502</figcaption></figure><ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li><li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致） <ul><li>为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</li></ul></li></ul><h4 id="bufferpool缓存的东西" tabindex="-1"><a class="header-anchor" href="#bufferpool缓存的东西" aria-hidden="true">#</a> BufferPool缓存的东西</h4><p>InnoDB将存储的数据分为页，以页作为磁盘和内存交互的基本单位，所以缓存数据的BufferPool的基本单位也是页（一页默认16kb）</p><p>在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p><ul><li>MySQL 刚启动的时候使用的虚拟内存空间很大，而使用到的物理内存空间却很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，申请物理内存，接着将虚拟地址和物理地址建立映射关系。</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240129194248772.png" alt="image-20240129194248772" tabindex="0" loading="lazy"><figcaption>image-20240129194248772</figcaption></figure><ul><li>BufferPool除了缓存数据页和索引页之外，还会缓存Undo页，插入缓存，自适应哈希索引，锁等等</li></ul><blockquote><p><strong>undo页是记录什么的？</strong></p></blockquote><p>开启事务后，InnoDB 更新记录前，首先要记录相应的 undo log</p><p>如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面</p><blockquote><p><strong>查一条记录缓存一条记录吗？</strong></p></blockquote><p>查询一条记录时，InnoDB 把整个页的数据加载到 Buffer Pool 中</p><p>将页加载到 Buffer Pool 后，再通过页里的「页目录」去定位到某条具体的记录。</p><h4 id="bufferpool的管理" tabindex="-1"><a class="header-anchor" href="#bufferpool的管理" aria-hidden="true">#</a> BufferPool的管理</h4><blockquote><p><strong>BufferPool中有三种页面</strong></p></blockquote><ul><li><strong>空闲页（free page）</strong>：BufferPool申请的新页，里面没有用户记录</li><li><strong>干净页（clean page）</strong>：加载到内存中但是没有发生修改的页面</li><li><strong>脏页（dirty page）</strong>：内存中发生修改操作的页面</li></ul><blockquote><p><strong>BufferPool通过三条链表来管理页面</strong></p></blockquote><ul><li><strong>free链表</strong>：将空闲页串成一个链表，从磁盘中加载新的数据页时就从里面去一个出来用</li><li><strong>flush链表</strong>：将脏页串成一个链表</li><li><strong>LRU链表</strong>：将加载到内存中的页面串成一个链表，这些页面包括脏页和干净页，用来作内存淘汰用 <ul><li>LRU链表分为两段，一段是young区，存的是热数据，一段是old区，存的是冷数据</li><li>判断热数据通过两个指标 <ul><li>不止访问一次（解决预读问题）</li><li>第一次访问和最后一次访问的时间间隔小于某个值（默认是1s）（解决扫描问题）</li></ul></li><li>young区的优化：如果访问的是前1/4的数据则不移动，访问后面的数据才会移动到链表头 <ul><li>解决频繁访问热点数据导致young区不断更新链表头节点的问题</li></ul></li></ul></li></ul><h3 id="redo日志的作用" tabindex="-1"><a class="header-anchor" href="#redo日志的作用" aria-hidden="true">#</a> redo日志的作用</h3><p>BufferPool是基于内存的，一旦断电重启了，还没来得及刷盘的脏页就丢了</p><p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，<strong>这个时候更新就算完成了</strong>。</p><p>InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p><blockquote><p><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240129211701535.png" alt="image-20240129211701535" tabindex="0" loading="lazy"><figcaption>image-20240129211701535</figcaption></figure><h4 id="redo日志的定义-1" tabindex="-1"><a class="header-anchor" href="#redo日志的定义-1" aria-hidden="true">#</a> redo日志的定义</h4><p>redo log 是物理日志，记录了某个数据页做了什么修改</p><p>比如<strong>对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</strong>，每当执行一个事务就会产生这样的一条或者多条物理日志。</p><p>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</p><p>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p><h4 id="undo页面的redo日志" tabindex="-1"><a class="header-anchor" href="#undo页面的redo日志" aria-hidden="true">#</a> undo页面的redo日志</h4><p>开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log</p><p>如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log</p><p>undo log 会写入 Buffer Pool 中的 Undo 页面。</p><p><strong>在内存修改该 Undo 页面后，需要记录对应的 redo log</strong>。</p><h4 id="redo日志和undo日志的区别" tabindex="-1"><a class="header-anchor" href="#redo日志和undo日志的区别" aria-hidden="true">#</a> redo日志和undo日志的区别</h4><p>这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：</p><ul><li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li><li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li></ul><p>事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240129213011826.png" alt="image-20240129213011826" tabindex="0" loading="lazy"><figcaption>image-20240129213011826</figcaption></figure><h4 id="redo日志的意义-1" tabindex="-1"><a class="header-anchor" href="#redo日志的意义-1" aria-hidden="true">#</a> redo日志的意义</h4><blockquote><p>redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？</p></blockquote><p>写入 redo log 的方式使用了追加操作， 所以磁盘操作是<strong>顺序写</strong>，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是<strong>随机写</strong>。</p><p>磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。</p><p>针对「顺序写」为什么比「随机写」更快这个问题，可以比喻为你有一个本子，按照顺序一页一页写肯定比写一个字都要找到对应页写快得多。</p><p>可以说这是 WAL 技术的另外一个优点：<strong>MySQL 的写操作从磁盘的「随机写」变成了「顺序写」</strong>，提升语句的执行性能。这是因为 MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上 。</p><blockquote><p>为什么需要 redo log 有两个答案</p></blockquote><ul><li><strong>实现事务的持久性，让 MySQL 有崩溃恢复(crash-safe) 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li><li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li></ul><h4 id="redo日志的刷盘" tabindex="-1"><a class="header-anchor" href="#redo日志的刷盘" aria-hidden="true">#</a> redo日志的刷盘</h4><blockquote><p>产生的 redo log 是直接写入磁盘的吗？</p></blockquote><p>执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I/O 操作，而且磁盘的运行速度远慢于内存。</p><p>redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240129214136840.png" alt="image-20240129214136840" tabindex="0" loading="lazy"><figcaption>image-20240129214136840</figcaption></figure><p>redo log buffer 默认大小 16 MB，可以通过 <code>innodb_log_Buffer_size</code> 参数动态的调整大小</p><p>增大它的大小可以让 MySQL 处理「大事务」时不必写入磁盘，进而提升写 IO 性能。</p><blockquote><p><strong>redo日志的刷盘时机</strong></p></blockquote><ul><li>MySQL 正常关闭时；</li><li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li><li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</li></ul><blockquote><p><code>innodb_flush_log_at_trx_commit</code> 参数控制刷盘时机</p></blockquote><p>默认参数为1</p><ul><li><strong>参数为 0 <strong>：表示每次事务提交时 ，还是</strong>将 redo log 留在 redo log buffer 中</strong><ul><li>该模式下在事务提交时不会主动触发写入磁盘的操作</li></ul></li><li><strong>参数为 1</strong> ：表示每次事务提交时，都<strong>将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong><ul><li>这样可以保证 MySQL 异常重启之后数据不会丢失。</li></ul></li><li><strong>参数为 2</strong> ：表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log <strong>写到 redo log 文件</strong><ul><li><strong>注意写入到「 redo log 文件」并不意味着写入到了磁盘</strong>，因为操作系统的文件系统中有个 Page Cache，Page Cache 是专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存。</li></ul></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240129214705162.png" alt="image-20240129214705162" tabindex="0" loading="lazy"><figcaption>image-20240129214705162</figcaption></figure><blockquote><p>参数为0或者2的时，什么时候才会将日志刷入磁盘</p></blockquote><p>InnoDB 的后台线程每隔 1 秒：</p><ul><li>针对参数 0 ：会把缓存在 redo log buffer 中的 redo log ，通过调用 <code>write()</code> 写到操作系统的 Page Cache，然后调用 <code>fsync()</code> 持久化到磁盘。<strong>所以参数为 0 的策略，MySQL 进程的崩溃会导致上一秒钟所有事务数据的丢失</strong>;</li><li>针对参数 2 ：调用 fsync，将缓存在操作系统中 Page Cache 里的 redo log 持久化到磁盘。 <ul><li><strong>所以参数为 2 的策略，较取值为 0 情况下更安全</strong></li><li><strong>因为 MySQL 进程的崩溃并不会丢失数据，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失</strong>。</li></ul></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240129215129557.png" alt="image-20240129215129557" tabindex="0" loading="lazy"><figcaption>image-20240129215129557</figcaption></figure><blockquote><p><strong>三种策略的应用场景</strong></p></blockquote><p>这三个参数的数据安全性和写入性能的比较如下：</p><ul><li>数据安全性：参数 1 &gt; 参数 2 &gt; 参数 0</li><li>写入性能：参数 0 &gt; 参数 2&gt; 参数 1</li></ul><p>所以，数据安全性和写入性能是熊掌不可得兼的，<strong>要不追求数据安全性，牺牲性能；要不追求性能，牺牲数据安全性</strong>。</p><ul><li>在一些对数据安全性要求比较高的场景中，显然 <code>innodb_flush_log_at_trx_commit</code> 参数需要设置为 1。</li><li>在一些可以容忍数据库崩溃时丢失 1s 数据的场景中，我们可以将该值设置为 0，这样可以明显地减少日志同步到磁盘的 I/O 操作。</li><li>安全性和性能折中的方案就是参数 2，虽然参数 2 没有参数 0 的性能高，但是数据安全性方面比参数 0 强，因为参数 2 只要操作系统不宕机，即使数据库崩溃了，也不会丢失数据，同时性能方便比参数 1 高。</li></ul><h4 id="redo日志存储" tabindex="-1"><a class="header-anchor" href="#redo日志存储" aria-hidden="true">#</a> redo日志存储</h4><p>默认情况下， InnoDB 存储引擎有 1 个重做日志文件组( redo log Group）</p><p>「重做日志文件组」由有 2 个 redo log 文件组成，这两个 redo 日志的文件名叫 ：<code>ib_logfile0</code> 和 <code>ib_logfile1</code></p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240129220250466.png" alt="image-20240129220250466" tabindex="0" loading="lazy"><figcaption>image-20240129220250466</figcaption></figure><p>在重做日志组中，每个 redo log File 的大小是固定且一致的</p><p>假设每个 redo log File 设置的上限是 1 GB，那么总共就可以记录 2GB 的操作。</p><p>重做日志文件组是以<strong>循环写</strong>的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。</p><p>InnoDB 存储引擎会先写 ib_logfile0 文件，当 ib_logfile0 文件被写满的时候，会切换至 ib_logfile1 文件，当 ib_logfile1 文件也被写满时，会切换回 ib_logfile0 文件。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240129220317911.png" alt="image-20240129220317911" tabindex="0" loading="lazy"><figcaption>image-20240129220317911</figcaption></figure><blockquote><p>为什么要这么设计？</p></blockquote><p>redo日志是用来防止BufferPool中脏页丢失的，那BufferPool将脏页刷盘之后，对应的redo日志也就失去作用了，这时候就应该擦除掉</p><p>redo日志是循环写的方式，相当于一个环形</p><p>InnoDB 用 <code>write pos</code>（<code>flushed_to_disk_lsn</code>） 表示 redo日志当前记录写到磁盘的位置</p><p>用<code>checkpoint</code>（ <code>checkpoint_lsn</code> ）表示当前可以擦除的位置</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240130153823275.png" alt="image-20240130153823275" tabindex="0" loading="lazy"><figcaption>image-20240130153823275</figcaption></figure><ul><li><code>write pos</code> 和 <code>checkpoint</code> 的移动都是顺时针方向；</li><li><code>write pos</code> ～ <code>checkpoint</code> 之间的部分（图中的红色部分），用来记录新的更新操作；</li><li><code>check point</code> ～ <code>write pos</code> 之间的部分（图中蓝色部分）：待落盘的脏数据页记录；</li></ul><blockquote><p>因此所以针对并发量大的系统，适当设置 redo log 的文件大小非常重要</p></blockquote><p>如果 write pos 追上了 checkpoint，就意味着 <strong>redo log 文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞</strong></p><ol><li>此时<strong>会停下来将 Buffer Pool 中的脏页刷新到磁盘中</strong></li><li><strong>然后标记 redo log 哪些记录可以被擦除</strong></li><li><strong>接着对旧的 redo log 记录进行擦除</strong></li><li><strong>等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针）</strong></li><li>然后 MySQL 恢复正常运行，继续执行新的更新操作</li></ol><p>所以，一次 checkpoint 的过程就是脏页刷新到磁盘中变成干净页，然后标记 redo log 哪些记录可以被覆盖的过程。</p><h4 id="redo日志实现数据恢复" tabindex="-1"><a class="header-anchor" href="#redo日志实现数据恢复" aria-hidden="true">#</a> redo日志实现数据恢复</h4><ol><li>找到日志文件中最大的<code>checkpoint_lsn</code>，也就是最近一次checkpoint标记的位置，作为恢复的起点</li><li>找到存放日志的block中没存满的那个，作为恢复的终点</li><li>执行数据恢复</li></ol><h3 id="binlog的作用" tabindex="-1"><a class="header-anchor" href="#binlog的作用" aria-hidden="true">#</a> binlog的作用</h3><h4 id="binlog的定义" tabindex="-1"><a class="header-anchor" href="#binlog的定义" aria-hidden="true">#</a> binlog的定义</h4><p>undo log 和 redo log 这两个日志都是 Innodb 存储引擎生成的。</p><p>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog</p><p>事务提交的时候，会将该事务执行过程中产生的所有 binlog 统一写入 binlog 文件。</p><p>binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p><h4 id="redo-log和binlog的区别" tabindex="-1"><a class="header-anchor" href="#redo-log和binlog的区别" aria-hidden="true">#</a> redo log和binlog的区别</h4><blockquote><p>为什么有了 binlog， 还要有 redo log？</p></blockquote><p>最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档</p><p>InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用 redo log 来实现 crash-safe 能力</p><blockquote><p><strong>redo log和binlog的四个不同之处</strong></p></blockquote><ol><li><p><strong>适用对象不同</strong></p><ul><li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</li><li>redo log 是 Innodb 存储引擎实现的日志</li></ul></li><li><p><strong>文件格式不同</strong></p><ul><li>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下： <ul><li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中，主从复制中 slave 端再根据 SQL 语句重现 <ul><li>相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志</li><li>但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li></ul></li><li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了） <ul><li>ROW格式不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录</li><li>比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</li></ul></li><li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li></ul></li><li>redo log 是物理日志，记录的是在某个数据页做了什么修改 <ul><li>比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</li></ul></li></ul></li><li><p><strong>写入方式不同</strong></p><ul><li>binlog ：追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li><li>redo log ：循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志</li></ul></li><li><p><strong>用途不同</strong></p><ul><li>binlog ：备份恢复、主从复制</li><li>redo log ：掉电等故障恢复</li></ul></li></ol><blockquote><p>如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？</p></blockquote><p>这个时候属于备份问题了，不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。</p><p>因为 redo log 文件是循环写，是会边写边擦除日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。</p><p>binlog 文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在 binlog 上的数据，都可以恢复，所以如果不小心整个数据库的数据被删除了，得用 binlog 文件恢复数据</p><h4 id="binlog实现主从复制" tabindex="-1"><a class="header-anchor" href="#binlog实现主从复制" aria-hidden="true">#</a> binlog实现主从复制</h4><p>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。</p><p>复制的过程就是将 binlog 中的数据从主库传输到从库上。</p><p>这个过程一般是<strong>异步</strong>的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240130160322127.png" alt="image-20240130160322127" tabindex="0" loading="lazy"><figcaption>image-20240130160322127</figcaption></figure><p>MySQL 集群的主从复制过程梳理成 3 个阶段：</p><ul><li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。 <ul><li>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog</li><li>再提交事务，更新存储引擎中的数据</li><li>事务提交完成后，返回给客户端 <code>“操作成功” </code>的响应。</li></ul></li><li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。 <ul><li>从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志</li><li>把接收到的 binlog 信息写入 relay log 的中继日志里，再返回给主库 <code>“复制成功”</code> 的响应。</li></ul></li><li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。 <ul><li>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志</li><li>然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li></ul></li></ul><p>在完成主从复制之后，就可以实现读写分离，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240130160517205.png" alt="image-20240130160517205" tabindex="0" loading="lazy"><figcaption>image-20240130160517205</figcaption></figure><blockquote><p>从库是不是越多越好？</p></blockquote><p>因为从库数量增加，从库连接上来的 I/O 线程也比较多，<strong>主库也要创建同样多的 log dump 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽</strong>。</p><p>所以在实际使用中，一个主库一般跟 2～3 个从库（1 套数据库，1 主 2 从 1 备主），这就是一主多从的 MySQL 集群结构</p><blockquote><p>MySQL 主从复制还有哪些模型？</p></blockquote><p>主要有三种：</p><ul><li><strong>同步复制</strong>：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果 <ul><li>这种方式在实际项目中，基本上没法用，原因有两个： <ul><li>性能很差，因为要复制到所有节点才返回响应；</li><li>可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。</li></ul></li></ul></li><li><strong>异步复制</strong>（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。 <ul><li>这种模式一旦主库宕机，数据就会发生丢失。</li></ul></li><li><strong>半同步复制</strong>：事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行 <ul><li>MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，</li><li>比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。</li><li>这种<strong>半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险</strong></li></ul></li></ul><h4 id="binlog的刷盘" tabindex="-1"><a class="header-anchor" href="#binlog的刷盘" aria-hidden="true">#</a> binlog的刷盘</h4><p>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。</p><p>一个事务的 binlog 是不能被拆开的，无论这个事务有多大（比如有很多条语句），也要保证一次性写入。</p><p>这是因为有一个线程只能同时有一个事务在执行的设定</p><p>所以每当执行一个 <code>begin / start transaction</code> 的时候，就会默认提交上一个事务</p><p>这样如果一个事务的 <code>binlog</code> 被拆开的时候，在备库执行就会被当做多个事务分段自行，这样破坏了原子性，是有问题的。</p><p>MySQL 给每个线程分配了一片内存用于缓冲 binlog ，该内存叫 binlog cache</p><p>参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p><blockquote><p>什么时候 binlog cache 会写到 binlog 文件？</p></blockquote><p>在事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 文件中，并清空 binlog cache。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240130211058964.png" alt="image-20240130211058964" tabindex="0" loading="lazy"><figcaption>image-20240130211058964</figcaption></figure><p>虽然每个线程有自己 binlog cache，但是最终都写到同一个 binlog 文件：</p><ul><li>图中的 write，指的就是指把日志写入到 binlog 文件，但是并没有把数据持久化到磁盘，因为数据还缓存在文件系统的 page cache 里，write 的写入速度还是比较快的，因为不涉及磁盘 I/O。</li><li>图中的 fsync，才是将数据持久化到磁盘的操作，这里就会涉及磁盘 I/O，所以频繁的 fsync 会导致磁盘的 I/O 升高。</li></ul><blockquote><p>binlog 刷盘的策略怎么控制的？</p></blockquote><p>MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：</p><ul><li>sync_binlog = 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；</li><li>sync_binlog = 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；</li><li>sync_binlog =N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li></ul><blockquote><p>如何选择binlog 刷盘策略？</p></blockquote><p>在MySQL中系统默认的设置是 <code>sync_binlog = 0</code>，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦主机发生异常重启，还没持久化到磁盘的数据就会丢失。</p><p>而当 sync_binlog 设置为 1 的时候，是最安全但是性能损耗最大的设置。因为当设置为 1 的时候，即使主机发生异常重启，最多丢失一个事务的 binlog，而已经持久化到磁盘的数据就不会有影响，不过就是对写入性能影响太大。</p><p>如果能容少量事务的 binlog 日志丢失的风险，为了提高写入的性能，一般会 sync_binlog 设置为 100~1000 中的某个数值。</p><h3 id="两阶段提交" tabindex="-1"><a class="header-anchor" href="#两阶段提交" aria-hidden="true">#</a> 两阶段提交</h3><h4 id="update语句的执行过程" tabindex="-1"><a class="header-anchor" href="#update语句的执行过程" aria-hidden="true">#</a> update语句的执行过程</h4><p>当优化器分析出成本最小的执行计划后，执行器就按照执行计划开始进行更新操作。</p><p>具体更新一条记录 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 的流程如下:</p><ol><li><p>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：</p><ul><li>如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li><li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li></ul></li><li><p>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：</p><ul><li>如果一样的话就不进行后续更新流程；</li><li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li></ul></li><li><p>InnoDB层更新记录前</p><ul><li>开启事务</li></ul><ul><li>记录相应的 undo log <ul><li>因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo lo</li><li>undo log 会写入 Buffer Pool 中的 Undo 页面</li><li>在内存修改该 Undo 页面后，需要记录对应的 redo log</li></ul></li></ul></li><li><p>InnoDB 层开始更新记录</p><ul><li>先更新内存（同时标记为脏页）</li><li>然后将记录写到 redo log 里面，这个时候更新就算完成了</li><li>为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong><ul><li>MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li></ul></li></ul></li><li><p>在一条更新语句执行完成后</p><ul><li>开始记录该语句对应的 binlog</li><li>此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件</li><li>在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li></ul></li><li><p>事务提交，此时执行<strong>两阶段提交</strong></p></li></ol><blockquote><p>什么是两阶段提交？</p></blockquote><h4 id="两阶段提交的作用" tabindex="-1"><a class="header-anchor" href="#两阶段提交的作用" aria-hidden="true">#</a> 两阶段提交的作用</h4><p>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。</p><p>在持久化 redo log 和 binlog 这两份日志的时候，如果出现半成功的状态，就会造成主从环境的数据不一致性。</p><p>因为 redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。</p><blockquote><p>例子</p></blockquote><p>假设 id = 1 这行数据的字段 name 的值原本是 <code>&#39;jay&#39;</code></p><p>然后执行 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code></p><p>如果在持久化 redo log 和 binlog 两个日志的过程中，出现了半成功状态，那么就有两种情况：</p><ul><li><strong>如果在将 redo log 刷入到磁盘之后， MySQL 突然宕机了，而 binlog 还没有来得及写入</strong>。 <ul><li>MySQL 重启后，通过 redo log 能将 Buffer Pool 中 id = 1 这行数据的 name 字段恢复到新值 xiaolin</li><li>但是 binlog 里面没有记录这条更新语句，在主从架构中，binlog 会被复制到从库，由于 binlog 丢失了这条更新语句，从库的这一行 name 字段是旧值 jay，与主库的值不一致性；</li></ul></li><li><strong>如果在将 binlog 刷入到磁盘之后， MySQL 突然宕机了，而 redo log 还没有来得及写入</strong>。 <ul><li>由于 redo log 还没写，崩溃恢复以后这个事务无效，所以 id = 1 这行数据的 name 字段还是旧值 jay</li><li>而 binlog 里面记录了这条更新语句，在主从架构中，binlog 会被复制到从库，从库执行了这条更新语句，那么这一行 name 字段是新值 xiaolin，与主库的值不一致性；</li></ul></li></ul><blockquote><p><strong>解决办法</strong></p></blockquote><p><strong>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决</strong></p><p><strong>两阶段提交其实是分布式事务一致性协议</strong>，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</p><p><strong>两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是「准备（Prepare）阶段」和「提交（Commit）阶段」</strong></p><p>每个阶段都由协调者（Coordinator）和参与者（Participant）共同完成。</p><blockquote><p>例子</p></blockquote><p>举个例子，两位拳击手（参与者）开始比赛之前，裁判（协调者）会在中间确认两位拳击手的状态，类似于问你准备好了吗？</p><ul><li><strong>准备阶段</strong>：裁判（协调者）会依次询问两位拳击手（参与者）是否准备好了，然后拳击手听到后做出应答，如果觉得自己准备好了，就会跟裁判说准备好了；如果没有自己还没有准备好（比如拳套还没有带好），就会跟裁判说还没准备好。</li><li><strong>提交阶段</strong>：如果两位拳击手（参与者）都回答准备好了，裁判（协调者）宣布比赛正式开始，两位拳击手就可以直接开打；如果任何一位拳击手（参与者）回答没有准备好，裁判（协调者）会宣布比赛暂停，对应事务中的回滚操作。</li></ul><h4 id="两阶段提交的过程" tabindex="-1"><a class="header-anchor" href="#两阶段提交的过程" aria-hidden="true">#</a> 两阶段提交的过程</h4><p>在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护 binlog 日志与 InnoDB 的 redo log</p><p>为了保证这两个日志的一致性，MySQL 使用了<strong>内部 XA 事务</strong>，内部 XA 事务由 binlog 作为协调者，存储引擎是参与者。</p><p>当客户端执行 commit 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，<strong>分两阶段来完成 XA 事务的提交</strong></p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240130214144156.png" alt="image-20240130214144156" tabindex="0" loading="lazy"><figcaption>image-20240130214144156</figcaption></figure><p>事务的提交过程有两个阶段，就是<strong>将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog</strong></p><ul><li><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用）；</li><li><strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；</li></ul><h4 id="异常重启情况" tabindex="-1"><a class="header-anchor" href="#异常重启情况" aria-hidden="true">#</a> 异常重启情况</h4><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240130214539542.png" alt="image-20240130214539542" tabindex="0" loading="lazy"><figcaption>image-20240130214539542</figcaption></figure><p>时刻A和时刻B崩溃，此时的redo log都处于prepare状态</p><blockquote><p>如何判断应该提交事务还是回滚事务？</p></blockquote><p>MySQL重启后按顺序扫描redo log 文件，碰到处于 prepare 状态的 redo log，就拿redo log 中的 XID 去 binlog 查看是否存在此 XID：</p><ul><li><strong>如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则回滚事务</strong>。 <ul><li>对应时刻 A 崩溃恢复的情况。</li></ul></li><li><strong>如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务</strong>。 <ul><li>对应时刻 B 崩溃恢复的情况。</li></ul></li></ul><p><strong>对于处于 prepare 阶段的 redo log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与 redo log 相同的 XID</strong></p><ul><li>如果有就提交事务，如果没有就回滚事务。</li><li>这样就可以保证 redo log 和 binlog 这两份日志的一致性了。</li></ul><p><strong>两阶段提交是以 binlog 写成功为事务提交成功的标识</strong></p><ul><li>binlog 写成功了，就意味着能在 binlog 中查找到与 redo log 相同的 XID。</li></ul><blockquote><p>处于 prepare 阶段的 redo log 加上完整 binlog，重启就提交事务，MySQL 为什么要这么设计?</p></blockquote><p>binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。</p><p>所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p><blockquote><p>事务没提交的时候，redo log 会被持久化到磁盘吗？</p></blockquote><p>事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的</p><p>这些缓存在 redo log buffer 里的 redo log 也会被「后台线程」每隔一秒一起持久化到磁盘。</p><p>也就是说，<strong>事务没提交的时候，redo log 也是可能被持久化到磁盘的</strong>。</p><blockquote><p>如果 mysql 崩溃了，还没提交事务的 redo log 已经被持久化磁盘了，mysql 重启后，数据不就不一致了？</p></blockquote><p>这种情况 mysql 重启会进行回滚操作，因为事务没提交的时候，binlog 是还没持久化到磁盘的。</p><p>所以， redo log 可以在事务没提交之前持久化到磁盘，但是 binlog 必须在事务提交之后，才可以持久化到磁盘</p><h4 id="两阶段提交存在的问题" tabindex="-1"><a class="header-anchor" href="#两阶段提交存在的问题" aria-hidden="true">#</a> 两阶段提交存在的问题</h4><p>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差</p><ul><li><strong>磁盘 I/O 次数高</strong>：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。</li><li><strong>锁竞争激烈</strong>：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</li></ul><blockquote><p>为什么两阶段提交磁盘I/O次数会变高？</p></blockquote><p>binlog 和 redo log 在内存中都对应的缓存空间，binlog 会缓存在 binlog cache，redo log 会缓存在 redo log buffer</p><p>它们持久化到磁盘的时机分别由下面这两个参数控制。一般为了避免日志丢失的风险，会将这两个参数设置为 1：</p><ul><li><code>sync_binlog = 1</code> 时，表示每次提交事务都会将 binlog cache 里的 binlog 直接持久到磁盘；</li><li><code>innodb_flush_log_at_trx_commit = 1 </code>时，表示每次事务提交时，都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</li></ul><p>可以看到，如果 sync_binlog 和 当 innodb_flush_log_at_trx_commit 都设置为 1，那么在每个事务提交过程中， 都会<strong>至少调用 2 次刷盘操作</strong>，一次是 redo log 刷盘，一次是 binlog 落盘，所以这会成为性能瓶颈。</p><blockquote><p>为什么锁竞争激烈？</p></blockquote><p>在早期的 MySQL 版本中，通过使用 <code>prepare_commit_mutex</code> 锁来保证事务提交的顺序</p><p>在一个事务获取到锁时才能进入 prepare 阶段，一直到 commit 阶段结束才能释放锁，下个事务才可以继续进行 prepare 操作。</p><p>通过加锁虽然完美地解决了顺序一致性的问题，但在并发量较大的时候，就会导致对锁的争用，性能不佳。</p><blockquote><p>如何优化锁竞争激烈问题？</p></blockquote><p><strong>MySQL 引入了 binlog 组提交（group commit）机制</strong></p><p><strong>当有多个事务提交的时候，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I/O 的次数</strong></p><p>如果说 10 个事务依次排队刷盘的时间成本是 10，那么将这 10 个事务一次性一起刷盘的时间成本则近似于 1。</p><p>引入了组提交机制后，<strong>prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为三个过程</strong>：</p><ul><li><strong>flush 阶段</strong>：多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）；</li><li><strong>sync 阶段</strong>：对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）；</li><li><strong>commit 阶段</strong>：各个事务按顺序做 InnoDB commit 操作；</li></ul><p>上面的<strong>每个阶段都有一个队列</strong>，每个阶段有锁进行保护，因此保证了事务写入的顺序</p><p>第一个进入队列的事务会成为 leader，leader领导所在队列的所有事务，全权负责整队的操作，完成后通知队内其他事务操作结束</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240131013229028.png" alt="image-20240131013229028" tabindex="0" loading="lazy"><figcaption>image-20240131013229028</figcaption></figure><p>对每个阶段引入了队列后，锁就只针对每个队列进行保护，不再锁住提交事务的整个过程</p><p>可以看的出来，<strong>锁粒度减小了，这样就使得多个阶段可以并发执行，从而提升效率</strong>。</p><blockquote><p>有 binlog 组提交，那有 redo log 组提交吗？</p></blockquote><p>这个要看 MySQL 版本，MySQL 5.6 没有 redo log 组提交，MySQL 5.7 有 redo log 组提交。</p><p>在 MySQL 5.6 的组提交逻辑中，每个事务各自执行 prepare 阶段，也就是各自将 redo log 刷盘，这样就没办法对 redo log 进行组提交。</p><p>所以在 MySQL 5.7 版本中，做了个改进，在 prepare 阶段不再让事务各自执行 redo log 刷盘操作，而是推迟到组提交的 flush 阶段，也就是说 prepare 阶段融合在了 flush 阶段。</p><p>这个优化<strong>将 redo log 的刷盘延迟到了 flush 阶段之中，sync 阶段之前</strong>。</p><p><strong>通过延迟写 redo log 的方式，为 redolog 做了一次组写入，这样 binlog 和 redo log 都进行了优化</strong>。</p><blockquote><p><strong>flush阶段</strong></p></blockquote><p>第一个事务会成为 flush 阶段的 Leader，此时后面到来的事务都是 Follower ：</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240131144519576.png" alt="image-20240131144519576" tabindex="0" loading="lazy"><figcaption>image-20240131144519576</figcaption></figure><p>接着，获取队列中的事务组，由绿色事务组的 Leader 对 redo log 做一次 write + fsync，即一次将同组事务的 redolog 刷盘：</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240131144539062.png" alt="image-20240131144539062" tabindex="0" loading="lazy"><figcaption>image-20240131144539062</figcaption></figure><p>完成了 prepare 阶段后，将绿色这一组事务执行过程中产生的 binlog 写入 binlog 文件</p><p>调用 write，不会调用 fsync，所以不会刷盘，binlog 缓存在操作系统的文件系统中</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240131144728688.png" alt="image-20240131144728688" tabindex="0" loading="lazy"><figcaption>image-20240131144728688</figcaption></figure><p>从上面这个过程，可以知道 flush 阶段队列的作用是<strong>用于支撑 redo log 的组提交</strong>。</p><p>如果在这一步完成后数据库崩溃，由于 binlog 中没有该组事务的记录，所以 MySQL 会在重启后回滚该组事务。</p><blockquote><p><strong>sync阶段</strong></p></blockquote><p>绿色这一组事务的 binlog 写入到 binlog 文件后，并不会马上执行刷盘的操作，而是<strong>会等待一段时间</strong></p><p>这个等待的时长由 <code>binlog_group_commit_sync_delay</code> 参数控制，<strong>目的是为了组合更多事务的 binlog，然后再一起刷盘</strong>，如下过程：</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240131144937619.png" alt="image-20240131144937619" tabindex="0" loading="lazy"><figcaption>image-20240131144937619</figcaption></figure><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240131144950965.png" alt="image-20240131144950965" tabindex="0" loading="lazy"><figcaption>image-20240131144950965</figcaption></figure><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240131145004852.png" alt="image-20240131145004852" tabindex="0" loading="lazy"><figcaption>image-20240131145004852</figcaption></figure><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240131145019076.png" alt="image-20240131145019076" tabindex="0" loading="lazy"><figcaption>image-20240131145019076</figcaption></figure><p>不过，在等待的过程中，如果事务的数量提前达到了 <code>Binlog_group_commit_sync_no_delay_count</code> 参数设置的值，就不用继续等待了，就马上将 binlog 刷盘</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240131145057819.png" alt="image-20240131145057819" tabindex="0" loading="lazy"><figcaption>image-20240131145057819</figcaption></figure><p>从上面的过程，可以知道 sync 阶段队列的作用是<strong>用于支持 binlog 的组提交</strong>。</p><p>如果想提升 binlog 组提交的效果，可以通过设置下面这两个参数来实现：</p><ul><li><code>binlog_group_commit_sync_delay= N</code>：表示在等待 N 微秒后，直接调用 fsync，将处于文件系统中 page cache 中的 binlog 刷盘，也就是将「 binlog 文件」持久化到磁盘。</li><li><code>binlog_group_commit_sync_no_delay_count = N</code>：表示如果队列中的事务数达到 N 个，就忽视binlog_group_commit_sync_delay 的设置，直接调用 fsync，将处于文件系统中 page cache 中的 binlog 刷盘。</li></ul><p>如果在这一步完成后数据库崩溃，由于 binlog 中已经有了事务记录，MySQL会在重启后通过 redo log 刷盘的数据继续进行事务的提交。</p><blockquote><p><strong>commit阶段</strong></p></blockquote><p>最后进入 commit 阶段，调用引擎的提交事务接口，将 redo log 状态设置为 commit。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240131145217175.png" alt="image-20240131145217175" tabindex="0" loading="lazy"><figcaption>image-20240131145217175</figcaption></figure><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240131145225259.png" alt="image-20240131145225259" tabindex="0" loading="lazy"><figcaption>image-20240131145225259</figcaption></figure><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240131145236128.png" alt="image-20240131145236128" tabindex="0" loading="lazy"><figcaption>image-20240131145236128</figcaption></figure><p><strong>commit 阶段队列的作用是承接 sync 阶段的事务，完成最后的引擎提交</strong>，使得 sync 可以尽早的处理下一组事务，最大化组提交的效率</p><blockquote><p>如何优化磁盘I/O变高的问题？</p></blockquote><p>事务在提交的时候，需要将 binlog 和 redo log 持久化到磁盘</p><p>如果出现 MySQL 磁盘 I/O 很高的现象，可以通过控制以下参数，来 “延迟” binlog 和 redo log 刷盘的时机，从而降低磁盘 I/O 的频率：</p><ul><li>设置组提交的两个参数： <code>binlog_group_commit_sync_delay</code> 和 <code>binlog_group_commit_sync_no_delay_count</code> 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数。 <ul><li>这个方法是基于<code>“额外的故意等待”</code>来实现的，因此可能会增加语句的响应时间</li><li>但即使 MySQL 进程中途挂了，也没有丢失数据的风险，因为 binlog 早被写入到 page cache 了</li><li>只要系统没有宕机，缓存在 page cache 里的 binlog 就会被持久化到磁盘。</li></ul></li><li>将 <code>sync_binlog</code> 设置为大于 1 的值（比较常见是 100~1000），表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机。 <ul><li>但是这样做的风险是，主机掉电时会丢 N 个事务的 binlog 日志。</li></ul></li><li>将 <code>innodb_flush_log_at_trx_commit</code> 设置为 2。表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件 <ul><li>注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache，专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存，然后交由操作系统控制持久化到磁盘的时机</li><li>但是这样做的风险是，主机掉电的时候会丢数据。</li></ul></li></ul><h3 id="更新语句的执行过程" tabindex="-1"><a class="header-anchor" href="#更新语句的执行过程" aria-hidden="true">#</a> 更新语句的执行过程</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">UPDATE</span> t_user <span class="token keyword">SET</span> name <span class="token operator">=</span> <span class="token string">&#39;xiaolin&#39;</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>具体更新一条记录 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 的流程如下:</p><ol><li><p>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：</p><ul><li>如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li><li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li></ul></li><li><p>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：</p><ul><li>如果一样的话就不进行后续更新流程；</li><li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li></ul></li><li><p>InnoDB层更新记录前</p><ul><li>开启事务</li></ul><ul><li>记录相应的 undo log <ul><li>因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo lo</li><li>undo log 会写入 Buffer Pool 中的 Undo 页面</li><li>在内存修改该 Undo 页面后，需要记录对应的 redo log</li></ul></li></ul></li><li><p>InnoDB 层开始更新记录</p><ul><li>先更新内存（同时标记为脏页）</li><li>然后将记录写到 redo log 里面，这个时候更新就算完成了</li><li>为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong><ul><li>MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li></ul></li></ul></li><li><p>InnoDB 层更新记录后</p><ul><li>Server层开始记录该语句对应的 binlog</li><li>此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件</li><li>在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li></ul></li><li><p>事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：</p><ul><li><p><strong>prepare 阶段</strong>：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</p></li><li><p><strong>commit 阶段</strong>：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</p></li></ul></li><li><p>至此，一条更新语句执行完成</p></li></ol></div><!--[--><!----><!--]--><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/lgy8888/my_blog.git/edit/main/src/backEnd/MySQL/日志.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><nav class="vp-page-nav"><a aria-label="事务" class="vp-link nav-link prev nav-link prev" href="/my_blog/backEnd/MySQL/%E4%BA%8B%E5%8A%A1.html"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><span class="font-icon icon iconfont icon-write" style=""></span>事务</div></a><a aria-label="锁" class="vp-link nav-link next nav-link next" href="/my_blog/backEnd/MySQL/%E9%94%81.html"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">锁<span class="font-icon icon iconfont icon-write" style=""></span></div></a></nav><div id="comment" class="giscus-wrapper input-top" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">林光远的个人笔记网站</div><div class="vp-copyright">Copyright © 2024 LGYNB</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/my_blog/assets/app-OTaO6_y0.js" defer></script>
  </body>
</html>
