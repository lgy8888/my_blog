<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.0" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.2" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://vuepress-theme-hope-docs-demo.netlify.app/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html"><meta property="og:site_name" content="林光远的个人笔记"><meta property="og:title" content="存储引擎"><meta property="og:description" content="文件系统中，MySQL将每个数据库保存为数据目录下的一个子目录; 创建表的时候，会在数据库子目录下创建一个和表同名的.frm文件保存该表的定义; MySQL使用文件系统的目录和文件夹保存数据库和表的定义，所以大小写敏感性和具体的平台密切相关; Windows中大小写是敏感的; 类Unix中大小写是不敏感的; 不同的存储引擎保存数据和索引的方式..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="LGYNB"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"存储引擎","image":[""],"dateModified":null,"author":[{"@type":"Person","name":"LGYNB","url":"/"}]}</script><link rel="icon" href="/my_blog/favicon.ico"><title>存储引擎 | 林光远的个人笔记</title><meta name="description" content="文件系统中，MySQL将每个数据库保存为数据目录下的一个子目录; 创建表的时候，会在数据库子目录下创建一个和表同名的.frm文件保存该表的定义; MySQL使用文件系统的目录和文件夹保存数据库和表的定义，所以大小写敏感性和具体的平台密切相关; Windows中大小写是敏感的; 类Unix中大小写是不敏感的; 不同的存储引擎保存数据和索引的方式...">
    <link rel="preload" href="/my_blog/assets/style-ERUp4lUP.css" as="style"><link rel="stylesheet" href="/my_blog/assets/style-ERUp4lUP.css">
    <link rel="modulepreload" href="/my_blog/assets/app-OTaO6_y0.js"><link rel="modulepreload" href="/my_blog/assets/存储引擎.html-Ih95IFyb.js"><link rel="modulepreload" href="/my_blog/assets/plugin-vue_export-helper-x3n3nnut.js"><link rel="modulepreload" href="/my_blog/assets/存储引擎.html-6Sd1YpIV.js">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand vp-brand" href="/my_blog/"><img class="vp-nav-logo" src="/my_blog/logo.png" alt="林光远的个人笔记"><!----><span class="vp-site-name hide-in-pad">林光远的个人笔记</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a aria-label="后端技术" class="vp-link nav-link active nav-link active" href="/my_blog/backEnd/"><span class="font-icon icon iconfont icon-back-stage" style=""></span>后端技术<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="Web开发" class="vp-link nav-link nav-link" href="/my_blog/webDevelop/"><span class="font-icon icon iconfont icon-config" style=""></span>Web开发<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="AI技术" class="vp-link nav-link nav-link" href="/my_blog/ai/"><span class="font-icon icon iconfont icon-function" style=""></span>AI技术<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="数据结构与算法" class="vp-link nav-link nav-link" href="/my_blog/coding/"><span class="font-icon icon iconfont icon-calculate" style=""></span>数据结构与算法<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="项目经历" class="vp-link nav-link nav-link" href="/my_blog/projects/"><span class="font-icon icon iconfont icon-code" style=""></span>项目经历<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/lgy8888/my_blog.git" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索本站" autocomplete="off" spellcheck="false" value><!----></form><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-cache" style=""></span><span class="vp-sidebar-title">Redis</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><span class="font-icon icon iconfont icon-mysql" style=""></span><span class="vp-sidebar-title">MySQL</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a aria-label="SQL基础" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/SQL%E5%9F%BA%E7%A1%80.html"><span class="font-icon icon iconfont icon-write" style=""></span>SQL基础<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="SQL原理" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/SQL%E5%8E%9F%E7%90%86.html"><span class="font-icon icon iconfont icon-write" style=""></span>SQL原理<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="数据类型" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"><span class="font-icon icon iconfont icon-write" style=""></span>数据类型<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="数据库设计" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1.html"><span class="font-icon icon iconfont icon-write" style=""></span>数据库设计<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="逻辑架构" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.html"><span class="font-icon icon iconfont icon-write" style=""></span>逻辑架构<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="存储引擎" class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active nav-link active vp-sidebar-link vp-sidebar-page active" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html"><span class="font-icon icon iconfont icon-write" style=""></span>存储引擎<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="存储引擎基本操作" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#存储引擎基本操作"><!---->存储引擎基本操作<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="查看存储引擎" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#查看存储引擎"><!---->查看存储引擎<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="默认存储引擎" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#默认存储引擎"><!---->默认存储引擎<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="表的存储引擎" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#表的存储引擎"><!---->表的存储引擎<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="存储引擎简介" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#存储引擎简介"><!---->存储引擎简介<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="InnoDB" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#innodb"><!---->InnoDB<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="MyISAM" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#myisam"><!---->MyISAM<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Archive" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#archive"><!---->Archive<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="BlackHole" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#blackhole"><!---->BlackHole<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="CSV" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#csv"><!---->CSV<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Memory" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#memory"><!---->Memory<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Federated" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#federated"><!---->Federated<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Merge" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#merge"><!---->Merge<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="NDB" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#ndb"><!---->NDB<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="InnoDB简介" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#innodb简介"><!---->InnoDB简介<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="InnoDB概述" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#innodb概述"><!---->InnoDB概述<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="InnoDB数据存储" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#innodb数据存储"><!---->InnoDB数据存储<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="InnoDB的索引" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#innodb的索引"><!---->InnoDB的索引<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="InnoDB的事务" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#innodb的事务"><!---->InnoDB的事务<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="InnoDB的数据读取" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#innodb的数据读取"><!---->InnoDB的数据读取<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="MyISAM简介" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#myisam简介"><!---->MyISAM简介<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="MyISAM数据存储" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#myisam数据存储"><!---->MyISAM数据存储<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="MyISAM的特性" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#myisam的特性"><!---->MyISAM的特性<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="MyISAM压缩表" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#myisam压缩表"><!---->MyISAM压缩表<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="MyISAM性能" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#myisam性能"><!---->MyISAM性能<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="MyISAM和InnoDB" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#myisam和innodb"><!---->MyISAM和InnoDB<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="磁盘文件" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#磁盘文件"><!---->磁盘文件<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="索引支持" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#索引支持"><!---->索引支持<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="事务机制" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#事务机制"><!---->事务机制<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="故障恢复" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#故障恢复"><!---->故障恢复<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="锁粒度" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#锁粒度"><!---->锁粒度<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="并发性能" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#并发性能"><!---->并发性能<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="内存利用度" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#内存利用度"><!---->内存利用度<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="InnoDB优势" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#innodb优势"><!---->InnoDB优势<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="MyISAM优势" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#myisam优势"><!---->MyISAM优势<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="MyISAM应用场景" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#myisam应用场景"><!---->MyISAM应用场景<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="InnoDB底层原理" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#innodb底层原理"><!---->InnoDB底层原理<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="InnoDB存储方式" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#innodb存储方式"><!---->InnoDB存储方式<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="InnDB行格式" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#inndb行格式"><!---->InnDB行格式<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="CHAR和VARCHAR" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#char和varchar"><!---->CHAR和VARCHAR<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="InnoDB页结构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#innodb页结构"><!---->InnoDB页结构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="MySQL数据目录" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#mysql数据目录"><!---->MySQL数据目录<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="数据库和文件系统的关系" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#数据库和文件系统的关系"><!---->数据库和文件系统的关系<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="MySQL的数据目录" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#mysql的数据目录"><!---->MySQL的数据目录<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="数据目录的结构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#数据目录的结构"><!---->数据目录的结构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="InnoDB的表空间" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#innodb的表空间"><!---->InnoDB的表空间<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="独立表空间结构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#独立表空间结构"><!---->独立表空间结构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Buffer Pool" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#buffer-pool"><!---->Buffer Pool<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="Buffer Pool基础" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#buffer-pool基础"><!---->Buffer Pool基础<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Buffer Pool缓存的内容" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#buffer-pool缓存的内容"><!---->Buffer Pool缓存的内容<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Buffer Pool的管理" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#buffer-pool的管理"><!---->Buffer Pool的管理<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Change Buffer" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#change-buffer"><!---->Change Buffer<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="简介" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#简介"><!---->简介<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="工作机制" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#工作机制"><!---->工作机制<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="使用时机" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#使用时机"><!---->使用时机<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="使用场景" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#使用场景"><!---->使用场景<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="跟redo-log的关联" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html#跟redo-log的关联"><!---->跟redo-log的关联<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a aria-label="索引" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E7%B4%A2%E5%BC%95.html"><span class="font-icon icon iconfont icon-write" style=""></span>索引<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="事务" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E4%BA%8B%E5%8A%A1.html"><span class="font-icon icon iconfont icon-write" style=""></span>事务<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="日志" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html"><span class="font-icon icon iconfont icon-write" style=""></span>日志<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="锁" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E9%94%81.html"><span class="font-icon icon iconfont icon-write" style=""></span>锁<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="性能调优" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98.html"><span class="font-icon icon iconfont icon-write" style=""></span>性能调优<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-java" style=""></span><span class="vp-sidebar-title">Java</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-OS" style=""></span><span class="vp-sidebar-title">OS</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->存储引擎</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="/" target="_blank" rel="noopener noreferrer">LGYNB</a></span><span property="author" content="LGYNB"></span></span><!----><!----><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 102 分钟</span><meta property="timeRequired" content="PT102M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#存储引擎基本操作">存储引擎基本操作</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#查看存储引擎">查看存储引擎</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#默认存储引擎">默认存储引擎</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#表的存储引擎">表的存储引擎</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#存储引擎简介">存储引擎简介</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#innodb">InnoDB</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#myisam">MyISAM</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#archive">Archive</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#blackhole">BlackHole</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#csv">CSV</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#memory">Memory</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#federated">Federated</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#merge">Merge</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#ndb">NDB</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#innodb简介">InnoDB简介</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#innodb概述">InnoDB概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#innodb数据存储">InnoDB数据存储</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#innodb的索引">InnoDB的索引</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#innodb的事务">InnoDB的事务</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#innodb的数据读取">InnoDB的数据读取</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#myisam简介">MyISAM简介</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#myisam数据存储">MyISAM数据存储</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#myisam的特性">MyISAM的特性</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#myisam压缩表">MyISAM压缩表</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#myisam性能">MyISAM性能</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#myisam和innodb">MyISAM和InnoDB</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#磁盘文件">磁盘文件</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#索引支持">索引支持</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#事务机制">事务机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#故障恢复">故障恢复</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#锁粒度">锁粒度</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#并发性能">并发性能</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#内存利用度">内存利用度</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#innodb优势">InnoDB优势</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#myisam优势">MyISAM优势</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#myisam应用场景">MyISAM应用场景</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#innodb底层原理">InnoDB底层原理</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#innodb存储方式">InnoDB存储方式</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#inndb行格式">InnDB行格式</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#char和varchar">CHAR和VARCHAR</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#innodb页结构">InnoDB页结构</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#mysql数据目录">MySQL数据目录</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#数据库和文件系统的关系">数据库和文件系统的关系</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#mysql的数据目录">MySQL的数据目录</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#数据目录的结构">数据目录的结构</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#innodb的表空间">InnoDB的表空间</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#独立表空间结构">独立表空间结构</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#buffer-pool">Buffer Pool</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#buffer-pool基础">Buffer Pool基础</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#buffer-pool缓存的内容">Buffer Pool缓存的内容</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#buffer-pool的管理">Buffer Pool的管理</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#change-buffer">Change Buffer</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#简介">简介</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#工作机制">工作机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#使用时机">使用时机</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#使用场景">使用场景</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#跟redo-log的关联">跟redo-log的关联</a></li><!----><!--]--></ul></li><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h1 id="存储引擎" tabindex="-1"><a class="header-anchor" href="#存储引擎" aria-hidden="true">#</a> 存储引擎</h1><ul><li>文件系统中，MySQL将<strong>每个数据库保存为数据目录下的一个子目录</strong></li><li>创建表的时候，会<strong>在数据库子目录下创建一个和表同名的<code>.frm</code>文件保存该表的定义</strong></li><li>MySQL使用文件系统的目录和文件夹保存数据库和表的定义，所以<strong>大小写敏感性和具体的平台密切相关</strong><ul><li>Windows中大小写是敏感的</li><li>类Unix中大小写是不敏感的</li></ul></li><li><strong>不同的存储引擎保存数据和索引的方式是不同的</strong></li><li>但是<strong>表的定义</strong>则是<strong>在MySQL服务层中统一处理的</strong></li></ul><h2 id="存储引擎基本操作" tabindex="-1"><a class="header-anchor" href="#存储引擎基本操作" aria-hidden="true">#</a> 存储引擎基本操作</h2><h3 id="查看存储引擎" tabindex="-1"><a class="header-anchor" href="#查看存储引擎" aria-hidden="true">#</a> 查看存储引擎</h3><blockquote><p>查看MySQL提供什么存储引擎</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SHOW</span> engines<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231221162055923.png" alt="image-20231221162055923" tabindex="0" loading="lazy"><figcaption>image-20231221162055923</figcaption></figure><h3 id="默认存储引擎" tabindex="-1"><a class="header-anchor" href="#默认存储引擎" aria-hidden="true">#</a> 默认存储引擎</h3><p><strong>查看默认存储引擎</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SHOW</span> variables <span class="token operator">LIKE</span> <span class="token string">&#39;%storage_engine%&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> @<span class="token variable">@default_storage_engine</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231221162244884.png" alt="image-20231221162244884" tabindex="0" loading="lazy"><figcaption>image-20231221162244884</figcaption></figure><p><strong>修改默认的存储引擎</strong></p><blockquote><p>如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用InnoDB 作为表的存储引擎。</p></blockquote><ul><li>写启动服务的命令行</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SET</span> DEFAULT_STORAGE_ENGINE<span class="token operator">=</span>MyISAM<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>修改my.cnf文件</li></ul><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">default-storage-engine</span><span class="token punctuation">=</span><span class="token value attr-value">MyISAM</span>
<span class="token comment"># 重启服务</span>
<span class="token key attr-name">systemctl</span> <span class="token value attr-value">restart mysqld.service</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="表的存储引擎" tabindex="-1"><a class="header-anchor" href="#表的存储引擎" aria-hidden="true">#</a> 表的存储引擎</h3><ul><li>存储引擎是负责对表中的数据进行提取和写入工作的，可以为不同的表设置不同的存储引擎</li><li>不同的表可以有不同的物理存储结构，不同的提取和写入方式</li></ul><p><strong>创建表时指定存储引擎</strong></p><ul><li>创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎InnoDB</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名<span class="token punctuation">(</span>
	建表语句<span class="token punctuation">;</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> 存储引擎名称<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>修改表的存储引擎</strong></p><ul><li>表建好之后修改表的存储引擎</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">ENGINE</span> <span class="token operator">=</span> 存储引擎名称<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> engine_demo_table <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.05</span> sec<span class="token punctuation">)</span>
Records: <span class="token number">0</span> Duplicates: <span class="token number">0</span> <span class="token keyword">Warnings</span>: <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>查看engine_demo_table的表结构</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> engine_demo_table\G
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
	   <span class="token keyword">Table</span>: engine_demo_table
<span class="token keyword">Create</span> <span class="token keyword">Table</span>: <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>engine_demo_table<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>
	<span class="token identifier"><span class="token punctuation">`</span>i<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="存储引擎简介" tabindex="-1"><a class="header-anchor" href="#存储引擎简介" aria-hidden="true">#</a> 存储引擎简介</h2><p>MySQL支持的存储引擎共有9种</p><blockquote><p><em>加粗代表重点，下划线代表MySQL默认</em></p></blockquote><ul><li><strong><u>InnoDB</u></strong></li><li>MRG_MYISAM</li><li>MEMORY</li><li>BLACKHOLE</li><li><strong>MyISAM</strong></li><li>CSV</li><li>ARCHIVE</li><li>PERFORMANCE_SCHEMA</li><li>FEDERATED</li></ul><h3 id="innodb" tabindex="-1"><a class="header-anchor" href="#innodb" aria-hidden="true">#</a> InnoDB</h3><blockquote><p><strong>具备外键支持功能的事务存储引擎</strong></p></blockquote><ul><li>MySQL从3.23.34a开始就包含InnoDB存储引擎。大于等于<strong>5.5之后，默认采用InnoDB引擎</strong>。</li><li>InnoDB是<strong>MySQL的默认事务型引擎</strong>，它<strong>被设计用来处理大量的短期(short-lived)事务</strong><ul><li>可以<strong>确保事务的完整提交(Commit)和回滚(Rollback)</strong>。</li></ul></li><li>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。</li><li>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</li><li>数据文件结构 <ul><li>表名.frm存储表结构（MySQL8.0时，合并在表名.ibd中）</li><li>表名.ibd存储数据和索引</li></ul></li><li><strong>InnoDB是为处理巨大数据量的最大性能设计</strong>。 <ul><li>在以前的版本中，字典数据以元数据文件、非事务表等来存储</li><li>现在这些元数据文件被删除了。比如： .frm ， .par ， .trn ， .isl ， .db.opt 等都在MySQL8.0中不存在了。</li></ul></li><li>对比MyISAM的存储引擎， InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保存数据和索引。</li><li>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据， 对内存要求较高，而且内存大小对性能有决定性的影响。</li></ul><h3 id="myisam" tabindex="-1"><a class="header-anchor" href="#myisam" aria-hidden="true">#</a> MyISAM</h3><blockquote><p><strong>主要的非事务处理存储引擎</strong></p></blockquote><ul><li>MyISAM<strong>提供了大量的特性</strong>，包括全文索引、压缩、空间函数(GIS)等 <ul><li>但MyISAM <strong>不支持事务、行级锁、外键</strong></li><li><strong>有一个毫无疑问的缺陷就是崩溃后无法安全恢复</strong>。</li></ul></li><li>MySQL<strong>5.5之前默认的存储引擎</strong></li><li>优势是<strong>访问的速度快</strong>，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li><li><strong>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高</strong></li><li>数据文件结构： <ul><li>表名.frm 存储表结构</li><li>表名.MYD 存储数据 (MYData)</li><li>表名.MYI 存储索引 (MYIndex)</li></ul></li><li>应用场景：<strong>只读应用或者以读为主的业务</strong><ul><li>主从集群——读写分离</li></ul></li></ul><h3 id="archive" tabindex="-1"><a class="header-anchor" href="#archive" aria-hidden="true">#</a> Archive</h3><blockquote><p><strong>用于数据存档</strong></p></blockquote><table><thead><tr><th>特征</th><th>支持</th></tr></thead><tbody><tr><td>B树索引</td><td>×</td></tr><tr><td>备份/时间点恢复（在服务器中实现）</td><td>√</td></tr><tr><td>集群数据库支持</td><td>×</td></tr><tr><td>聚簇索引</td><td>×</td></tr><tr><td>压缩数据</td><td>√</td></tr><tr><td>数据缓存</td><td>×</td></tr><tr><td>加密数据（在服务器中实现</td><td>√</td></tr><tr><td>外键支持</td><td>×</td></tr><tr><td>全文检索索引</td><td>×</td></tr><tr><td>地理空间数据类型支持</td><td>√</td></tr><tr><td>地理空间索引支持</td><td>×</td></tr><tr><td>哈希索引</td><td>×</td></tr><tr><td>索引缓存</td><td>×</td></tr><tr><td>锁粒度</td><td>行锁</td></tr><tr><td>MVCC</td><td>×</td></tr><tr><td>存储限制</td><td>没有限制</td></tr><tr><td>交易</td><td>×</td></tr><tr><td>更新数据字典的统计信息</td><td>√</td></tr></tbody></table><h3 id="blackhole" tabindex="-1"><a class="header-anchor" href="#blackhole" aria-hidden="true">#</a> BlackHole</h3><blockquote><p><strong>丢弃写时操作，读操作会返回空内容</strong></p></blockquote><h3 id="csv" tabindex="-1"><a class="header-anchor" href="#csv" aria-hidden="true">#</a> CSV</h3><blockquote><p><strong>存储数据时，以逗号分隔各个数据项</strong></p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test <span class="token punctuation">(</span>i <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> c <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> CSV<span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.06</span> sec<span class="token punctuation">)</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&#39;record one&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">&#39;record two&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.05</span> sec<span class="token punctuation">)</span>
Records: <span class="token number">2</span> Duplicates: <span class="token number">0</span> <span class="token keyword">Warnings</span>: <span class="token number">0</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> test<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">---+------------+</span>
<span class="token operator">|</span> i <span class="token operator">|</span> c 		 <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---+------------+</span>
<span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> record one <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> record two <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---+------------+</span>
<span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建CSV表还会创建相应的元文件，用于存储表的状态和表中存在的行数。</p><ul><li>此文件的名称与表的名称相同，后缀为CSM</li></ul><p>CSV格式的文件可以被Excel等电子表格应用程序读取，甚至写入</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231221164441715.png" alt="image-20231221164441715" tabindex="0" loading="lazy"><figcaption>image-20231221164441715</figcaption></figure><h3 id="memory" tabindex="-1"><a class="header-anchor" href="#memory" aria-hidden="true">#</a> Memory</h3><p>置于内存的表</p><p><strong>概述</strong></p><ul><li>Memory采用的逻辑介质是内存，响应速度很快</li><li>但是当mysqld守护进程崩溃的时候数据会丢失</li><li>另外，要求存储的数据是数据长度不变的格式，比如，Blob和Text类型的数据不可用(长度不固定的)。</li></ul><p><strong>主要特征</strong></p><ul><li>Memory<strong>同时支持哈希（HASH）索引和B+树索引</strong>。</li><li><strong>Memory表至少比MyISAM表要快一个数量级</strong>。</li><li><strong>MEMORY 表的大小是受到限制的</strong>。表的大小主要取决于两个参数，分别是max_rows 和max_heap_table_size <ul><li>其中，max_rows可以在创建表时指定；max_heap_table_size的大小默认为16MB，可以按需要进行扩大。</li></ul></li><li><strong>数据文件与索引文件分开存储</strong>。 <ul><li>缺点：其<strong>数据易丢失</strong>，生命周期短。基于这个缺陷，选择MEMORY存储引擎时需要特别小心。</li></ul></li></ul><p><strong>应用场景</strong></p><ul><li><p>目标数据比较小，而且非常频繁的进行访问</p><ul><li>在内存中存放数据，如果太大的数据会造成内存溢出</li><li>可以通过参数max_heap_table_size 控制Memory表的大小，限制Memory表的最大的大小。</li></ul></li><li><p>如果数据是临时的，而且必须立即可用得到，那么就可以放在内存中。</p></li><li><p>存储在Memory表中的数据如果突然间丢失的话也没有太大的关系。</p></li></ul><h3 id="federated" tabindex="-1"><a class="header-anchor" href="#federated" aria-hidden="true">#</a> Federated</h3><blockquote><p><strong>访问远程表</strong></p></blockquote><ul><li>Federated引擎是访问其他MySQL服务器的一个代理</li><li>尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</li></ul><h3 id="merge" tabindex="-1"><a class="header-anchor" href="#merge" aria-hidden="true">#</a> Merge</h3><p>管理多个MyISAM表构成的表集合</p><h3 id="ndb" tabindex="-1"><a class="header-anchor" href="#ndb" aria-hidden="true">#</a> NDB</h3><blockquote><p><strong>MySQL集群专用存储引擎</strong></p></blockquote><ul><li>也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境</li><li>类似于 Oracle 的 RAC 集群。</li></ul><h2 id="innodb简介" tabindex="-1"><a class="header-anchor" href="#innodb简介" aria-hidden="true">#</a> InnoDB简介</h2><h3 id="innodb概述" tabindex="-1"><a class="header-anchor" href="#innodb概述" aria-hidden="true">#</a> InnoDB概述</h3><ul><li>InnoDB是MySQL<strong>默认事务型引擎</strong></li><li>InnoDB是最重要、使用最广泛的存储引擎</li><li>InnoDB<strong>被设计用来处理大量的短期事务</strong><ul><li>短期事务大部分情况是正常提交的，很少有回滚</li></ul></li><li><strong>InnoDB具有高性能和自动崩溃恢复的特性</strong>，在非事务型存储的需求中也很受欢迎</li><li>除非有其他的原因，否则都得优先考虑InnoDB</li></ul><h3 id="innodb数据存储" tabindex="-1"><a class="header-anchor" href="#innodb数据存储" aria-hidden="true">#</a> InnoDB数据存储</h3><ul><li><p>InnoDB的数据存储在<strong>表空间</strong>中，表空间由一系列的数据文件组成</p></li><li><p>MySQL4.1后，InnoDB可以将每个表的<strong>数据和索引存放在单独的文件</strong>中，一张表的数据和索引放在同一份文件中。数据文件结构：</p><ul><li><p>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</p></li><li><p>表名.ibd 存储数据和索引</p></li></ul></li><li><p>InnoDB的存储格式是<strong>平台独立</strong>的，可以将数据和索引文件从Intel平台复制到PowerPC或者Sun SPARC平台</p></li><li><p>InnoDB也可以使用裸设备作为表空间的存储介质，但是现代文件系统提供了很多优势，如更好的数据管理、容错能力、安全性和易用性，因此裸设备不再是必要的选择</p></li></ul><blockquote><p>裸设备：</p><p>存储设备上创建的没有经过文件系统格式化的存储原始数据的区域，裸设备直接在磁盘或者分区上存储数据，不经过文件系统的管理</p><p>裸设备可以避免文件系统的开销，减少了一些I/O操作的复杂性，提高了数据库的性能，因此曾经有一段时间裸设备被认为是一种性能优化的选择</p></blockquote><h3 id="innodb的索引" tabindex="-1"><a class="header-anchor" href="#innodb的索引" aria-hidden="true">#</a> InnoDB的索引</h3><p><strong>InnoDB表基于聚簇索引建立，聚簇索引对主键查询有很高的性能</strong></p><p>但是InnoDB的二级索引中必须包含主键值，所以如果表的索引很多的话，<strong>主键应该尽量小</strong></p><p>如果主键大的话，其他全部的二级索引会跟着变大</p><h3 id="innodb的事务" tabindex="-1"><a class="header-anchor" href="#innodb的事务" aria-hidden="true">#</a> InnoDB的事务</h3><ul><li><strong>采用MVCC支持高并发，实现了四个标准的隔离级别</strong><ul><li>默认的隔离级别是可重复读</li></ul></li><li>通过间隙锁策略可以防止幻读现象 <ul><li>间隙锁不仅锁定查询涉及的列，还会对索引中的间隙进行锁定，防止网索引中插入新行</li></ul></li></ul><blockquote><p>索引间隙</p><ul><li>主键由0，5，10，15，20，25</li><li>有(-∞，0)，（0，5）， （5， 10），（10，15），（15，20），（20，25），（25，+∞）总共七个索引间隙</li><li>查询 id = 7 的数据时，这条记录位于（5，10）索引间隙中，除了会锁定id = 7的数据外，还会锁定整个（5，10）的索引间隙</li></ul></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231221201848929.png" alt="image-20231221201848929" tabindex="0" loading="lazy"><figcaption>image-20231221201848929</figcaption></figure><h3 id="innodb的数据读取" tabindex="-1"><a class="header-anchor" href="#innodb的数据读取" aria-hidden="true">#</a> InnoDB的数据读取</h3><ul><li><p>从磁盘读取数据时采用<strong>可预测性预读</strong></p><ul><li>数据库的瓶颈在于磁盘I/O，预读是在读取一个数据块时，同时读取相邻块数据的技术</li><li>InnoDB的可预测性预读，是在原始磁盘I/O预读的基础上，预测下一个会被访问的数据块，然后在数据被访问之前，提前从磁盘中读取这些数据块到内存中，等应用程序下次访问这个数据的时候，已经在内存中，减少应用程序在访问数据时的磁盘I/O，提高读取性能</li></ul></li><li><p>能够自动在内存中创建hash索引以加速读操作的<strong>自适应哈希索引</strong></p><ul><li><p>hash索引通常用于快速的等值查找，但是在某些场景下，Hash索引的效果可能没有B+索引好</p></li><li><p>InnoDB实现的是自适应哈希索引</p><ul><li>InnoDB监控查询模式，对一些频繁访问的数据，它会在内存中自动创建哈希索引，这使得对于这些特定的查询，可以更快的通过哈希索引找到</li></ul></li><li><p>举例：假设有一个电子商务网站，某段时间内某款热门商品的查询频率急剧上升。InnoDB会监测到这一变化，然后自动在内存中创建哈希索引，加速对这个商品的查询。随着时间的推移，如果这个商品不再处于热门状态，系统可以动态地调整，甚至取消哈希索引的使用，以释放内存资源</p></li></ul></li><li><p>InnoDB通过一些机制和工具支持真正的热备份</p><ul><li>热备份：在不中断数据库正常运行的情况下进行备份操作</li></ul></li></ul><h2 id="myisam简介" tabindex="-1"><a class="header-anchor" href="#myisam简介" aria-hidden="true">#</a> MyISAM简介</h2><ul><li>在MySQL5.1及之前的版本，MyISAM是默认的存储引擎</li><li>MyISAM提供大量的特性：<strong>全文索引、压缩、空间函数</strong></li><li><strong>MyISAM不支持事务和行级锁</strong></li><li><strong>MyISAM崩溃后无法完全恢复</strong></li><li>对于只读的数据，或者表i较小，可以忍受修复操作，依然可以继续使用MyISAM，但最好还是使用InnoDB</li></ul><h3 id="myisam数据存储" tabindex="-1"><a class="header-anchor" href="#myisam数据存储" aria-hidden="true">#</a> MyISAM数据存储</h3><ul><li>MyISAM将表存储在两个文件中 <ul><li>数据文件：.MYD 扩展名</li><li>索引文件：.MIY 扩展名</li></ul></li><li>MyISAM表可以包含动态或者静态(长度固定)的行，MySQL会根据表的定义来决定采用哪种行格式</li><li>MyISAM表可以存储行记录数，记录数受限于可用的磁盘空间，或者操作系统单个文件的最大尺寸</li><li>MySQL5.0中，MyISAM表如果是变长行，默认配置只能处理256TB的数据</li></ul><h3 id="myisam的特性" tabindex="-1"><a class="header-anchor" href="#myisam的特性" aria-hidden="true">#</a> MyISAM的特性</h3><p><strong>加锁与并发</strong></p><ul><li>MyISAM对整张表加锁，而不是针对行</li><li><strong>读取时会对需要读到的所有表加共享锁，写入时对表加排他锁</strong><ul><li>共享锁：允许多个会话获取同一个资源的读取权限，但没有写入权限，用于保护读取操作，不阻塞其他共享锁的获取。</li><li>排他锁：只允许一个会话获取同一个资源的访问权限，不允许其他会话对同一资源的读写，保护写操作</li></ul></li><li>在表有<strong>读取查询的同时，也可以往表中插入新的记录</strong>(这被称为并发插入) <ul><li>插入不属于写权限，如果MyISAM在数据文件中没有空洞（中间删除了行），当有会话进行查询操作时， <code>INSERT</code>可以将要插入的数据添加到表的末尾，如果有多个 <code>INSERT</code>语句，它们将排队并按顺序执行，并发的结果可能不会立即可见，因为并发性可能导致插入操作的顺序不同</li><li>如果表MyISAM在数据文件中有空洞（中间删除了行），并发的<code>INSERT</code>语句仍然可以执行。这时，新的数据将插入到空洞中，而不影响其他正在进行的读取或写入操作。并且，这些插入的数据将填充空洞，保持表的连续性。</li></ul></li></ul><p><strong>修复</strong></p><ul><li>对于MyISAM表，MySQL可以手工或者自动执行检查和修复操作</li><li>这里的表的修复，与事务修复和崩溃修复是不同的概念</li><li><strong>执行表的修复可能会丢失数据，且修复操作非常慢</strong>，下面的延迟更新索引键就有可能导致索引损坏，就需要执行修复操作</li><li>检查表的错误：<code>CHECK TABLE tablename</code></li><li>修复表：<code>REPAIR TABLE mytable</code></li><li>如果MySQL服务器已关闭，可以通过<code>myisamchk</code>命令行工具进行检查和修复</li></ul><p><strong>索引特性</strong></p><ul><li>对于BLOB和TEXT这样的长字段也可以<strong>基于前500个字符创建索引</strong></li><li><strong>MyISAM表支持全文索引，这是一种基于分词创建的索引，可以支持复杂的查询</strong></li></ul><p><strong>延迟更新索引键</strong></p><ul><li>创建MyISAM表的时候，如果指定了<code>DELAY_KEY_WRITE</code>选项，在每次<strong>修改执行完成时，不会立刻将修改的索引写入磁盘，而是会写到内存中的键缓冲区</strong></li><li>只有<strong>在清理键缓冲区或者关闭表的时候才会将对应的所应快写入磁盘</strong><ul><li>关闭所有打开的表：<code>FLUSH TABLES</code></li></ul></li><li>这样虽然可以提升写性能，但是<strong>在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作</strong></li><li>延迟更新索引键可以在全局设置，也可以单表设置</li></ul><h3 id="myisam压缩表" tabindex="-1"><a class="header-anchor" href="#myisam压缩表" aria-hidden="true">#</a> MyISAM压缩表</h3><ul><li><strong>如果表创建并导入数据后不再修改，那么这样的表可能适合MyISAM压缩表</strong></li><li>可以使用<code>myisampack</code>对MyISAM表进行压缩(也叫打包pack)</li><li><strong>压缩表不能直接进行修改</strong>，除非先解压，修改数据，然后再次压缩</li><li><strong>压缩表可以减少磁盘空间占用</strong>，因此也可以<strong>减少磁盘I/O</strong>，<strong>提升查询性能</strong><ul><li>压缩表通过数据压缩减少了存储需求，占用更少的磁盘空间，相比起未经过压缩的数据，<strong>相同的量级的 I/O ，能够获取的数据会更多</strong>，可以理解为每次 I/O 的效率都很高，一下就拿了很多数据，三两下就能把数据都拿完，就可以减少磁盘I/O</li><li>例如：一次拿16k，</li></ul></li><li><strong>压缩表支持索引，但索引只读</strong></li><li>以现在的硬件能力，读取压缩表数据时的解压带来的开销不大，同时可以获得减少磁盘I/O这样大的好处</li><li>压缩时表中的记录是独立压缩的，所以读取单行的时候不用解压整个表，也不解压行所在的整个页面 <ul><li>压缩表查询数据时可以从磁盘中读出比没压缩更多的数据，在内存中对待查询的记录进行解压</li><li>未被查询到的数据不会解压</li></ul></li></ul><blockquote><p><strong>压缩表的优势</strong></p></blockquote><ul><li><strong>磁盘空间节省</strong>： 压缩表通过使用压缩算法，可以显著减小数据在磁盘上的存储空间。这对于拥有大量数据的数据库来说，可以降低存储成本，并允许在磁盘上存储更多的数据。</li><li><strong>IO性能提升</strong>： 压缩表在磁盘上占用更小的空间，这意味着在进行IO操作（如读取和写入）时需要传输的数据量更少。这可以提高IO性能，尤其是对于那些受限于磁盘带宽的系统而言。</li><li><strong>缓存效率提高</strong>： 压缩表在内存中占用的空间也相对较小，因为解压缩后的数据较少。这可以提高数据库在内存中的缓存效率，允许更多的数据放入内存中，从而加速查询性能。</li></ul><blockquote><p><strong>压缩表的劣势</strong></p></blockquote><ul><li>压缩和解压缩过程可能对系统产生一些<strong>额外的计算开销</strong>，这可能在某些查询场景下影响性能</li></ul><h3 id="myisam性能" tabindex="-1"><a class="header-anchor" href="#myisam性能" aria-hidden="true">#</a> MyISAM性能</h3><ul><li>MyISAM引擎设计简单，数据以紧密格式存储，在某些场景下性能很好 <ul><li><strong>数据以紧密格式存储，磁盘上的布局更为紧凑</strong></li><li>在只读或很少写入的情况下，MyISAM能够<strong>更快地进行磁盘扫描操作，提高查询性能</strong></li></ul></li><li>MyISAM最典型的性能问题还是<strong>表锁的问题</strong><ul><li>如果所有的查询都长期处于“Lock”状态，那么表锁就是罪魁祸首</li></ul></li></ul><h2 id="myisam和innodb" tabindex="-1"><a class="header-anchor" href="#myisam和innodb" aria-hidden="true">#</a> MyISAM和InnoDB</h2><p>MyISAM引擎是MySQL官方基于早期的ISAM引擎改良而来的，由于其不错的性能表现，再加上丰富的特性支持（全文索引、压缩机制、空间索引/函数等），在MySQL5.5版本之前，一直是MySQL默认的存储引擎。</p><p>但随着时间慢慢推移，开始主推使用InnoDB作为表的引擎，到了MySQL5.6及以后版本中，直接用InnoDB代替了MyISAM，作为了MySQL默认的存储引擎</p><table><thead><tr><th>对比</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>锁</td><td>表锁，即使操作一条记录也会锁住整个表</td><td>行锁，操作时只锁一行，不会影响其他的行，适合高并发操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存要求较高，内存大小对性能有决定性影响</td></tr><tr><td>自带系统表使用</td><td>Y</td><td>N</td></tr><tr><td>关注点</td><td>节省资源、消耗少、简单业务</td><td>并发写、事务、更大资源</td></tr><tr><td>默认安装</td><td>Y</td><td>Y</td></tr><tr><td>默认使用</td><td>N</td><td>Y</td></tr></tbody></table><h3 id="磁盘文件" tabindex="-1"><a class="header-anchor" href="#磁盘文件" aria-hidden="true">#</a> 磁盘文件</h3><p><strong>MyISAM引擎</strong>的表 <code>myisam_table_name</code>，会在本地生成三个磁盘文件：</p><ul><li><code>myisam_table_name.frm</code>：该文件中存储表的结构信息。</li><li><code>myisam_table_name.MYD</code>：该文件中存储表的行数据。</li><li><code>myisam_table_name.MYI</code>：该文件中存储表的索引数据。</li></ul><p><strong>InnoDB引擎</strong>的表 <code>innodb_table_name</code>，在磁盘中仅有两个文件：</p><ul><li><code>innodb_table_name.frm</code>：该文件中存储表的结构信息。</li><li><code>innodb_table_name.ibd</code>：该文件中存储表的行数据和索引数据。</li></ul><blockquote><p>MyISAM的行数据和索引数据会分别用两个文件来存储，InnoDB则合二为一</p></blockquote><h3 id="索引支持" tabindex="-1"><a class="header-anchor" href="#索引支持" aria-hidden="true">#</a> 索引支持</h3><p><strong>MyISAM</strong>引擎将表数据和索引数据分成两个文件进行存储，就注定<strong>无法使用聚簇索引</strong></p><p>InnoDB的表数据和索引数据都存放在同一个.ibd文件中，因此<strong>InnoDB是支持聚簇索引的</strong></p><blockquote><p>为什么MyISAM不支持聚簇索引？</p></blockquote><p>聚簇索引要求<strong>索引键</strong>和<strong>行数据</strong>必须在<strong>物理空间上也是连续</strong>的</p><p>而<code>MyISAM</code>表数据和索引数据，分别位于两个磁盘文件中，这也就注定了它无法满足聚簇索引的要求。</p><blockquote><p>MyISAM不支持聚簇索引也有好处</p></blockquote><p>无论走任何索引，都只需要<strong>一遍查询即可获得数据</strong></p><p><code>InnoDB</code>引擎的表中，如果不走聚簇（主键）索引查询数据，走其他索引的情况下，都需要经过<strong>两遍</strong>查询（回表）才能获得数据。</p><h3 id="事务机制" tabindex="-1"><a class="header-anchor" href="#事务机制" aria-hidden="true">#</a> 事务机制</h3><p><strong>MyISAM不支持事务，InnoDB支持事务</strong></p><h4 id="myisam-1" tabindex="-1"><a class="header-anchor" href="#myisam-1" aria-hidden="true">#</a> MyISAM</h4><ul><li><p>MyISAM不涉及类似支持事务的技术，因此<strong>MyISAM不支持事务</strong></p><ul><li>没有<code>undo_log_buffer</code>缓冲区</li><li>磁盘中没有相应的日志</li></ul></li><li><p>如果使用了MyISAM，想保证事务的原子性，只能在客户端做事务补偿</p><ul><li>比如用户表和学生表必须同时添加成功，只要有一个没添加成功，就对其中一个添加成功的表执行删除操作，进行补偿。</li></ul></li></ul><h4 id="innodb-1" tabindex="-1"><a class="header-anchor" href="#innodb-1" aria-hidden="true">#</a> InnoDB</h4><ul><li><p><strong>InnoDB借助undo-log日志实现事务机制</strong>，可以决定发生异常时SQL是回滚还是提交</p></li><li><p>InnoDB引擎有两个自己专享的日志文件：</p><ul><li>redo-log</li><li>undo-log <ul><li>InnoDB在MySQL启动的时候，会在内存中构建一个<code>undo_log_buffer</code>缓冲区</li><li>同时在磁盘中也有相应的<code>undo-log</code>文件</li></ul></li></ul></li><li><p>在写操作正式执行之前，会先记录redo-log、undo-log。</p></li><li><p>在执行写操作的时候，都是在内存缓冲区中完成数据操作，等待符合刷盘要求的时候，才会将数据刷入磁盘。</p></li></ul><blockquote><p>undo-log如何实现事务机制</p></blockquote><ul><li>undo-log会记录变更前的旧数据 <ul><li>当一个事务commit提交时，会先将当前事务中所有的SQL的<code>redo-log</code>日志改为<code>commit</code>状态 <ul><li>然后由MySQL后台线程刷盘，将缓冲区中的数据刷入磁盘中</li></ul></li><li>当一个事务需要rollback回滚，则会找到<code>undo-log</code>日志中旧数据，将缓冲区内更新过的数据全部还原 <ul><li>由于缓冲区中的数据被还原了，后台线程在刷盘的时候也就不会改变磁盘文件中存储的数据</li></ul></li></ul></li></ul><h3 id="故障恢复" tabindex="-1"><a class="header-anchor" href="#故障恢复" aria-hidden="true">#</a> 故障恢复</h3><p>因为写数据会先写在缓冲区，再写入磁盘，当缓冲区的数据还未落盘，就有丢失数据的风险。</p><ul><li>在InnoDB中只要事务提交，它就能确保数据永远不丢失，无论数据是否落盘</li><li>MyISAM并没有InnoDB引擎可靠，只要数据没有落盘，且SQL还没有被记录到bin-log日志中，MySQL异常关闭，就会丢失数据</li></ul><h4 id="innodb-2" tabindex="-1"><a class="header-anchor" href="#innodb-2" aria-hidden="true">#</a> InnoDB</h4><ul><li>InnoDB在启动时，会在内存中构建一个<code>redo_log_buffer</code>缓冲区，在磁盘中有相应的redo-log日志</li><li>当一条或多条SQL语句执行成功时，无论MySQL在什么时候宕机，<strong>只要这个事务提交了，InnoDB就能确保该事务的数据不会丢失</strong></li></ul><h4 id="myisam-2" tabindex="-1"><a class="header-anchor" href="#myisam-2" aria-hidden="true">#</a> MyISAM</h4><ul><li><strong>MyISAM引擎没有redo-log日志，所以并不支持数据的故障恢复</strong></li><li>如果表是使用<code>MyISAM</code>引擎创建的，当一条<code>SQL</code>将数据写入到了缓冲区后，SQL还未被写到bin-log日志，此时机器断电、DB宕机了，重启之后由于数据在宕机前还未落盘，丢失无法找回 <ul><li>若bin-log已经记录了相关的修改操作，那么在MySQL重启后，可以通过回放bin-log来恢复这些操作，减少数据丢失的风险</li><li>但bin-log并不是专门用于数据恢复的，而是主从复制</li></ul></li></ul><h3 id="锁粒度" tabindex="-1"><a class="header-anchor" href="#锁粒度" aria-hidden="true">#</a> 锁粒度</h3><p>锁的实现力度和索引有关</p><ul><li>MyISAM只支持表锁</li><li>InnoDB支持表锁，行锁</li></ul><blockquote><p>为什么MyISAM只支持表锁？和索引有什么关系？</p></blockquote><p>MyISAM只有一层索引，如果要加行锁，加锁的时候只能对操作到的索引那棵树的那行记录加锁，但是无法锁住其他树上的数据。</p><p>InnoDB支持聚簇索引，要上锁只需要给聚簇索引树上的行记录上锁就行，其他的索引要访问也得经过聚簇索引，锁住了就没办法访问</p><p>同时InnoDB引擎构建的缓冲区中，会专门申请一块内存作为锁空间，同时再结合InnoDB支持事务，所以InnoDB是基于事务来生成锁对象，相较于SQL Server的行锁来说，InnoDB的行锁会更节约内存。</p><h3 id="并发性能" tabindex="-1"><a class="header-anchor" href="#并发性能" aria-hidden="true">#</a> 并发性能</h3><p>MyISAM只支持表锁，而InnoDB同时支持表锁、行锁。因为<strong>InnoDB支持的锁粒度更小，并发重读的概率更低，因此并发支撑越高</strong>。</p><h4 id="innodb-3" tabindex="-1"><a class="header-anchor" href="#innodb-3" aria-hidden="true">#</a> InnoDB</h4><blockquote><p>锁粒度小、版本链+事务快照、MVCC多版本并发控制，因此支持高并发</p></blockquote><p>InnoDB不止因为<strong>锁粒度小</strong>而支持高并发，InnoDB还可以基于undo-log日志的<strong>版本链+事务快照</strong>，以及<strong>MVCC多版本并发控制</strong>，对读-写共存的场景支持并发执行。</p><p>比如说，当一条数据正在被读的时候，允许其他事务对这条数据进行修改，在<strong>可重复读的隔离级别之下</strong>：</p><ul><li>读事务会根据事务快照，读取的都是在开启读事务时的数据，其他事务对被读取的数据进行操作，对读事务是不可见的</li><li>而<strong>事务快照引用的旧数据，就是位于undo-log的版本链</strong>中</li></ul><h4 id="myisam-3" tabindex="-1"><a class="header-anchor" href="#myisam-3" aria-hidden="true">#</a> MyISAM</h4><blockquote><p>读取时会对表加共享锁，写入时对表加排他锁</p></blockquote><p>MyISAM只支持表锁，因此当一条SQL在写数据时，会加排他锁，阻塞其他的读操作。</p><p>当一条线程在读数据时，会加共享锁，允许其他想要读取数据的线程来访问表，但会阻塞想要执行写操作的线程</p><ul><li>共享锁：允许多个会话获取同一个资源的读取权限，但没有写入权限，用于保护读取操作，不阻塞其他共享锁的获取。</li><li>排他锁：只允许一个会话获取同一个资源的访问权限，不允许其他会话对同一资源的读写，保护写操作</li></ul><h3 id="内存利用度" tabindex="-1"><a class="header-anchor" href="#内存利用度" aria-hidden="true">#</a> 内存利用度</h3><p>因为在InnoDB使用聚簇索引，聚簇索引和真实数据存放在一起，索引即数据，所以缓存索引必须将数据也缓存进来，而MyISAM因为数据和索引分开存储，所以可以只缓存索引</p><ul><li><p>MyISAM只缓存索引，不缓存真实数据</p></li><li><p>InnoDB不仅缓存索引还要缓存真实数据， 对内存要求较高 ，而且内存大小对性能有决定性的影响</p></li></ul><h4 id="innodb-4" tabindex="-1"><a class="header-anchor" href="#innodb-4" aria-hidden="true">#</a> InnoDB</h4><p><strong>InnoDB将所有能够在内存完成的操作，全部都放在内存中完成。</strong></p><ul><li>无论是<strong>读写数据</strong>、<strong>维护索引结构</strong>，还是<strong>记录日志</strong>，各类操作都在内存完成。</li></ul><p>只要机器内存够大，为缓冲池分配的内存够多，MySQL在线上运行的时间越久，InnoDB甚至会将磁盘中所有数据加载入内存</p><p>此后的读写请求基本无需走磁盘，都采用异步I/O的方式完成，即先写内存+后台线程刷写的方式执行。</p><h4 id="myisam-4" tabindex="-1"><a class="header-anchor" href="#myisam-4" aria-hidden="true">#</a> MyISAM</h4><p>虽然MyISAM中也有缓冲池以及异步I/O技术，但<strong>对内存的开发都远不如InnoDB引擎</strong>，运行期间大量操作依旧会走磁盘完成，不如InnoDB逐步演变成半内存式引擎。</p><p>由于MySQL官方最初将MySQL Server + MyISAM锁死了，因此MyISAM很多功能都依赖于MySQL Server实现。比如：</p><ul><li>InnoDB创造了一个插入缓冲区，也就是后来的写入缓冲区，用于减少写操作执行时磁盘I/O</li><li>MyISAM引擎没有相应实现，而是依赖于MySQL Server在工作线程中设计的<code>bulk_insert_buffer</code>批量插入缓冲区来实现类似的功能</li></ul><h3 id="innodb优势" tabindex="-1"><a class="header-anchor" href="#innodb优势" aria-hidden="true">#</a> InnoDB优势</h3><blockquote><p>MyISAM不支持的，InnoDB全都支持：</p></blockquote><ul><li>存储方式：MyISAM将表数据和索引数据分成两个文件存储</li><li>索引支持：因为MyISAM将表数据和索引数据分开存储，因此不支持聚簇索引</li><li>事务支持：MyISAM没有undo-log日志用于回滚，因此不支持事务</li><li>故障恢复：MyISAM依靠bin-log实现，bin-log中没有写入的数据会丢失</li><li>锁粒度支持：因为MyISAM不支持聚簇索引，因此无法实现行锁，只支持表锁</li><li>并发性能：MyISAM只支持表锁，所以多条线程出现读-写并发场景会阻塞</li><li>内存利用度：MyISAM过度依赖MySQL Server，对缓冲池、异步I/O技术开发不够</li></ul><h3 id="myisam优势" tabindex="-1"><a class="header-anchor" href="#myisam优势" aria-hidden="true">#</a> MyISAM优势</h3><h4 id="统计表记录总数" tabindex="-1"><a class="header-anchor" href="#统计表记录总数" aria-hidden="true">#</a> 统计表记录总数</h4><p>在MyISAM引擎中会记录表的行数，也就是当执行<code>count()</code>时，可以直接获取之前统计的值并返回。</p><ul><li>在InnoDB中统计一张表的总数时，会触发全表扫描，InnoDB会一行行的去统计表的行数</li><li>MyISAM的这个特性也仅仅只适用于<strong>统计全表数据量</strong>，如果后面跟了<code>where</code>条件，那InnoDB、MyISAM的工作模式是相同的</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> <span class="token identifier"><span class="token punctuation">`</span>table_name<span class="token punctuation">`</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="删除数据-表" tabindex="-1"><a class="header-anchor" href="#删除数据-表" aria-hidden="true">#</a> 删除数据/表</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">delete</span> <span class="token keyword">from</span> <span class="token identifier"><span class="token punctuation">`</span>table_name<span class="token punctuation">`</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用<code>delete</code>命令清空表数据时，注意是清空表，而不是直接删除表</p><ul><li><strong>MyISAM会直接重新创建表数据文件</strong>，就是创建一个空表，就相当于清空表了</li><li><strong>InnoDB则是一行行删除数据</strong></li></ul><p>因此对于清空表数据的操作，MyISAM比InnoDB快上无数倍。</p><p>同时MyISAM引擎的表，对于<code>delete</code>过的数据不会立即删除，而是先隐藏起来，后续定时删除或手动删除</p><ul><li>好处：误删一张表的大量数据时，只要手速够快，手动将本地的.MYD、.MYI文件拷贝出去，就可以直接基于这两个数据文件恢复数据，也不需要通过日志或第三方工具修复</li></ul><p>手动删除的命令如下：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">optimize</span> <span class="token keyword">table</span> <span class="token identifier"><span class="token punctuation">`</span>table_name<span class="token punctuation">`</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="crud速度更快" tabindex="-1"><a class="header-anchor" href="#crud速度更快" aria-hidden="true">#</a> CRUD速度更快</h4><blockquote><p>理论上，MyISAM的读写效率会高于InnoDB，但实际生产环境中并非如此，只有在单个客户端与MyISAM连接的时候相比于InnoDB才会有更高的性能</p></blockquote><p><strong>InnoDB</strong></p><ul><li>就算没有创建主键，InnoDB也会定义一个隐式字段ROW_ID作为聚簇索引字段，因此聚簇索引在InnoDB中是必然存在的。</li><li>但InnoDB的索引存在下列问题，影响<strong>读写数据的性能</strong>： <ul><li>如果在二级索引查找数据，需要回表才可以得到数据</li><li>插入、修改数据，需要维护聚簇索引和非聚簇索引之间的关系</li></ul></li></ul><p><strong>MyISAM</strong></p><blockquote><p>MyISAM的查询、插入性能较好</p></blockquote><p>创建的索引都是非聚簇索引，每个索引之间都是独立的，在索引中存储的是直接指向行数据的地址，并非聚簇索引的索引键</p><ul><li>因此无论走任何索引，走一次就可以获取数据，不用回表 <ul><li>在索引中存储的是记录在数据文件中的地址偏移量</li></ul></li><li>写数据时，不用维护不同索引之间的关系，因为每个索引都是独立的</li><li>允许并发插入，即当表被读取时，仍然可以插入数据</li></ul><p><strong>单个客户端连接</strong></p><p>在单个客户端的情况下，MyISAM的读写性能远超InnoDB，因为InnoDB需要维护聚簇索引。而MyISAM因为每个索引都是独立的，因此</p><ul><li>插入、修改数据不需要维护其他索引和聚簇索引的关系</li><li>插入表数据直接追加在表数据文件(.MYD文件)的末尾，不需要像聚簇索引那样在数据文件中找到合适的位置插入数据 <ul><li>但MyISAM仍然需要更新索引文件以包含指向新数据的指针</li></ul></li><li>单个连接意味着只有一条线程，一条线程就不会出现锁竞争，表锁会一直由这条线程持有，因此单客户端MyISAM比InnoDB快</li></ul><p><strong>多个客户端连接</strong></p><p>多个客户端连接的情况下，随着连接数的增加，工作线程会不断增加，InnoDB的性能会逐步上升</p><p>但MyISAM从头到尾都很低，这是因为MyISAM的<strong>锁机制</strong>导致的。</p><ul><li>MyISAM只支持表锁，只允许一个线程一张表具有写权限，同时允许多个线读线程共享同一张表，但拒接其他写线程的访问。读写并发场景中，一张被写的表只允许单线程操作，冲突大，吞吐量严重下降</li><li>InnoDB支持行锁，并发冲突小，在高并发，多连接的场景中，性能更出色</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231222002102720.png" alt="image-20231222002102720" tabindex="0" loading="lazy"><figcaption>image-20231222002102720</figcaption></figure><h4 id="压缩机制" tabindex="-1"><a class="header-anchor" href="#压缩机制" aria-hidden="true">#</a> 压缩机制</h4><blockquote><p>了解即可，现在不会让单库承载大量数据，当数据到一定级别，会采用分库分表来均摊数据，避免单库数据量过大影响性能</p></blockquote><p>数据量的增长，容易出现以下两个问题：</p><ul><li>I/O瓶颈：DB数据量过大，导致内存无法载入太多数据，从而触发大量磁盘I/O，DB整体性能降低</li><li>磁盘空间不足：部署数据库的机器磁盘无法存储迅速增长的数据，需要不断扩容</li></ul><p><strong>MyISAM</strong></p><p>MyISAM为了解决数据迅速增长带来的问题，可以通过<code>myisampack</code>工具对数据表进行压缩，压缩的效果至少能让数据缩小一半，但压缩过后的数据<strong>只可读，不可写</strong></p><p><strong>InnoDB</strong></p><p>到了MySQL5.7版本中，该特性也被移植到了InnoDB引擎中，相关的压缩参数如下：</p><ul><li><code>innodb_compression_level</code>：调整压缩的级别，可控范围在<code>1~9</code>，越高压缩效果越好，但压缩速度也越慢。</li><li><code>innodb_compression_failure_threshold_pct</code>：当压缩失败的数据页超出该比例时，会加入数据填充来减小失败率，为<code>0</code>表示禁止填充。</li><li><code>innodb_compression_pad_pct_max</code>：一个数据页中最大允许填充多少比例的空白数据。</li><li><code>innodb_log_compressed_pages</code>：控制是否对<code>redo-log</code>日志的数据也开启压缩机制。</li><li><code>innodb_cmp_per_index_enabled</code>：是否对索引文件开启压缩机制。</li></ul><h3 id="myisam应用场景" tabindex="-1"><a class="header-anchor" href="#myisam应用场景" aria-hidden="true">#</a> MyISAM应用场景</h3><h4 id="单体架构" tabindex="-1"><a class="header-anchor" href="#单体架构" aria-hidden="true">#</a> <strong>单体架构</strong></h4><ul><li>不需要事务</li><li>并发冲突低</li><li>读写操作多</li></ul><p>例如文章表、帖子表、字典表，但这种表在一个系统中占比很少</p><h4 id="主从架构" tabindex="-1"><a class="header-anchor" href="#主从架构" aria-hidden="true">#</a> <strong>主从架构</strong></h4><blockquote><p>主从架构非常适合MyISAM引擎</p></blockquote><p>利用主从架构实现读写分离</p><ul><li>主节点承载写请求</li><li>从节点承载读请求</li></ul><p>从节点的表可以改为MyISAM存储引擎</p><ul><li>MyISAM的索引查询数据不需要回表，查询速度快</li><li>从库只会有读请求，支持并发读取</li><li>从库的数据由后台线程进行主从复制，从库在写入数据时，只会有少数几条线程执行写入工作，因而造成的冲突不会太大，不会因为表锁引起大量阻塞</li><li>而且MyISAM是可以读写并发的，即用户在对一个表进行查询操作时，其他的线程可以向该表插入数据</li></ul><h2 id="innodb底层原理" tabindex="-1"><a class="header-anchor" href="#innodb底层原理" aria-hidden="true">#</a> InnoDB底层原理</h2><h3 id="innodb存储方式" tabindex="-1"><a class="header-anchor" href="#innodb存储方式" aria-hidden="true">#</a> InnoDB存储方式</h3><p>InnoDB 是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的</p><p>真正处理数据的过程是发生在内存中的，需要把磁盘中的数据加载到内存中，如果是处理写请求的话，还需要把内存中的内容刷到磁盘上</p><blockquote><p>InnoDB会将数据一条一条的从磁盘上读取出来吗？</p></blockquote><p>InnoDB 采取的方式是：<strong>将数据划分为若干个页</strong>，<strong>以页作为磁盘和内存之间交互的基本单位</strong>，<strong><u>InnoDB中页的大小一般为 16 KB</u></strong></p><p>在一般情况下，<strong>一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中</strong>。</p><h3 id="inndb行格式" tabindex="-1"><a class="header-anchor" href="#inndb行格式" aria-hidden="true">#</a> InnDB行格式</h3><p>SQL是以记录为单位来向表中插入数据的，这些<strong>记录在磁盘上的存放方式也被称为行格式或者记录格式</strong></p><p><strong>InnoDB有四种不同的行格式</strong></p><ul><li>Compact</li><li>Redundant</li><li>Dynamic</li><li>Compressed</li></ul><h4 id="指定行格式" tabindex="-1"><a class="header-anchor" href="#指定行格式" aria-hidden="true">#</a> 指定行格式</h4><p>可以在创建表或修改表的时候指定行格式</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名 <span class="token punctuation">(</span>列信息···<span class="token punctuation">)</span> ROW_FORMAT<span class="token operator">=</span>行格式名称
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 ROW_FORMAT<span class="token operator">=</span>行格式名称
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="compact行格式" tabindex="-1"><a class="header-anchor" href="#compact行格式" aria-hidden="true">#</a> Compact行格式</h4><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231222103325391.png" alt="image-20231222103325391" tabindex="0" loading="lazy"><figcaption>image-20231222103325391</figcaption></figure><ul><li>一条完整的记录可以被分为<strong>记录的额外信息</strong>和<strong>记录的真实数据</strong>两部分</li></ul><h5 id="记录的额外信息" tabindex="-1"><a class="header-anchor" href="#记录的额外信息" aria-hidden="true">#</a> 记录的额外信息</h5><p>这部分信息是<strong>服务器为了描述这条记录而不得不额外添加的一些信息</strong></p><p>这些额外信息分为3类</p><ul><li>变长字段长度列表</li><li>NULL值列表</li><li>记录头信息</li></ul><h6 id="变长字段长度列表" tabindex="-1"><a class="header-anchor" href="#变长字段长度列表" aria-hidden="true">#</a> 变长字段长度列表</h6><p>MySQL支持一些变长的数据类型，如VARCHAR，VARBINARY，各种TEXT，各种BLOB ······</p><p>将<strong>拥有这些数据类型的列成为<u>变长字段</u></strong>，<strong>变长字段中存储多少字节的数据是不固定的</strong></p><p>所以存储真实数据的时候需要顺便<strong>将这些数据占用的字节数也存起来</strong></p><p>这些变长字段占用的存储空间分为两部分</p><ul><li>真正的数据内容</li><li>占用的字节数</li></ul><p>在Compact行格式中，<strong>将所有变长字段的真实数据占用的字节长度都存放在记录的开头部分，形成一个变长字段长度列表</strong></p><p>各个变长字段数据占用的字节数<strong>按照列的顺序<u>逆序</u>存放</strong></p><blockquote><p>为什么变长字段长度列表要按逆序存放？</p></blockquote><p>记录头信息中指向下一个记录的指针，指向的是<strong>下一条记录的记录头信息和真实数据之间的位置</strong>。</p><ul><li>这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li></ul><p>变长字段长度列表中的信息逆序存放</p><ul><li><p>这样的好处是，可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，提高 CPU Cache 的命中率</strong>。</p></li><li><p>让真实数据和对应的字段长度信息符合局部性原理的范围</p></li><li><p>同样的道理， NULL 值列表的信息也需要逆序存放</p></li></ul><blockquote><p>变长字段长度列表存储例子</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 字符集是 ascii（所以每一个字符占用的 1 字节）</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>t_user<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>phone<span class="token punctuation">`</span></span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">=</span> ascii ROW_FORMAT <span class="token operator">=</span> COMPACT<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231222105024692.png" alt="image-20231222105024692" tabindex="0" loading="lazy"><figcaption>image-20231222105024692</figcaption></figure><p>对于第一条记录：</p><ul><li>name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01</li><li>phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03</li><li>age为固定长度字段，不需要记录</li></ul><p>在表中，name比phone先定义，因此正序为name，phone。</p><p>在变长字段长度列表中，一行数据中，可变长字段实际占用字节数逆序存放，因此这里是phone，name的顺序存放的</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231222105207537.png" alt="image-20231222105207537" tabindex="0" loading="lazy"><figcaption>image-20231222105207537</figcaption></figure><p>由于示例记录中变长列中的字符串都比较短，也就是内容占用的字节数比较少，用1个字节就可以表示，但如果变长列内容占用的字节数比较多，可能就需要2个字节来表示</p><blockquote><p>什么时候变长字段长度需要用2个字节来表示？</p></blockquote><p><strong>W、M、L概念解释</strong></p><ul><li>假设某个字符集中表示一个字符最多需要使用的字节数为W ，也就是使用SHOW CHARSET 语句的结果中的Maxlen 列 <ul><li>比方说utf8 字符集中的W 就是3 ， gbk 字符集中的W 就是2 ， ascii 字符集中的W 就是1</li></ul></li><li>对于变长类型VARCHAR(M) 来说，这种类型表示能存储最多M 个字符（注意是字符不是字节） <ul><li>所以这个类型能表示的字符串最多占用的字节数就是M×W</li></ul></li><li>假设它实际存储的字符串占用的字节数是L</li></ul><p><strong>确定真正字符串占用字节数的规则</strong></p><ul><li><p>$M*W &lt; 255$，用1个字节</p><ul><li>InnoDB在读记录的变长字段长度列表时先查看表结构</li><li>如果某个变长字段允许存储的最大字节数不大于255，就认为只需要使用1个字节</li><li>255 = 1111 1111</li></ul></li><li><p>$M*W&gt;255$，分两种情况：</p><ul><li>$L&lt;=127$，用1个字节</li><li>$L&gt;127$，用2个字节</li><li>如果允许存储的最大字节数大于255，该字节的第一个二进制位被设计位一个标识位 <ul><li>如果该字节第一个位为0，代表该字节是一个单独的字段长度</li><li>如果该字节第一个位为1，代表该字节是半个字段长度</li></ul></li><li>127 = 0111 1111</li><li>对于一些占用字节数非常多的字段，例如大于16kb，那么该记录在单个页面无法存储</li><li>InnoDB会将一部分数据存到溢出页中，在变长字段长度列表中也只存储本页面中的长度，所以两个字节也放的下来</li></ul></li></ul><p><strong>变长字段允许存储的最大字节数大于255并且实际存储的字节数也超过了127</strong>（去掉标识位的一个字节表示的十进制数），<strong>就用2个字节</strong>，否则就用1个字节</p><blockquote><p>每个数据库表的行格式都要有变长字段长度列表吗？</p></blockquote><ul><li>变长字段长度列表不是必须的</li></ul><ul><li><p>数据表没有变长字段时，例如全都是int类型，这时候表里的行格式就不会有变长字段长度列表了</p></li><li><p>变长字段长度列表只出现在数据表有变长字段的时候</p></li></ul><blockquote><p>如果定义的是变长的字符集呢？</p></blockquote><p>示例表中定义的字符集是定长的ASCII字符集，一个字符固定使用一个字节，所以CHAR列的长度不会被存入变长字段长度列表</p><p><strong>如果采用变长的字符集，CHAR列的长度也会被存入变长字段长度列表</strong></p><ul><li>变长字符集表示一个字符需要的字节数不确定，GBK表示一个字符要1或2个字节，UTF8表示一个字符要1或2或3个字节</li></ul><h6 id="null值列表" tabindex="-1"><a class="header-anchor" href="#null值列表" aria-hidden="true">#</a> NULL值列表</h6><p>表中的某些列可能会存储NULL值，将这些NULL值都放在记录真实数据中存储会很占地方</p><p>Compact行格式将这些值为NULL的列统一管理起来，存储到NULL值列表中</p><p><strong>处理过程</strong></p><ol><li>统计表中允许存储NULL值的列 <ul><li>主键列，NOT NULL列多少不可以存储NULL值的，统计的时候不会将这些列算进去</li><li><strong>如果表中没有允许存储NULL的列，那么NULL值列表也不存在了</strong></li></ul></li><li>给每个允许存储NULL值的列对应一个二进制位，二进制位按照列的顺序**<u>逆序</u>**排列 <ul><li>二进制位值为1，代表该列的值为NULL</li><li>二进制位值为0，代表该列的值不为NULL</li></ul></li><li>NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0</li></ol><blockquote><p>NULL值列表示例</p></blockquote><p>示例表结构</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231222170508195.png" alt="image-20231222170508195" tabindex="0" loading="lazy"><figcaption>image-20231222170508195</figcaption></figure><p>对于第一条记录</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231222170535186.png" alt="image-20231222170535186" tabindex="0" loading="lazy"><figcaption>image-20231222170535186</figcaption></figure><p>对于第二条记录</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231222172001150.png" alt="image-20231222172001150" tabindex="0" loading="lazy"><figcaption>image-20231222172001150</figcaption></figure><p>把三条记录的 NULL 值列表都填充完毕后，它们的行格式是这样的</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231222172210612.png" alt="image-20231222172210612" tabindex="0" loading="lazy"><figcaption>image-20231222172210612</figcaption></figure><blockquote><p>NULL值列表的空间是不是固定1字节的？</p></blockquote><p>NULL 值列表的空间不是固定 1 字节的。</p><p>当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的NULL 值列表，以此类推。</p><h6 id="记录头信息" tabindex="-1"><a class="header-anchor" href="#记录头信息" aria-hidden="true">#</a> 记录头信息</h6><p>记录头信息由固定的 5 个字节组成。 5 个字节也就是 40 个二进制位，不同的位代表不同的意思</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223102318173.png" alt="image-20231223102318173" tabindex="0" loading="lazy"><figcaption>image-20231223102318173</figcaption></figure><p>几个比较重要的标识：</p><ul><li><p><code>delete_mask</code> ：标识此条数据是否被删除。</p><ul><li>执行 <strong>detele 删除记录的时候</strong>，并不会真正的删除记录，只是<strong>将这个记录的 delete_mask 标记为 1</strong>。</li><li>在MySQL中DELETE一条数据后，该条数据不会立即从磁盘上移除，因为移除后把其他的记录在磁盘上进行重新排列需要消耗性能，因此该记录被DELETE后，只是进行标记</li><li>所有被删除的记录都会组成一个「垃圾链表」，这个链表中的记录占用的空间即为「可重用空间」，之后如果有新记录要插入到表中，可能会把这些被删除的记录占用的存储空间覆盖掉</li></ul></li><li><p><code>next_record</code>：下一条记录的位置。</p><ul><li><strong>记录与记录之间是通过链表组织的</strong>。</li><li><strong>指向的是下一条记录的「记录头信息」和「真实数据」之间的位置</strong>，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li></ul></li><li><p><code>record_type</code>：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</p></li></ul><h5 id="记录的真实数据" tabindex="-1"><a class="header-anchor" href="#记录的真实数据" aria-hidden="true">#</a> 记录的真实数据</h5><p>记录真实数据部分除了表中定义的字段，还有三个隐藏字段</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223101148928.png" alt="image-20231223101148928" tabindex="0" loading="lazy"><figcaption>image-20231223101148928</figcaption></figure><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223102556124.png" alt="image-20231223102556124" tabindex="0" loading="lazy"><figcaption>image-20231223102556124</figcaption></figure><ul><li><code>row_id</code><ul><li>如果建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。</li><li>如果建表的时候没有定义主键，但是有定义一些唯一约束列，InnoDB会将第一个唯一列定义为主键（聚簇索引）</li><li>如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。</li></ul></li><li><code>trx_id</code><ul><li>事务id，表示这个数据是由哪个事务生成的</li><li>trx_id是必须的，占用6个字节</li></ul></li><li><code>roll_pointer</code><ul><li>记录上一个版本的指针。roll_pointer是必须的，占用7个字节</li></ul></li></ul><h5 id="完整的compact行格式示例" tabindex="-1"><a class="header-anchor" href="#完整的compact行格式示例" aria-hidden="true">#</a> 完整的Compact行格式示例</h5><blockquote><p>表结构及数据</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> record_format_demo <span class="token punctuation">(</span>
  c1 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  c2 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  c3 <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  c4 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>ascii ROW_FORMAT<span class="token operator">=</span>COMPACT<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> record_format_demo<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">------+-----+------+------+</span>
<span class="token operator">|</span>  c1  <span class="token operator">|</span>  c2 <span class="token operator">|</span>  c3  <span class="token operator">|</span>  c4  <span class="token operator">|</span>	   
<span class="token operator">+</span><span class="token comment">------+-----+------+------+</span>
<span class="token operator">|</span> aaaa <span class="token operator">|</span> bbb <span class="token operator">|</span>  cc  <span class="token operator">|</span>  d   <span class="token operator">|</span>
<span class="token operator">|</span> eeee <span class="token operator">|</span> fff <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">------+-----+------+------+</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>两条记录的完整行格式</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223102723624.png" alt="image-20231223102723624" tabindex="0" loading="lazy"><figcaption>image-20231223102723624</figcaption></figure><p>对于第一条记录</p><ul><li><p>变长字段长度列表中存的是C1、C2、C4列的数据长度：01 03 04，因为C3列的数据类型是定长的CHAR</p></li><li><p>NULL值列表中是00，二进制表示为0000 0000，表示该行记录中没有空值</p></li><li><p>由于表没有定义主键，所以InnoDB自动给该表的所有记录增加row_id列</p></li><li><p>C3列数据类型是CHAR(10)，实际只存储了2个字符，所以剩下的8个字符都是由空格填充，空格在ASCII编码中表示为20</p></li></ul><p>对于第二条记录</p><ul><li>变长字段长度列表中存的是C1、C2列的数据长度：03 04，因为C3列的数据类型是定长的CHAR，C4没有存数据</li><li>NULL值列表中是06，二进制表示为0000 0110 <ul><li>由于C2列是定义为NOT NULL的，所以没有给它分配NULL值列表的位置</li><li>C1有值，所以第一个位是0</li><li>C3和C4为空，所以第二第三个位是1</li></ul></li><li>由于表没有定义主键，所以InnoDB自动给该表的所有记录增加row_id列</li></ul><h4 id="行溢出数据" tabindex="-1"><a class="header-anchor" href="#行溢出数据" aria-hidden="true">#</a> 行溢出数据</h4><h5 id="varchar数据存储" tabindex="-1"><a class="header-anchor" href="#varchar数据存储" aria-hidden="true">#</a> VARCHAR数据存储</h5><blockquote><p>一张表只有一个字段</p></blockquote><p><strong>VARCHAR类型最多可以存储65535字节</strong></p><p>这个65535个字节除了列本身的数据之外，还包括一些其他的数据（ storage overhead ）</p><p>存储一个VARCHAR类型的列，其实需要占用3部分存储空间：</p><ul><li><p><strong>真实数据</strong></p></li><li><p><strong>真实数据占用字节的长度（最多2字节）</strong></p></li><li><p><strong>NULL值标识（如果该列有NOT NULL属性，则可以没有这部分存储空间）（1字节）</strong></p><ul><li><p>如果该VARCHAR 类型的列不是非空的，那最多能存储65532个字节的数据，因为真实数据的长度可能占用2个字节， NULL 值标识需要占用1个字节</p></li><li><p>如果该VARCHAR 类型的列是非空的，那最多能存储65533个字节的数据，因为真实数据的长度可能占用2个字节， 不需要NULL 值标识</p></li></ul></li></ul><p>VARCHAR(M)的M指的是字符，每个字符集单个字符表示的最大字节数是不一样的</p><ul><li>ASCII字符集(一个字符1字节)下，非空-&gt;VARCHAR(65533)，不是非空-&gt;VARCHAR(65532)</li><li>GBK字符集(一个字符最大2字节)下，非空-&gt;VARCHAR(32765)，不是非空-&gt;VARCHAR(32764) <ul><li>65535 / 2 = 32767</li></ul></li><li>UTF-8字符集(一个字符最大3字节)下，非空-&gt;VARCHAR(21843)，不是非空-&gt;VARCHAR(21842) <ul><li>65535 / 3 = 21845</li></ul></li></ul><blockquote><p>一张表有多个字段</p></blockquote><p><strong>如果有多个字段的话，要保证<u>所有字段的长度</u> + <u>变长字段字节数列表所占用的字节数</u> + <u>NULL值列表所占用的字节数</u> &lt;= 65535</strong>。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test <span class="token punctuation">(</span>
	<span class="token string">&#39;id&#39;</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    <span class="token string">&#39;name&#39;</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">65277</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> CAHRACTER <span class="token keyword">SET</span> ascii ROW_FORMAT <span class="token operator">=</span> COMPACT<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>255(小于等于255) + 1(变长长度) + 65277(大于255) + 2(变长长度) = 65535</li></ul><h5 id="行溢出" tabindex="-1"><a class="header-anchor" href="#行溢出" aria-hidden="true">#</a> 行溢出</h5><h6 id="行溢出的原因" tabindex="-1"><a class="header-anchor" href="#行溢出的原因" aria-hidden="true">#</a> 行溢出的原因</h6><ul><li>MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 <code>16KB</code> = <code>16384字节</code></li><li>一个 VARCHAR(N) 类型的列最多可以存储 <code>65532字节</code>，一些大对象如 TEXT、BLOB 可能存储更多的数据</li><li>这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</li></ul><h6 id="compact行格式处理溢出数据" tabindex="-1"><a class="header-anchor" href="#compact行格式处理溢出数据" aria-hidden="true">#</a> Compact行格式处理溢出数据</h6><p>如果一个数据页存不下一条完整的记录，InnoDB会自动将溢出的部分存到「溢出页」中。</p><ul><li>在一般情况下，InnoDB 的数据都是存放在 「数据页」中</li><li>但是当发生行溢出时，溢出的数据会存放到「溢出页」中</li></ul><p><strong>Compact 行格式</strong>在发生行溢出后，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223124714563.png" alt="image-20231223124714563" tabindex="0" loading="lazy"><figcaption>image-20231223124714563</figcaption></figure><h4 id="dynamic和compressed行格式" tabindex="-1"><a class="header-anchor" href="#dynamic和compressed行格式" aria-hidden="true">#</a> Dynamic和Compressed行格式</h4><p>MySQL5.7默认的行格式就是Dynamic</p><p>这两个行格式跟Compact一样，只不过处理行溢出的时候有点不同</p><blockquote><p><strong>Compressed 和 Dynamic 处理溢出的数据</strong></p></blockquote><ul><li>这两种格式采用<strong>完全的行溢出方式</strong></li><li>记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223124744637.png" alt="image-20231223124744637" tabindex="0" loading="lazy"><figcaption>image-20231223124744637</figcaption></figure><blockquote><p>Compressed行格式和Dynamic行格式的不同之处</p></blockquote><p>Compressed 行格式会采用压缩算法对页面进行压缩，以节省空间。</p><h4 id="innodb行格式总结" tabindex="-1"><a class="header-anchor" href="#innodb行格式总结" aria-hidden="true">#</a> InnoDB行格式总结</h4><blockquote><p><strong>MySQL的NULL值是怎么存放的？</strong></p></blockquote><p>MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。</p><p>NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。</p><blockquote><p><strong>MySQL 怎么知道 VARCHAR(n) 实际占用数据的大小？</strong></p></blockquote><p>MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。</p><blockquote><p><strong>VARCHAR(n) 中 n 最大取值为多少？</strong></p></blockquote><p>一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。计算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。</p><p>假设表中只有一个VARCHAR字段</p><ul><li>如果该VARCHAR字段是非空的，则最多可以取到65533，具体是65535 - 变长字段占用字节数2</li><li>如果该VARCHAR字段是可以为空的，则最多可以取到65532，具体是65535 - 变长字段占用字节数2 - NULL值列表所占字节数1</li></ul><p>如果表中有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;= 65535。</p><blockquote><p><strong>行溢出后，MySQL 是怎么处理的？</strong></p></blockquote><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。</p><p>Compact 行格式针对行溢出的处理是这样的：</p><ul><li>当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，</li><li>然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</li></ul><p>Compressed 和 Dynamic 这两种格式采用完全的行溢出方式</p><ul><li><p>记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。</p></li><li><p>实际的数据都存储在溢出页中。</p></li></ul><h3 id="char和varchar" tabindex="-1"><a class="header-anchor" href="#char和varchar" aria-hidden="true">#</a> CHAR和VARCHAR</h3><h4 id="mysql层的区别" tabindex="-1"><a class="header-anchor" href="#mysql层的区别" aria-hidden="true">#</a> MySQL层的区别</h4><ul><li><strong>最大长度：CHAR是255，VARCHAR是65535，单位是字节</strong><ul><li>但根据不同的行格式，实际上VARCHAR的最大长度无法到达65535字节</li></ul></li><li><strong>尾随空格：CHAR会将尾随空格去掉，而VARCHAR不会</strong><ul><li>如果写入CHAR列的字符串的长度大小小于指定的字符长度，那么MySQL会在源字符串后填充空格一直到指定的长度</li><li>读取CHAR列中的值时，MySQL会删除后面的空格</li><li>MySQL认为CAHR列存的<code>&#39;a &#39;</code> 和 <code>&#39;a&#39;</code>是相同的值，如果该列有唯一约束，则会插入失败</li></ul></li><li><strong>存储空间占用：VARCAHR会占用额外的1-2个字节来存储字符串长度</strong><ul><li>如果最大长度超过255字节，并实际占用字节数&lt;=127，使用1字节存储长度</li><li>如果最大长度超过255字节，并实际占用字节数&gt;127，使用2字节存储长度</li></ul></li></ul><h4 id="存储引擎层的区别" tabindex="-1"><a class="header-anchor" href="#存储引擎层的区别" aria-hidden="true">#</a> 存储引擎层的区别</h4><ul><li>CHAR和VARCHAR都会存储字符串长度</li><li>对于CHAR(N)字段，如果实际存储数据小于<code>N</code>字节，会填充空格到<code>N</code>个字节。</li></ul><h4 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景" aria-hidden="true">#</a> 适用场景</h4><h5 id="varchar" tabindex="-1"><a class="header-anchor" href="#varchar" aria-hidden="true">#</a> <strong>VARCHAR</strong></h5><ul><li>字符串列的最大长度比平均长度大很多 <ul><li>比如最大长度是10，平均长度是1</li><li>如果使用CHAR，就需要给每一行都分配CHAR(10)来存储，而实际上平均只会用到一个字符的空间</li></ul></li><li>列的更新很少，所以碎片化不是问题</li><li>使用UTF-8复杂的字符集，每个字符都使用不同的字节数进行存储，这样一列中每一行占用的字节数都有所不同，使用可变长列存储比较合适</li></ul><h5 id="char" tabindex="-1"><a class="header-anchor" href="#char" aria-hidden="true">#</a> CHAR</h5><ul><li>所有值都接近同一个长度 <ul><li>例如MD5密码，是定长的</li></ul></li><li>经常变更的数据，定长的CHAR不容易产生碎片</li><li>对于非常短的列，CHAR比VARCHAR在存储空间上更有效率 <ul><li>例如CHAR(1)如果采用ASCII编码，只需要1字节，但是使用VARCHAR(1)，需要两个字节，因为记录VARCHAR实际存储的长度需要1个字节</li><li>但如果采用的是变长字符集，CHAR也会有额外1字节来记录该列存储的值</li></ul></li></ul><h4 id="性能对比" tabindex="-1"><a class="header-anchor" href="#性能对比" aria-hidden="true">#</a> 性能对比</h4><blockquote><p>大部分情况最好使用VARCHAR</p></blockquote><h5 id="char-1" tabindex="-1"><a class="header-anchor" href="#char-1" aria-hidden="true">#</a> CHAR</h5><blockquote><p><strong>CHAR有什么缺点？</strong></p></blockquote><ul><li><strong>浪费存储空间</strong>：CHAR填充空格可能导致浪费存储空间，进而导致性能下降</li><li><strong>性能消耗</strong>：因为CHAR需要存储额外的空格，即需要从磁盘读写更多的数据、耗费更多的内存、查找数据时需要删除空格再返回也会耗费一些CPU性能</li></ul><blockquote><p><strong>CHAR有什么优点?</strong></p></blockquote><ul><li><strong>字段分配得到的字节数固定</strong>，后续对字段进行修改<strong>不会造成页分裂、页空隙等问题</strong></li><li>VARCHAR由于不会提前分配存储空间，后续<strong>频繁修改</strong>可能会出现页分裂，进而导致性能下降 <ul><li>页分裂： <ul><li>当进行修改时，导致该行记录大小变大，从而导致该页无法完整存下记录，因此需要申请新的一页，用来保存这个记录</li><li>同时需要维护索引数据的有序性，因此需要重新组织这些页面，以维护索引结构，会增加数据库的IO操作</li></ul></li></ul></li></ul><h5 id="varchar-1" tabindex="-1"><a class="header-anchor" href="#varchar-1" aria-hidden="true">#</a> VARCHAR</h5><blockquote><p><strong>更新行记录导致页不够存怎么办？</strong></p></blockquote><p>由于VARCHAR是可变长的，在UPDATE时可能使行变得比原来长。</p><p>如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，这种情况下，不同的存储引擎处理的方式不同。</p><ul><li>MyISAM会将行拆成不同的片段存储</li><li>InnoDB需要分裂页使行可以放进页内</li></ul><blockquote><p><strong>列长的定义：VARCHAR(5) VS VARCHAR(200)</strong></p></blockquote><p>VARCHAR(5)和VARCHAR(200)存储<code>‘hello’</code>的<strong>占用磁盘的存储空间</strong>是一样的，但使用更长的列会<strong>消耗更多的内存</strong>：</p><ul><li>MySQL通常会<strong>分配固定大小的内存块来保存内部值</strong></li><li>尤其是使用内存临时表进行排序或操作时，以及磁盘临时表进行排序 <ul><li>内存临时表很好理解，在内存临时表的VARCHAR列会分配固定长度</li><li>使用磁盘临时表排序，排序时先要从磁盘临时表读取数据，将数据加载到内存VARCHAR也是定长的</li></ul></li><li>也就是说，在使用内存临时表或磁盘临时表执行ORDER BY排序时，排序字段分配的列的长度是固定的，因此<strong>只能分配VARCAHR限定的最大长度</strong></li></ul><blockquote><p><strong>怎么确定变长字段应该分配多长的长度？</strong></p></blockquote><p>因为涉及文件排序或基于临时表排序，更长的列会消耗更多的内存，要评估实际使用的长度来设置字符长度，推荐使用冗余10%的长度。</p><ul><li>使用VARCAHR(10)更加节约内存空间，但是实际业务中字符长度一旦超过10就要更改表结构，因此在数据量特别大的时候，不易拓展</li><li>VARCAHR(100)无需更改表结构，业务拓展性好，但更耗费内存</li></ul><h3 id="innodb页结构" tabindex="-1"><a class="header-anchor" href="#innodb页结构" aria-hidden="true">#</a> InnoDB页结构</h3><ul><li>页是InnoDB管理存储空间的基本单位 <ul><li>当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存</li></ul></li><li>一页的大小一般是16KB <ul><li>一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中</li></ul></li><li>InnoDB 为了不同的目的而设计了许多种不同类型的页： <ul><li>存放表空间头部信息的页</li><li>存放 Insert Buffer信息的页</li><li>存放 INODE 信息的页</li><li>存放 undo 日志信息的页</li><li>存放行记录的页，官方称为INDEX页，也叫数据页</li></ul></li></ul><h4 id="数据页结构" tabindex="-1"><a class="header-anchor" href="#数据页结构" aria-hidden="true">#</a> 数据页结构</h4><h5 id="数据页整体结构" tabindex="-1"><a class="header-anchor" href="#数据页整体结构" aria-hidden="true">#</a> 数据页整体结构</h5><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223133111848.png" alt="image-20231223133111848" tabindex="0" loading="lazy"><figcaption>image-20231223133111848</figcaption></figure><h5 id="每个部分的作用" tabindex="-1"><a class="header-anchor" href="#每个部分的作用" aria-hidden="true">#</a> 每个部分的作用</h5><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间</th><th>说明</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38 字节</td><td>页的一些通用信息</td></tr><tr><td>Page Header</td><td>页面头部</td><td>56 字节</td><td>数据页专有的一些信息</td></tr><tr><td>Infimum + Supremum</td><td>最小记录 + 最大记录</td><td>26 字节</td><td>两个虚拟的行记录</td></tr><tr><td>User Records</td><td>用户记录</td><td>不确定</td><td>实际存储的行记录内容</td></tr><tr><td>Free Space</td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td>Page Diretory</td><td>页面目录</td><td>不确定</td><td>页中某些记录的相对位置</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8 字节</td><td>校验页是否完整</td></tr></tbody></table><h4 id="user-records" tabindex="-1"><a class="header-anchor" href="#user-records" aria-hidden="true">#</a> User Records</h4><blockquote><p>用户记录，用来存储插入的行记录内容</p></blockquote><h5 id="记录存储入页" tabindex="-1"><a class="header-anchor" href="#记录存储入页" aria-hidden="true">#</a> 记录存储入页</h5><blockquote><p><strong>插入表中的数据是如何进入页中的？</strong></p></blockquote><p>在页的7个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到User Records 部分。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223134705617.png" alt="image-20231223134705617" tabindex="0" loading="lazy"><figcaption>image-20231223134705617</figcaption></figure><ul><li>一开始生成页的时候，并没有User Records 这个部分</li></ul><ul><li>每插入一条记录，都会从Free Space 部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分</li><li>当Free Space 部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了</li><li>如果还有新的记录插入的话，就需要去申请新的页了</li></ul><h5 id="记录头信息详解" tabindex="-1"><a class="header-anchor" href="#记录头信息详解" aria-hidden="true">#</a> 记录头信息详解</h5><blockquote><p><strong>InnoDB是如何管理User Records中的数据的？</strong></p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> page_demo <span class="token punctuation">(</span>
	c1 <span class="token keyword">INT</span><span class="token punctuation">,</span>
    c2 <span class="token keyword">INT</span><span class="token punctuation">,</span>
    c3 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>c1<span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>ascii ROW_FORMAT<span class="token operator">=</span>Compact<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>将c1列定义为主键，InnoDB就不需要再定义row_id了，直接把c1列的值放到对应row_id的位置</li></ul><blockquote><p>示例表对应记录的行格式</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223134912504.png" alt="image-20231223134912504" tabindex="0" loading="lazy"><figcaption>image-20231223134912504</figcaption></figure><blockquote><p>记录头信息中各个属性的大体意思</p></blockquote><table><thead><tr><th>名称</th><th>大小(bit)</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树每层非叶子节点中最小记录会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型(0:普通，1:非叶子节点，2:最小记录，3:最大记录)</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><blockquote><p>page_demo表的行格式简化图</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223135816039.png" alt="image-20231223135816039" tabindex="0" loading="lazy"><figcaption>image-20231223135816039</figcaption></figure><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> page_demo
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">&#39;aaaa&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	   <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token string">&#39;bbbb&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	   <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">,</span> <span class="token string">&#39;cccc&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>插入数据后的User Records</strong></p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223140256565.png" alt="image-20231223140256565" tabindex="0" loading="lazy"><figcaption>image-20231223140256565</figcaption></figure><ul><li><p><code>delete_mask</code>：这个属性标记着当前记录是否被删除，占用1个二进制位</p><ul><li>值为0 的时候代表记录并没有被删除，为1 的时候代表记录被删除掉了。</li><li>这些<strong>被删除的记录之所以不立即从磁盘上移除</strong>，是<strong>因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗</strong></li><li>所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为所谓的<strong>可重用空间</strong>，</li><li>之后如果有<strong>新记录插入到表</strong>中的话，可能<strong>把这些被删除的记录占用的存储空间覆盖掉</strong></li></ul></li><li><p><code>min_rec_mask</code>：B+树的每层非叶子节点中的最小记录都会添加该标记</p><ul><li>插入的四条记录的min_rec_mask 值都是0 ，意味着它们都不是B+ 树的非叶子节点中的最小记录。</li></ul></li><li><p><code>n_owned</code>：表示当前记录拥有的记录数</p></li><li><p><code>heap_no</code>：这个属性表示当前记录在本页中的位置</p><ul><li>从图中可以看出来，我们插入的4条记录在本页中的位置分别是： 2 、3 、4 、5</li><li>InnoDB自动给每个页里边加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录。</li><li>这两个伪记录一个代表最小记录，一个代表最大记录，</li><li>对于一条完整的记录来说，比较记录的大小就是比较主键的大小。 <ul><li>比方说我们插入的4行记录的主键值分别是： 1 、2 、3 、4 ，这也就意味着这4条记录的大小从小到大依次递增。</li></ul></li></ul></li><li><p><code>record_type</code>：这个属性表示当前记录的类型，一共有4种类型的记录</p><ul><li>0 表示普通记录 <ul><li>手动插入的记录就是普通记录</li></ul></li><li>1 表示B+树非叶节点记录</li><li>2 表示最小记录</li><li>3 表示最大记录</li></ul></li><li><p><code>next_record</code>：从当前记录的真实数据 到下一条记录的真实数据的地址偏移量</p><ul><li>第一条记录的next_record值为32 ，意味着从第一条记录的真实数据的地址处向后找32 个字节便是下一条记录的真实数据</li><li><strong>下一条记录</strong>指得并不是按照我们插入顺序的下一条记录，而<strong>是按照主键值由小到大的顺序的下一条记录</strong></li><li><strong>Infimum记录</strong>（也就是最小记录） 的<strong>下一条记录就是本页中主键值最小的用户记录</strong></li><li>本页中<strong>主键值最大的用户记录的下一条记录就是 Supremum记录</strong>（也就是最大记录）</li></ul></li></ul><blockquote><p>将next_record存的偏移量用箭头替代，可以得到一张直观的页示意图</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223150408303.png" alt="image-20231223150408303" tabindex="0" loading="lazy"><figcaption>image-20231223150408303</figcaption></figure><ul><li>用户记录中的记录按照主键的从小到大形成了一个单链表</li></ul><blockquote><p>如果删除其中一条记录，会发生什么？</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223150921731.png" alt="image-20231223150921731" tabindex="0" loading="lazy"><figcaption>image-20231223150921731</figcaption></figure><ul><li>第2条记录并没有从存储空间中移除，而是把该条记录的 <code>delete_mask</code> 值设置为1</li><li>第2条记录的 <code>next_record</code> 值变为了0，意味着该记录没有下一条记录了</li><li>第1条记录的 <code>next_record</code> 指向了第3条记录</li><li>最大记录的 <code>n_owned</code> 值从5 变成了4</li></ul><blockquote><p>如果此时重新将第二条记录插回表中，会发生什么？</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223151159031.png" alt="image-20231223151159031" tabindex="0" loading="lazy"><figcaption>image-20231223151159031</figcaption></figure><ul><li>InnoDB 并没有因为新记录的插入而为它申请新的存储空间，而是直接复用了原来被删除记录的存储空间</li><li>当数据页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。</li></ul><blockquote><p>最小记录和最大记录</p></blockquote><p>不管我们向页中插入了多少自己的记录，InnoDB都规定他们定义的两条伪记录分别为最小记录与最大记录。</p><p>这两个记录相当于链表的虚拟头节点和虚拟尾节点</p><p>这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223145342693.png" alt="image-20231223145342693" tabindex="0" loading="lazy"><figcaption>image-20231223145342693</figcaption></figure><p>由于这两条记录不是我们自己定义的，所以并不存放在User Records中</p><p>它们被单独存放在一个称为 Infimum + Supremum 的部分</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223145445263.png" alt="image-20231223145445263" tabindex="0" loading="lazy"><figcaption>image-20231223145445263</figcaption></figure><ul><li>最小记录和最大记录的 <code>heap_no</code> 值分别是0 和1 ，也就是说它们的位置最靠前。</li></ul><h4 id="page-directory" tabindex="-1"><a class="header-anchor" href="#page-directory" aria-hidden="true">#</a> Page Directory</h4><blockquote><p>页目录，用来快速定位一条记录</p></blockquote><h5 id="查找用户记录" tabindex="-1"><a class="header-anchor" href="#查找用户记录" aria-hidden="true">#</a> 查找用户记录</h5><p>最笨的方法：遍历链表</p><ul><li>从Infimum记录（最小记录）开始，沿着next_record一直向后找</li><li>由于链表是有序的，找到下一个记录的主键比待查找的主键值大时就停止</li></ul><p>InnoDB采取的方法：通过页目录来定位记录</p><ul><li>InnoDB会为用户记录里面的记录维护一个页目录</li><li>要查找的时候直接通过页目录去查询</li></ul><h5 id="页目录的制作" tabindex="-1"><a class="header-anchor" href="#页目录的制作" aria-hidden="true">#</a> 页目录的制作</h5><blockquote><p><strong>页目录的制作过程</strong></p></blockquote><ol><li><strong>将所有正常的记录</strong>（包括最大最小记录，不包括标记为删除的记录）<strong>划分为几个组</strong></li><li>每个组的<strong>最后一条记录</strong>（也就是<strong>组内最大的记录</strong>）的<strong>头信息中</strong>的<code>n_owned</code>属性表示该<strong>记录拥有多少条记录</strong><ul><li>也就是该组内有多少条记录</li><li>相当于把最后一条记录当作该组组长，组长手握组内成员的总数</li></ul></li><li>将每个组<strong>最后一条记录的地址偏移量</strong>单独提取出来<strong>按照顺序存储到靠近页尾部的地方</strong><ul><li>这个地方就是页目录(Page Directory)</li><li>页面目录中的这些地址偏移量被称为槽，整个页目录就是由槽组成的</li><li>相当于把组长的位置集合起来，做成一本组长的花名册</li></ul></li></ol><blockquote><p><strong>分组的规则</strong></p></blockquote><p>InnoDB对每个分组中记录条数的规定</p><ul><li>对于最小记录所在的分组只能有 1 条记录</li><li>最大记录所在的分组拥有的记录条数只能在 1~8 条之间</li><li>剩下的分组中记录的条数范围只能在是 4~8 条之间</li></ul><p>分组规则</p><ul><li><strong>初始情况</strong>下一个数据页里<strong>只有最小记录和最大记录两条记录</strong>，它们<strong>分属于两个分组</strong>。</li><li>之后<strong>每插入一条记录</strong>，都会<strong>从页目录中找到主键值比本记录的主键值大并且差值最小的槽</strong>，然后<strong>把该槽对应的记录的<code>n_owned</code> 值加1</strong>，表示本组内又添加了一条记录，<strong>直到该组中的记录数等于8个</strong>。</li><li>在一个组中的记录数<strong>等于8个后再插入一条记录时</strong>，会<strong>将组中的记录拆分成两个组</strong>，<strong>一个组中4条记录，另一个5条记录</strong>。这个过程会在页目录中<strong>新增一个槽来记录这个新增分组中最大的那条记录的偏移量</strong>。</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223153226329.png" alt="image-20231223153226329" tabindex="0" loading="lazy"><figcaption>image-20231223153226329</figcaption></figure><h5 id="使用页目录查询记录" tabindex="-1"><a class="header-anchor" href="#使用页目录查询记录" aria-hidden="true">#</a> 使用页目录查询记录</h5><blockquote><p><strong>怎么从这个页目录中查找记录？</strong></p></blockquote><p>因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用二分法来进行快速查找</p><ol><li><strong>通过二分法确定该记录所在的槽</strong>，并找到该槽中主键值最小的那条记录。</li><li>通过记录的<code>next_record</code> 属性<strong>遍历该槽所在的组中的各个记录</strong>。</li></ol><blockquote><p>查找主键值为6的记录</p></blockquote><p>4个槽的编号分别是： 0 、1 、2 、3 、4 ，所以初始情况下最低的槽就是low=0 ，最高的槽就是high=4</p><ol><li><p>计算中间槽的位置： (0+4)/2=2 ，所以查看槽2 对应记录的主键值为8 ，又因为8 &gt; 6 ，所以设置high=2 ， low 保持不变。</p></li><li><p>重新计算中间槽的位置： (0+2)/2=1 ，所以查看槽1 对应的主键值为4 ，又因为4 &lt; 6 ，所以设置low=1 ， high 保持不变。</p></li><li><p>因为high - low 的值为1，所以确定主键值为5 的记录在槽2 对应的组中。</p></li></ol><ul><li>由于槽与槽之间是挨着的，很容易可以拿到槽1对应的下一个记录，也就是槽2的起始位置</li><li>遍历槽2，直到找到主键值为6的记录</li><li>由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。</li></ul><h4 id="page-header" tabindex="-1"><a class="header-anchor" href="#page-header" aria-hidden="true">#</a> Page Header</h4><blockquote><p>页头部，用来存储各种状态信息</p></blockquote><h5 id="页头部的内容" tabindex="-1"><a class="header-anchor" href="#页头部的内容" aria-hidden="true">#</a> 页头部的内容</h5><table><thead><tr><th>名称</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2字节</td><td>在页目录中的槽数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2字节</td><td>还未使用的空间最小地址，也急速hi说从该地址之后就是Free Space</td></tr><tr><td>PAGE_N_HEAP</td><td>2字节</td><td>本页中记录的总数（包括最大最小以及被标记删除）</td></tr><tr><td>PAGE_FREE</td><td>2字节</td><td>第一个标记为删除的记录地址</td></tr><tr><td>PAGE_GRABAGE</td><td>2字节</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2字节</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2字节</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2字节</td><td>一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2字节</td><td>本页中有用记录的数量（不包括最大最小以及被标记删除）</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8字节</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2字节</td><td>当前页在B+树种所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8字节</td><td>索引ID，表示该页属于哪个索引</td></tr><tr><td>PAGE_BIR_SEG_LEAF</td><td>10字节</td><td>B+树叶子字段的头部信息，尽在B+树的Root页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10字节</td><td>B+树非叶子字段的头部信息，尽在B+树的Root页定义</td></tr></tbody></table><ul><li><p>PAGE_DIRECTION：用来表示最后一条记录插入方向的状态</p><ul><li>假如新插入的一条记录的主键值比上一条记录的主键值大，这条记录的插入方向就是右边，反之则是左边</li></ul></li><li><p>PAGE_N_DIRECTION：一个方向连续插入的记录数量</p><ul><li>假设连续几次插入新记录的方向都是一致的， InnoDB 会把沿着同一个方向插入记录的条数记下来，</li><li>这个条数就用PAGE_N_DIRECTION 这个状态表示。</li><li>如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计</li></ul></li></ul><h4 id="file-header" tabindex="-1"><a class="header-anchor" href="#file-header" aria-hidden="true">#</a> File Header</h4><blockquote><p>文件头部，描述一些页的通用信息</p></blockquote><h5 id="文件头部的内容" tabindex="-1"><a class="header-anchor" href="#文件头部的内容" aria-hidden="true">#</a> 文件头部的内容</h5><p>File Header 针对各种类型的页都通用，也就是说不同类型的页都会以File Header 作为第一个组成部分</p><p>它描述了一些针对各种页都通用的一些信息。这个部分占用固定的38 个字节</p><table><thead><tr><th>名称</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>4字节</td><td>页的校验和（checksum值）</td></tr><tr><td>FIL_PAGE_OFFSET</td><td>4字节</td><td>页号</td></tr><tr><td>FIL_PAGE_PREV</td><td>4字节</td><td>上一个页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4字节</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN（Log Sequence Number）</td><td>8字节</td><td>页面最后被修改时对应的日志序列位置</td></tr><tr><td>FIL_PAGE_TYPE</td><td>4字节</td><td>该页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td>4字节</td><td>仅在系统表空间第一个页定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>4字节</td><td>页属于哪个表空间</td></tr></tbody></table><ul><li><p>FIL_PAGE_SPACE_OR_CHKSUM：当前页面的校验和（checksum）</p><ul><li>对于一个很长的字节串来说，会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为校验和。</li><li>这样在比较两个很长的字节串之前先比较这两个长字节串的校验和</li><li>如果校验和都不一样两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。</li></ul></li><li><p>FIL_PAGE_OFFSET：页号</p><ul><li>每一个页都有一个单独的页号，就跟你的身份证号码一样， InnoDB 通过页号来可以唯一定位一个页</li></ul></li><li><p>FIL_PAGE_TYPE：代表当前页的类型</p></li></ul><table><thead><tr><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_TYPE_ALLOCATED</td><td>0x0000</td><td>最新分配，还没使用</td></tr><tr><td>FIL_PAGE_UNDO_LOG</td><td>0x0002</td><td>Undo日志页</td></tr><tr><td>FIL_PAGE_INODE</td><td>0x0003</td><td>段信息节点</td></tr><tr><td>FIL_PAGE_IBUF_FREE_LIST</td><td>0x0004</td><td>Insert Buffer空闲列表</td></tr><tr><td>FIL_PAGE_IBUF_BITMAP</td><td>0x0005</td><td>Insert Buffer位图</td></tr><tr><td>FIL_PAGE_TYPE_SYS</td><td>0x0006</td><td>系统页</td></tr><tr><td>FIL_PAGE_TYPE_TRX_SYS</td><td>0x0007</td><td>事务系统数据</td></tr><tr><td>FIL_PAGE_TYPE_FSP_HDR</td><td>0x0008</td><td>表空间头部信息</td></tr><tr><td>FIL_PAGE_TYPE_XDES</td><td>0x0009</td><td>扩展描述页</td></tr><tr><td>FIL_PAGE_TYPE_BLOB</td><td>0x000A</td><td>BLOB页</td></tr><tr><td><strong>FIL_PAGE_INDEX</strong></td><td>0x45BF</td><td><strong>索引页</strong>，也就是我们所说的<strong>数据页</strong></td></tr></tbody></table><ul><li>FIL_PAGE_PREV 和 FIL_PAGE_NEXT：上一页页号和下一页页号 <ul><li>InnoDB 都是以页为单位存放数据的，有时候存放某种类型的数据占用的空间非常大（比方说一张表中可以有成千上万条记录）</li><li>InnoDB 可能不可以一次性为这么多数据分配一个非常大的存储空间</li><li>如果分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。</li><li>这样通过建立一个双向链表把许许多多的页都串联起来了，而无需这些页在物理上真正连着。</li><li>需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过我们本集中唠叨的数据页（也就是类型为FIL_PAGE_INDEX 的页）是有这两个属性的，所以<strong>所有的数据页其实是一个双链表</strong>，就像这样</li></ul></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223161057649.png" alt="image-20231223161057649" tabindex="0" loading="lazy"><figcaption>image-20231223161057649</figcaption></figure><h4 id="file-trailer" tabindex="-1"><a class="header-anchor" href="#file-trailer" aria-hidden="true">#</a> File Trailer</h4><blockquote><p>文件尾部：用于校验页是否完整</p></blockquote><p>File Trailer 与File Header 类似，都是所有类型的页通用的</p><h5 id="文件尾部的作用" tabindex="-1"><a class="header-anchor" href="#文件尾部的作用" aria-hidden="true">#</a> 文件尾部的作用</h5><p>InnoDB为了提高读写速度，以页为单位把数据加载到内存中处理</p><p>如果该页中的数据在内存中被修改，在修改后的某个时间需要把数据同步到磁盘中</p><p>但是在同步到一半时，如果出现MySQL宕机或者断电，这个页就无法被完整同步。</p><p>因此，为了检验一个页是否完整，在每个页的尾部添加File Trailer</p><h5 id="文件尾部的内容" tabindex="-1"><a class="header-anchor" href="#文件尾部的内容" aria-hidden="true">#</a> 文件尾部的内容</h5><p>File Trailer由8个字节组成：</p><ul><li>前4个字节代表页的校验和 <ul><li>File Trailer 文件尾记录的校验和，和File Header 文件头记录的校验和是相对应的，在同步之前就需要把校验和计算出来</li><li>因为File Header位于页的开头，因此其中的校验和会被先同步到磁盘，当页面完成同步，File Header和File Trailer记录的校验和是一致的，代表相同的页</li><li>如果页面同步中断，那么在 <strong>File Header 中的校验和就代表着已经修改过的页</strong>，而在 <strong>File Trialer 中的校验和代表着原先的页</strong>，二者不同则意味着同步中间出了错 <ul><li>从磁盘中取出一页，此时File Header和File Trailer记录的校验和是一致的，这个校验和代表修改前的页</li><li>在内存里面修改后，会重新计算校验和，此时内存中的页的File Header和File Trailer的校验和是一致的，这个校验和代表修改后的页</li><li>在刷盘的过程中，由于File Header位与头部，所以File Header中的校验和会被首先写入，此时磁盘里面的页的File Header已经被覆盖，记录了修改后的页的校验和</li><li>如果此时同步中断，磁盘中File Trialer 中的校验和还没来得及被覆盖，记录的就是修改前的页的校验和</li><li>此时磁盘中页的两个校验和就不相同了，代表刷盘出问题，同步出错</li></ul></li></ul></li><li>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）</li></ul><h2 id="mysql数据目录" tabindex="-1"><a class="header-anchor" href="#mysql数据目录" aria-hidden="true">#</a> MySQL数据目录</h2><blockquote><p>数据之家</p></blockquote><h3 id="数据库和文件系统的关系" tabindex="-1"><a class="header-anchor" href="#数据库和文件系统的关系" aria-hidden="true">#</a> 数据库和文件系统的关系</h3><p>存储引擎将表存储在文件系统上</p><ul><li>当我们想读取数据的时候，这些<strong>存储引擎会从文件系统中把数据读出来返回给我们</strong></li><li>当我们想写入数据的时候，这些<strong>存储引擎会把这些数据又写回文件系统</strong></li></ul><h3 id="mysql的数据目录" tabindex="-1"><a class="header-anchor" href="#mysql的数据目录" aria-hidden="true">#</a> MySQL的数据目录</h3><p>MySQL服务器程序在启动时会到文件系统的某个目录下加载一些文件</p><p>之后在运行过程中产生的数据也都会存储到这个目录下的某些文件中，这个目录就称为数据目录</p><blockquote><p>数据目录和安装目录一样吗？</p></blockquote><p>安装目录下的bin 目录里边存储了许多关于控制客户端程序和服务器程序的命令</p><ul><li>许多可执行文件，比如mysql ， mysqld ， mysqld_safe 等</li></ul><p>而数据目录是用来存储MySQL 在运行过程中产生的数据</p><blockquote><p>如何确定数据目录的位置？</p></blockquote><p>数据目录对应着一个系统变量<code>datadir</code> ，我们在使用客户端与服务器建立连接之后查看这个系统变量的值就可以</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">&#39;datadir&#39;</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">---------------+-----------------------+</span>
<span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span>					<span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------------+-----------------------+</span>
<span class="token operator">|</span> datadir 		<span class="token operator">|</span> <span class="token operator">/</span>usr<span class="token operator">/</span><span class="token keyword">local</span><span class="token operator">/</span>var<span class="token operator">/</span>mysql<span class="token operator">/</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------------+-----------------------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="数据目录的结构" tabindex="-1"><a class="header-anchor" href="#数据目录的结构" aria-hidden="true">#</a> 数据目录的结构</h3><h4 id="数据库在文件系统中的表示" tabindex="-1"><a class="header-anchor" href="#数据库在文件系统中的表示" aria-hidden="true">#</a> 数据库在文件系统中的表示</h4><p>每个数据库都对应数据目录下的一个子目录，或者说对应一个文件夹</p><p>每新建一个数据库， MySQL 会做两件事：</p><ol><li>在数据目录下创建一个和数据库名同名的子目录（或者说是文件夹）</li><li>在该与数据库名同名的子目录下创建一个名为<code>db.opt</code>的文件，这个文件中包含了该数据库的各种属性</li></ol><ul><li>例如：该数据库的字符集和比较规则</li></ul><h4 id="表在文件系统中的表示" tabindex="-1"><a class="header-anchor" href="#表在文件系统中的表示" aria-hidden="true">#</a> 表在文件系统中的表示</h4><p>数据其实都是以记录的形式插入到表中的，每个表的信息其实可以分为两种：</p><ul><li>表结构的定义 <ul><li>名称、多少列、每列的数据类型、约束条件、索引，字符集，比较规则 …</li><li>MyISAM和InnoDB都在数据目录对应的数据库子目录下创建一个专门用于描述表结构的文件：<code>表名.frm</code></li><li>该文件以二进制格式存储</li></ul></li><li>表中的数据 <ul><li>不同的存储引擎有不同的方式保存表中的数据</li></ul></li></ul><h5 id="innodb-5" tabindex="-1"><a class="header-anchor" href="#innodb-5" aria-hidden="true">#</a> InnoDB</h5><p>为了更好的管理页，InnoDB提出了表空间这一概念</p><p>表空间是一个抽象的概念，它可以对应文件系统上一个或多个真实文件（不同表空间对应的文件数量可能不同）</p><p>每一个表空间可以被划分为很多很多很多个页，表数据就存放在某个表空间下的某些页里</p><h6 id="系统表空间" tabindex="-1"><a class="header-anchor" href="#系统表空间" aria-hidden="true">#</a> 系统表空间</h6><p>系统表空间可以对应文件系统上一个或多个实际的文件</p><p>默认情况下， InnoDB 会在数据目录下创建一个名为<code>ibdata1</code> 、大小为12M 的文件，这个文件就是对应的系统表空间在文件系统上的表示</p><p>在一个MySQL服务器中，系统表空间只有一份</p><p>从MySQL5.5.7 ~ MySQL5.6.6之间的各个版本中，我们表中的数据都会被默认存储到系统表空间</p><h6 id="独立表空间" tabindex="-1"><a class="header-anchor" href="#独立表空间" aria-hidden="true">#</a> 独立表空间</h6><p>在MySQL5.6.6以及之后的版本中， InnoDB 并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个独立表空间</p><ul><li>也就是说我们创建了多少个表，就有多少个独立表空间</li></ul><p>使用独立表空间来存储表数据，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件</p><p>文件名和表名相同，只不过添加了一个.ibd 的扩展名而已，完整的文件名称：<code>表名.ibd</code></p><h6 id="其他类型的表空间" tabindex="-1"><a class="header-anchor" href="#其他类型的表空间" aria-hidden="true">#</a> 其他类型的表空间</h6><p>随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间</p><p>通用表空间（general tablespace）、undo表空间（undo tablespace）、临时表空间（temporary tablespace）……</p><h5 id="myisam-5" tabindex="-1"><a class="header-anchor" href="#myisam-5" aria-hidden="true">#</a> MyISAM</h5><p>MyISAM 并没有所谓的表空间，表数据都存放到对应的数据库子目录下</p><p>假如test 表使用MyISAM 存储引擎的话，那么在它所在数据库对应的xiaohaizi 目录下会为test 表创建这三个文件：</p><ul><li><code>test.frm</code><ul><li>表结构文件</li></ul></li><li><code>test.MYD</code><ul><li>数据文件</li></ul></li><li><code>test.MYI</code><ul><li>索引文件</li></ul></li></ul><h4 id="视图在文件系统中的表示" tabindex="-1"><a class="header-anchor" href="#视图在文件系统中的表示" aria-hidden="true">#</a> 视图在文件系统中的表示</h4><p>MySQL 中的<strong>视图其实是虚拟的表</strong>，也就是<strong>某个查询语句的一个别名</strong>而已</p><p>所以在<strong>存储视图的时候是不需要存储真实的数据的，只需要把它的结构存储起来就行了</strong></p><p>和表一样，描述视图结构的文件也会被存储到所属数据库对应的子目录下边，只会存储一个<code>视图名.frm</code> 的文件。</p><h4 id="其他文件" tabindex="-1"><a class="header-anchor" href="#其他文件" aria-hidden="true">#</a> 其他文件</h4><p>除了上边说的这些用户自己存储的数据以外， 数据目录下还包括为了更好运行程序的一些额外文件</p><p>主要包括这几种类型的文件：</p><ul><li><p>服务器进程文件：我们知道每运行一个MySQL 服务器程序，都意味着启动一个进程</p><ul><li>MySQL 服务器会把自己的进程ID写入到一个文件中。</li></ul></li><li><p>服务器日志文件：在服务器运行过程中，会产生各种各样的日志</p><ul><li>比如常规的查询日志、错误日志、二进制日志、redo日志等</li></ul></li><li><p>默认/自动生成的SSL和RSA证书和密钥文件。</p><ul><li>主要是为了客户端和服务器安全通信而创建的一些文件</li></ul></li></ul><h2 id="innodb的表空间" tabindex="-1"><a class="header-anchor" href="#innodb的表空间" aria-hidden="true">#</a> InnoDB的表空间</h2><blockquote><p>存放页面的大池子</p></blockquote><h3 id="独立表空间结构" tabindex="-1"><a class="header-anchor" href="#独立表空间结构" aria-hidden="true">#</a> 独立表空间结构</h3><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231224145915626.png" alt="image-20231224145915626" tabindex="0" loading="lazy"><figcaption>image-20231224145915626</figcaption></figure><h4 id="区-extend" tabindex="-1"><a class="header-anchor" href="#区-extend" aria-hidden="true">#</a> 区（extend）</h4><h5 id="区的定义" tabindex="-1"><a class="header-anchor" href="#区的定义" aria-hidden="true">#</a> 区的定义</h5><p>区的提出是为了更好的管理表空间中的页</p><p>对于16KB的页来说，<strong>连续的64个页就是一个区</strong>，也就是说<strong>一个区默认占用1MB空间大小</strong></p><p>不论是系统表空间还是独立表空间，都可以看成是由若干个区组成的，<strong>每256个区被划分成一组</strong>。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231224002133168.png" alt="image-20231224002133168" tabindex="0" loading="lazy"><figcaption>image-20231224002133168</figcaption></figure><h5 id="区中的页面" tabindex="-1"><a class="header-anchor" href="#区中的页面" aria-hidden="true">#</a> 区中的页面</h5><p><strong>每组的头几个页面都是一样的</strong></p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231224002420371.png" alt="image-20231224002420371" tabindex="0" loading="lazy"><figcaption>image-20231224002420371</figcaption></figure><p><strong>第一个组最开始的3个页面的类型是固定的</strong>，也就是说extent 0 这个区最开始的3个页面的类型是固定的，</p><ul><li><p>FSP_HDR 类型：这个类型的页面是用来登记<strong>整个表空间的一些整体属性以及本组所有的区</strong></p><ul><li><p>也就是extent 0 ~ extent 255 这256个区的属性。</p></li><li><p>整个表空间只有一个FSP_HDR 类型的页面。</p></li></ul></li><li><p>IBUF_BITMAP 类型：这个类型的页面是<strong>存储本组所有的区的所有页面关于INSERT BUFFER 的信息</strong></p></li><li><p>INODE 类型：这个类型的页面<strong>存储了许多称为INODE 的数据结构</strong></p></li></ul><p><strong>其余各组最开始的2个页面的类型是固定的</strong>，也就是说extent 256 、extent 512 这些区最开始的2个页面的类型是固定的</p><ul><li><p>XDES 类型：全称是extent descriptor ，用来<strong>登记本组256个区的属性</strong></p><ul><li>也就是说对于在extent 256区中的该类型页面存储的就是extent 256 ~ extent 511 这些区的属性</li><li>对于在extent 512 区中的该类型页面存储的就是extent 512 ~ extent 767 这些区的属性</li></ul><ul><li>FSP_HDR 类型的页面其实和XDES 类型的页面的作用类似，只不过<strong>FSP_HDR 类型的页面还会额外存储一些表空间的属性</strong></li></ul></li></ul><ul><li>IBUF_BITMAP 类型：这个类型的页面是存储本组所有的区的所有页面关于INSERT BUFFER 的信息</li></ul><h5 id="区的作用" tabindex="-1"><a class="header-anchor" href="#区的作用" aria-hidden="true">#</a> 区的作用</h5><blockquote><p>为什么要提出区？</p></blockquote><p>从理论上说，不引入区的概念只使用页的概念对存储引擎的运行并没啥影响。</p><p>如果没有区，<strong>页与页之间的物理位置可能离得非常远，扫描页的时候会产生大量的随机I/O</strong>，随机I/O的速度是非常慢的</p><p><strong>一个区就是在物理位置上连续的64个页</strong></p><p><strong>在表中数据量大的情况下</strong>，<strong>为某个索引分配空间</strong>的时候就不再按照页为单位分配了，而是<strong>按照区为单位分配</strong></p><p>甚至表中数据非常大的时候，可以一次性分配多个连续的区。</p><p><strong>每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了</strong>。</p><h5 id="区的分类" tabindex="-1"><a class="header-anchor" href="#区的分类" aria-hidden="true">#</a> 区的分类</h5><blockquote><p>存在问题</p></blockquote><p>默认情况下一个使用InnoDB 存储引擎的表只有一个聚簇索引，一个索引会生成2个段</p><p>段是以区为单位申请存储空间的，一个区默认占用1M存储空间</p><p>默认情况下一个只存了几条记录的小表也需要2M的存储空间么？以后每次添加一个索引都要多申请2M的存储空间么？</p><blockquote><p><strong>区的四种分类</strong></p></blockquote><table><thead><tr><th>状态名</th><th>含义</th></tr></thead><tbody><tr><td>FREE</td><td>空闲的区</td></tr><tr><td>FREE_FRAG</td><td>有剩余空间的碎片区</td></tr><tr><td>FULL_FRAG</td><td>没有剩余空间的碎片区</td></tr><tr><td>FSEG</td><td>附属于某个段的区</td></tr></tbody></table><ul><li>空闲的区：现在还没有用到这个区中的任何页面。</li><li>有剩余空间的碎片区：表示碎片区中还有可用的页面。</li><li>没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面。</li><li>附属于某个段的区 <ul><li>每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段</li><li>在这些段中的数据量很大时将使用区来作为基本的分配单位。</li></ul></li></ul><p>处于FREE 、FREE_FRAG 以及FULL_FRAG 这三种状态的区都是独立的，算是直属于表空间；而处于FSEG 状态的区是附属于某个段的</p><blockquote><p>加深理解</p></blockquote><p>如果把表空间比作是一个集团军，段就相当于师，区就相当于团。</p><p>一般的团都是隶属于某个师的，就像是处于<code>FSEG</code>的区全都隶属于某个段</p><p>而处于<code>FREE</code>、<code>FREE_FRAG</code>以及<code>FULL_FRAG</code>这三种状态的区却直接隶属于表空间，就像独立团直接听命于军部一样</p><h5 id="区的数据结构" tabindex="-1"><a class="header-anchor" href="#区的数据结构" aria-hidden="true">#</a> 区的数据结构</h5><p>为了方便管理这些区，设计InnoDB 的大叔设计了一个称为XDES Entry 的结构（全称就是Extent Descriptor Entry），每一个区都对应着一个XDES Entry 结构</p><p>这个结构记录了对应的区的一些属性</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231224151017136.png" alt="image-20231224151017136" tabindex="0" loading="lazy"><figcaption>image-20231224151017136</figcaption></figure><p>XDES Entry 是一个40个字节的结构，大致分为4个部分</p><ul><li><p>Segment ID （8字节）</p><ul><li>每一个段都有一个唯一的编号，用ID表示</li><li>此处的Segment ID 字段表示就是该区所在的段</li><li>前提是该区已经被分配给某个段了，不然的话该字段的值没啥意义。</li></ul></li><li><p><strong>List Node</strong> （12字节）</p><ul><li>这个部分可以将若干个XDES Entry 结构串联成一个链表</li><li>Pre Node Page Number 和Pre Node Offset 的组合就是指向前一个XDES Entry 的指针</li><li>Next Node Page Number 和Next Node Offset 的组合就是指向后一个XDES Entry 的指针。</li></ul></li><li><p><strong>State</strong> （4字节）</p><ul><li>这个字段表明区的状态。</li><li>可选的值就是我们前边说过的那4个，分别是： FREE 、FREE_FRAG 、FULL_FRAG 和FSEG 。</li></ul></li><li><p>Page State Bitmap （16字节）</p><ul><li>这个部分共占用16个字节，也就是128个比特位。</li><li>我们说一个区默认有64个页，这128个比特位被划分为64个部分，每个部分2个比特位，对应区中的一个页。</li><li>比如Page State Bitmap 部分的第1和第2个比特位对应着区中的第1个页面，第3和第4个比特位对应着区中的第2个页面，依此类推，Page State Bitmap 部分的第127和128个比特位对应着区中的第64个页面。</li><li>这两个比特位的第一个位表示对应的页是否是空闲的，第二个比特位还没有用。</li></ul></li></ul><blockquote><p><strong>如何向表中插入数据？</strong></p></blockquote><p>向表中插入数据本质上就是<strong>向表中各个索引的叶子节点段、非叶子节点段插入数据</strong></p><ul><li>当段中数据较少的时候，首先会查看表空间中是否有状态为FREE_FRAG的区，也就是找还有空闲空间的碎片区 <ul><li>找到了，那么从该区中去一些零碎的页把数据插进去</li><li>找不到，到表空间下申请一个状态为FREE的区，也就是空闲的区，把该区的状态变为FREE_FRAG，然后从新申请的区中取一些零碎的页把数据插进去</li><li>之后不同的段使用零碎页的时候都会从该区里面取，直到该区中没有空闲空间位置，然后该区的状态就变成了FULL_FRAG</li></ul></li><li>当段中数据占满32个零散的页之后，就直接申请完整的区来插入数据了</li></ul><blockquote><p><strong>如何知道表空间里面各个区的状态是什么？</strong></p></blockquote><p>利用XDES Entry中的List Node将各种区对应的XDES Entry连接起来</p><ul><li>FREE 链表：把状态为FREE 的区对应的XDES Entry 结构通过List Node 来连接成一个链表</li><li>FREE_FRAG 链表：把状态为FREE_FRAG 的区对应的XDES Entry 结构通过List Node 来连接成一个链表</li><li>FULL_FRAG 链表：把状态为FULL_FRAG 的区对应的XDES Entry 结构通过List Node 来连接成一个链表</li></ul><p>这样每当我们想找一个FREE_FRAG 状态的区时，就直接把FREE_FRAG 链表的头节点拿出来，从这个节点中取一些零碎的页来插入数据</p><p>当这个节点对应的区用完时，就修改一下这个节点的State 字段的值，然后从FREE_FRAG 链表中移到FULL_FRAG 链表中。</p><p>同理，如果FREE_FRAG 链表中一个节点都没有，那么就直接从FREE 链表中取一个节点移动到FREE_FRAG 链表的状态，并修改该节点的STATE 字段值为FREE_FRAG ，然后从这个节点对应的区中获取零碎的页就好了。</p><blockquote><p><strong>如何知道段中各个区的状态是什么？</strong></p></blockquote><p>在同一个段中，也需要维护三条链表</p><ul><li>FREE 链表：同一个段中，所有页面都是空闲的区对应的XDES Entry 结构会被加入到这个链表。</li><li>NOT_FULL 链表：同一个段中，仍有空闲空间的区对应的XDES Entry 结构会被加入到这个链表。</li><li>FULL 链表：同一个段中，已经没有空闲空间的区对应的XDES Entry 结构会被加入到这个链表。</li></ul><blockquote><p><strong>究竟要维护多少链表？</strong></p></blockquote><p>每一个索引都对应两个段，每个段都会维护上述的3个链表</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t <span class="token punctuation">(</span>
    c1 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
    c2 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    c3 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">KEY</span> idx_c2 <span class="token punctuation">(</span>c2<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个表t 共有两个索引，一个聚簇索引，一个二级索引<code>idx_c2</code> ，所以这个表共有4个段，每个段都会维护上述3个链表，总共是12个链表。加上直属于表空间的3个链表，整个独立表空间共需要维护15个链表</p><p>段在<strong>数据量比较大时插入数据的话，会先获取NOT_FULL 链表的头节点，直接把数据插入这个头节点对应的区中即可</strong>，如果该区的空间已经被用完，就把该节点移到FULL 链表中。</p><h5 id="链表基节点" tabindex="-1"><a class="header-anchor" href="#链表基节点" aria-hidden="true">#</a> 链表基节点</h5><blockquote><p>那么多链表，要怎么找到它们呢？</p></blockquote><p>InnoDB有一个链表基节点(List Base Node)的结构，用于存储链表的头节点和为节点的指针，以及这个链表包含了多少节点的信息</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231224193015830.png" alt="image-20231224193015830" tabindex="0" loading="lazy"><figcaption>image-20231224193015830</figcaption></figure><ul><li>List Length：表明该链表一共有多少个节点</li><li>First Node Page Number 和 First Node Offset 表明该链表的头节点在表空间中的位置</li><li>Last Node Page Number 和 Last Node Offset 表明该链表的尾节点在表空间中的位置</li></ul><p>一般我们把某个链表对应的List Base Node 结构放置在表空间中固定的位置，这样就可以随时定位到某个链表了</p><h5 id="链表小结" tabindex="-1"><a class="header-anchor" href="#链表小结" aria-hidden="true">#</a> 链表小结</h5><p>表空间是由若干个区组成的</p><p>每个区都对应一个XDES Entry 的结构</p><p>直属于表空间的区对应的XDES Entry 结构可以分成FREE 、FREE_FRAG 和FULL_FRAG 这3个链表</p><p>每个段可以附属若干个区</p><p>每个段中的区对应的XDES Entry 结构可以分成FREE 、NOT_FULL 和FULL 这3个链表。</p><p>每个链表都对应一个List Base Node 的结构，</p><p>这个结构里记录了链表的头、尾节点的位置以及该链表中包含的节点数。</p><p>链表帮助InnoDB更加高效的管理这些区</p><h4 id="段-segment" tabindex="-1"><a class="header-anchor" href="#段-segment" aria-hidden="true">#</a> 段（segment）</h4><h5 id="段的简介" tabindex="-1"><a class="header-anchor" href="#段的简介" aria-hidden="true">#</a> 段的简介</h5><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p><ul><li><strong>索引段</strong>：存放 B + 树的非叶子节点的区的集合；</li><li><strong>数据段</strong>：存放 B + 树的叶子节点的区的集合；</li><li><strong>回滚段</strong>：存放的是回滚数据的区的集合 <ul><li>MVCC 利用了回滚段实现了多版本查询数据。</li></ul></li></ul><p>段其实不对应表空间中某个连续的物理区域，它是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成</p><blockquote><p>索引段和数据段是什么？</p></blockquote><p>InnoDB对B+ 树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。</p><p>存放叶子节点的区的集合就算是一个段（ segment ），存放非叶子节点的区的集合也算是一个段。</p><p><strong>一个索引会生成2个段，一个叶子节点段（数据段），一个非叶子节点段（索引段）</strong>。</p><h5 id="段的结构" tabindex="-1"><a class="header-anchor" href="#段的结构" aria-hidden="true">#</a> 段的结构</h5><p>每个区都有对应的XDES Entry来记录这个区中的属性，每个段也有一个INODE Entry来记录段中的属性</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231224210757415.png" alt="image-20231224210757415" tabindex="0" loading="lazy"><figcaption>image-20231224210757415</figcaption></figure><ul><li>Segment ID：指这个INODE Entry 结构对应的段的编号（ID）</li><li>NOT_FULL_N_USED：指的是在NOT_FULL 链表中已经使用了多少个页面 <ul><li>下次从NOT_FULL 链表分配空闲页面时可以直接根据这个字段的值定位到。而不用从链表中的第一个页面开始遍历着寻找空闲页面。</li></ul></li><li>3个List Base Node：分别为段的FREE 链表、NOT_FULL 链表、FULL 链表 <ul><li>定义了List Base Node ，这样我们想查找某个段的某个链表的头节点和尾节点的时候，就可以直接到这个部分找到对应链表的List Base Node 。</li></ul></li><li>Magic Number ：用来标记这个INODE Entry 是否已经被初始化了（初始化的意思就是把各个字段的值都填进去了） <ul><li>如果这个数字是值的97937874 ，表明该INODE Entry 已经初始化</li><li>否则没有被初始化。（不用纠结这个值有啥特殊含义，人家规定的）。</li></ul></li><li>Fragment Array Entry：我们前边强调过无数次段是一些零散页面和一些完整的区的集合，每个Fragment Array Entry 结构都对应着一个零散的页面 <ul><li>这个结构一共4个字节，表示一个零散页面的页号。</li></ul></li></ul><h2 id="buffer-pool" tabindex="-1"><a class="header-anchor" href="#buffer-pool" aria-hidden="true">#</a> Buffer Pool</h2><h3 id="buffer-pool基础" tabindex="-1"><a class="header-anchor" href="#buffer-pool基础" aria-hidden="true">#</a> Buffer Pool基础</h3><blockquote><p><strong>为什么要有Buffer Pool</strong></p></blockquote><p>MySQL 的数据是存储在磁盘里的，每次都从磁盘里面读取数据，这样性能是极差的</p><p>为此，Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，来提高数据库的读写性能。</p><p>InnoDB 存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中</p><p>也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中，将整个页加载到内存中后就可以进行读写访问了</p><p>在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘IO 的开销了</p><blockquote><p><strong>缓冲池的位置</strong></p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231224220526185.png" alt="image-20231224220526185" tabindex="0" loading="lazy"><figcaption>image-20231224220526185</figcaption></figure><ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li><li>当<strong>修改数据时</strong>，首先是<strong>修改 Buffer Pool 中数据所在的页</strong>，然后<strong>将其页设置为脏页</strong>，最后<strong>由后台线程将脏页写入到磁盘</strong></li></ul><blockquote><p><strong>缓冲池的大小</strong></p></blockquote><p>Buffer Pool 是<strong>在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间</strong>，默认配置下 Buffer Pool 只有 <code>128MB</code> 。</p><p>可以通过调整 <code>innodb_buffer_pool_size</code> 参数来设置 Buffer Pool 的大小，<strong>一般建议设置成可用物理内存的 60%~80%</strong>。</p><h3 id="buffer-pool缓存的内容" tabindex="-1"><a class="header-anchor" href="#buffer-pool缓存的内容" aria-hidden="true">#</a> Buffer Pool缓存的内容</h3><blockquote><p><strong>Buffer Pool是拿什么来装数据的</strong></p></blockquote><p>在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间</strong></p><p>然后<strong>按照默认的<code>16KB</code>的大小划分出一个个的页</strong>， Buffer Pool 中的页就叫做<strong>缓存页</strong>。</p><p>此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中</p><ul><li>MySQL 刚启动的时候，你会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小</li><li>这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，接着将虚拟地址和物理地址建立映射关系。</li></ul><blockquote><p><strong>Buffer Pool里面都装了什么页</strong></p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231224221110719.png" alt="image-20231224221110719" tabindex="0" loading="lazy"><figcaption>image-20231224221110719</figcaption></figure><blockquote><p><strong>Buffer Pool如何管理这些缓存页</strong>？</p></blockquote><p>为了更好的管理这些在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个<strong>控制块</strong></p><p>控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231224223640674.png" alt="image-20231224223640674" tabindex="0" loading="lazy"><figcaption>image-20231224223640674</figcaption></figure><ul><li>控制块和缓存页是一一对应的，它们都被存放到 Buffer Pool 中 <ul><li>控制块被存放到 Buffer Pool 前边</li><li>缓存页被存放到 Buffer Pool 后边</li></ul></li><li>每一个控制块对应一个缓存页，那两边分配完空间，剩下的那一小部分就是碎片了</li></ul><blockquote><p><strong>如何从Buffer Pool里面找到某页？</strong></p></blockquote><p>InnoDB根据表空间号 + 页号来定位一个页，相当于表空间号 + 页号就是一个key，缓存页就是对应的value</p><p>用表空间号 + 页号作为key，缓存页作为value，组成一个哈希表</p><p>在需要访问某个页的数据时，先从哈希表中根据表空间号 + 页号看看有没有对应的缓存页</p><ul><li>如果有，直接使用该缓存页就好</li><li>如果没有，那就从free链表中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置</li></ul><h3 id="buffer-pool的管理" tabindex="-1"><a class="header-anchor" href="#buffer-pool的管理" aria-hidden="true">#</a> Buffer Pool的管理</h3><blockquote><p>Buffer Pool有3种页和链表来管理数据</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231225000120815.png" alt="image-20231225000120815" tabindex="0" loading="lazy"><figcaption>image-20231225000120815</figcaption></figure><ul><li>Free Page（空闲页），表示此页未被使用，位于 Free 链表；</li><li>Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于LRU 链表。</li><li>Dirty Page（脏页），表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。 <ul><li>当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。</li><li>脏页同时存在于 LRU 链表和 Flush 链表。</li></ul></li></ul><h4 id="空闲页的管理" tabindex="-1"><a class="header-anchor" href="#空闲页的管理" aria-hidden="true">#</a> 空闲页的管理</h4><p>最初启动MySQL 服务器的时候，需要完成对Buffer Pool 的初始化过程，就是先向操作系统申请BufferPool 的内存空间，然后把它划分成若干对控制块和缓存页。</p><p>但是此时并没有真实的磁盘页被缓存到BufferPool 中（因为还没有用到），之后随着程序的运行，会不断的有磁盘上的页被缓存到Buffer Pool 中。</p><blockquote><p>如何区分这些页哪些是空闲的，哪些已经被使用了</p></blockquote><p>把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中，这个链表也可以被称作free链表（或者说空闲链表）。</p><p>刚刚完成初始化的Buffer Pool 中所有的缓存页都是空闲的，所以每一个缓存页对应的控制块都会被加入到free链表中</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231224231458102.png" alt="image-20231224231458102" tabindex="0" loading="lazy"><figcaption>image-20231224231458102</figcaption></figure><ul><li>FREE链表有一个基节点，基节点中包含了链表的头尾节点地址，以及当前链表中节点的数量等信息</li><li>链表的基节点占用的内存空间并不包含在为Buffer Pool 申请的一大片连续内存空间之内，而是单独申请的一块内存空间</li></ul><blockquote><p>有了FREE链表之后，页是如何从磁盘中加载到Buffer Pool的？</p></blockquote><ol><li>每当需要从磁盘中加载一个页到Buffer Pool中时，就从free链表中取一个空闲的缓存页来存</li><li>把该缓存页对应的控制块的信息填上（就是该页所在的表空间、页号之类的信息）</li><li>然后把该缓存页对应的free链表节点从链表中移除，表示该缓存页已经被使用了</li></ol><h4 id="脏页的管理" tabindex="-1"><a class="header-anchor" href="#脏页的管理" aria-hidden="true">#</a> 脏页的管理</h4><p>如果修改了Buffer Pool 中某个缓存页的数据，那它就和磁盘上的页不一致了，这样的缓存页也被称为脏页（ dirty page ）</p><p>InnoDB会创建一个<strong>存储脏页的链表</strong>，凡是修改过过的缓存页，对应的控制块都会作为一个节点加入到一个链表中</p><p>因为这个链表节点对应的缓存页都是需要被刷新到磁盘上的，所以也叫<strong>flush链表</strong></p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231224232354468.png" alt="image-20231224232354468" tabindex="0" loading="lazy"><figcaption>image-20231224232354468</figcaption></figure><h4 id="内存淘汰" tabindex="-1"><a class="header-anchor" href="#内存淘汰" aria-hidden="true">#</a> 内存淘汰</h4><p>Buffer Pool 对应的内存大小毕竟是有限的，如果需要缓存的页占用的内存大小超过了Buffer Pool 大小，也就是free链表中已经没有多余的空闲缓存页了</p><p>解决方案就是将某些旧的缓存页从Buffer Pool 中移除，然后再把新的页放进来</p><blockquote><p>要移除哪些页呢？</p></blockquote><p>使用LRU算法，<strong>淘汰掉最近最少使用的页</strong></p><blockquote><p><strong>如何移除这些页？</strong></p></blockquote><h5 id="简单的lru链表" tabindex="-1"><a class="header-anchor" href="#简单的lru链表" aria-hidden="true">#</a> 简单的LRU链表</h5><p>构建一个链表，这个链表是为了按照LRU原则去淘汰缓存页的，所以这个链表可以被称为LRU链表</p><p>当我们需要访问某个页时，可以这样处理LRU链表：</p><ul><li>当访问的页在 Buffer Pool 里，就直接把该页对应的 LRU 链表节点移动到链表的头部。</li><li>当访问的页不在 Buffer Pool 里，除了要把页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的节点。</li></ul><p>只要我们使用到某个缓存页，就把该缓存页调整到LRU链表的头部，这样LRU链表尾部就是最近最少使用的缓存页</p><p>当Buffer Pool 中的空闲缓存页使用完时，到LRU链表的尾部找些缓存页淘汰就行了</p><h5 id="划分区域的lru链表" tabindex="-1"><a class="header-anchor" href="#划分区域的lru链表" aria-hidden="true">#</a> 划分区域的LRU链表</h5><blockquote><p><strong>简单的LRU链表有什么问题？</strong></p></blockquote><p><strong>预读失效</strong></p><p>InnoDB 提供预读（read ahead ）</p><blockquote><p>所谓预读，就是InnoDB 认为执行当前的请求可能之后会读取某些页面，就预先把它们加载到Buffer Pool 中。</p></blockquote><p>根据触发方式的不同， 预读又可以细分为两种</p><ul><li><u>线性预读</u><ul><li>InnoDB 提供了一个系统变量<code>innodb_read_ahead_threshold</code> ，如果顺序访问了某个区（ extent ）的页面超过这个系统变量的值，就会触发一次异步读取下一个区中全部的页面到Buffer Pool 的请求</li><li>异步读取意味着从磁盘中加载这些被预读的页面并不会影响到当前工作线程的正常 执行。</li><li>这个<code>innodb_read_ahead_threshold</code> 系统变量的值默认是56 <ul><li>我们可以在服务器启动时通过启动参数或者服务器运行过程中直接调整该系统变量的值，它是一个全局变量，需要使用SETGLOBAL 命令来修改</li></ul></li></ul></li><li><u>随机预读</u><ul><li>如果Buffer Pool 中已经缓存了某个区的13个连续的页面，不论这些页面是不是顺序读取的，都会触发一次异步读取本区中所有其的页面到Buffer Pool 的请求。</li><li>这13个连续的页面得是非常热的页面，也就是LRU链表中young区域的前1/4</li><li>InnoDB 同时提供了<code>innodb_random_read_ahead</code> 系统变量</li><li>它的默认值为OFF ，InnoDB 并不会默认开启随机预读的功能 <ul><li>如果我们想开启该功能，可以通过修改启动参数或者直接使用SET GLOBAL 命令把该变量的值设置为ON 。</li></ul></li></ul></li></ul><p>如果预读到Buffer Pool 中的页成功的被使用到，那就可以极大的提高语句执行的效率</p><p><strong>如果用不到，这些预读的页都会放到LRU 链表的头部</strong>，但是如果此时Buffer Pool 的容量不太大而且很多预读的页面都没有用到的话，这就会导致<strong>处在LRU链表尾部的一些缓存页会很快的被淘汰掉</strong>，也就是所谓的劣币驱逐良币，会<strong>大大降低缓存命中率</strong>。</p><p><strong>Buffer Pool 污染</strong></p><p>当某一个 SQL 语句扫描了大量的数据时，在 Buffer Pool 空间比较有限的情况下，可能会将 Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</p><p>等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 Buffer Pool 污染。</p><p>Buffer Pool 污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成 Buffer Pool 污染。</p><blockquote><p><strong>问题总结</strong></p></blockquote><ul><li><strong>加载到Buffer Pool 中的页不一定被用到。</strong></li><li><strong>如果非常多的使用频率偏低的页被同时加载到Buffer Pool 时，可能会把那些使用频率非常高的页从Buffer Pool 中淘汰掉。</strong></li></ul><blockquote><p><strong>解决方案</strong></p></blockquote><p>因为有这两种情况的存在，所以InnoDB 把这个LRU链表按照一定比例分成两截</p><ul><li>一部分存储使用频率非常高的缓存页，所以这一部分链表也叫做<strong>热数据</strong>，或者称<strong>young区</strong>域</li><li>另一部分存储使用频率不是很高的缓存页，所以这一部分链表也叫做<strong>冷数据</strong>，或者称<strong>old区</strong>域</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231224233613409.png" alt="image-20231224233613409" tabindex="0" loading="lazy"><figcaption>image-20231224233613409</figcaption></figure><p>InnoDB是按照某个比例将LRU链表分成两半的，不是某些节点固定是young区域的，某些节点固定是old区域的</p><p>随着程序的运行，某个节点所属的区域也可能发生变化</p><p>默认情况下， old 区域在LRU链表中所占的比例是37% ，也就是old区域和young区域的比例是3 : 5</p><blockquote><p><strong>划分区域之后是如何解决这两个问题的？</strong></p></blockquote><ol><li><p><strong>解决预读的问题</strong></p><ul><li><p>InnoDB规定，当磁盘上的某个页面在<strong>初次加载</strong>到Buffer Pool中的某个缓存页时，该缓存页对应的<strong>控制块会被放到old区域的头部</strong></p></li><li><p>这样预读到Buffer Pool 却不进行后续访问的页面就会被逐渐从old 区域逐出，不会影响young 区域中被使用比较频繁的缓存页</p></li></ul></li><li><p><strong>解决全表扫描的问题</strong></p><ul><li><p>InnoDB规定，在对某个处在old 区域的缓存页进行<strong>第一次访问时</strong>就在它对应的控制块中<strong>记录下来这个访问时间</strong>，如果<strong>后续的访问时间与第一次访问的时间在某个时间间隔内</strong>，那么<strong>该页面就不会被从old区域移动到young区域的头部</strong>，否则将它移动到young区域的头部</p></li><li><p>这个时间默认是1s，也就是说，对于从磁盘上被加载到LRU 链表的old 区域的某个页来说，如果第一次和最后一次访问该页面的时间间隔小于1s （在一次全表扫描的过程中，多次访问一个页面中的时间不会超过1s ），那么该页不会被加入到young 区域</p></li></ul></li></ol><h5 id="优化lru链表的young区域" tabindex="-1"><a class="header-anchor" href="#优化lru链表的young区域" aria-hidden="true">#</a> 优化LRU链表的young区域</h5><blockquote><p><strong>存在问题</strong></p></blockquote><p>对于young 区域的缓存页来说，我们每次访问一个缓存页就要把它移动到LRU链表的头部，这样开销太大了</p><p>毕竟在young 区域的缓存页都是热点数据，也就是可能被经常访问的，这样频繁的对LRU链表进行节点移动操作不太好</p><blockquote><p><strong>解决方案</strong></p></blockquote><p>只有被访问的缓存页位于young 区域的1/4 的后边，才会被移动到LRU链表头部，这样就可以降低调整LRU链表的频率，从而提升性能</p><p>也就是说<strong>如果某个缓存页对应的节点在young 区域的1/4 中，再次访问该缓存页时也不会将其移动到LRU 链表头部</strong></p><h4 id="脏页刷盘" tabindex="-1"><a class="header-anchor" href="#脏页刷盘" aria-hidden="true">#</a> 脏页刷盘</h4><p>后台有专门的线程每隔一段时间负责把脏页刷新到磁盘，这样可以不影响用户线程处理正常的请求</p><p>主要有两种刷盘的策略</p><ul><li><strong>从LRU链表的冷数据中刷新一部分页面到磁盘。</strong><ul><li>后台线程会<strong>定时从LRU链表尾部开始扫描一些页面</strong>，扫描的页面数量可以通过系统变量<code>innodb_lru_scan_depth</code> 来指定，如果<strong>从里边发现脏页，会把它们刷新到磁盘</strong></li><li>这种从LRU链表中刷新页面的方式被称之为BUF_FLUSH_LRU 。</li></ul></li><li><strong>从flush链表中刷新一部分页面到磁盘。</strong><ul><li>后台线程也会<strong>定时从flush链表中刷新一部分页面到磁盘</strong>，刷新的速率取决于当时系统是不是很繁忙</li><li>这种从flush链表中刷新页面的方式被称之为BUF_FLUSH_LIST 。</li></ul></li></ul><blockquote><p>刷新脏页的速度跟不上加载数据的速度怎么办？</p></blockquote><p>有时候后台线程刷新脏页的进度比较慢，导致用户线程在准备加载一个磁盘页到Buffer Pool时<strong>没有可用的缓存页</strong></p><p>这时会看LRU链表尾部有<strong>没有可以直接释放掉的未修改页面</strong></p><ul><li>如果没有的话会<strong>不得不将LRU链表尾部的一个脏页同步刷新到磁盘</strong></li><li>和磁盘交互是很慢的，这会降低处理用户请求的速度</li></ul><p>这种直接刷新单个页面到磁盘中的刷新方式被称之为BUF_FLUSH_SINGLE_PAGE</p><h2 id="change-buffer" tabindex="-1"><a class="header-anchor" href="#change-buffer" aria-hidden="true">#</a> Change Buffer</h2><h3 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h3><blockquote><p>change buffer有什么用？</p></blockquote><p>更新一个数据时，如果数据页还在Buffer Pool中，就会直接更新缓存页。</p><p>当要更新的数据页在Buffer Pool中不存在，InnoDB会将这些更新操作缓存在Change Buffer中，在有更新操作的时候，就不用从磁盘读取数据页：</p><ul><li>减少读磁盘，提高写命令的执行效率</li><li>数据页读入磁盘也会占用Buffer Pool的空间，因此这种方式还可以避免因写操作而缓存了不会被访问的缓存页，避免占用内存，提高内存利用率</li></ul><blockquote><p>change buffer占多大空间？</p></blockquote><p>Change Buffer使用的是Buffer Pool里的内存</p><ul><li>可以通过<code>innodb_change_buffer_max_size</code>设置Change Buffer的大小</li><li>参数值为50则表示Change Buffer最多只能占用Buffer Pool的50%</li></ul><h3 id="工作机制" tabindex="-1"><a class="header-anchor" href="#工作机制" aria-hidden="true">#</a> 工作机制</h3><ul><li>要修改的数据页不存在，就先将写命令写入Change Buffer</li><li>在下一次查询需要访问这个数据页时，将数据页读入内存，然后执行Change Buffer 中与这个页有关的操作</li><li>Change Buffer 中的数据是可持久化的，Change Buffer 中的数据也会被写入磁盘</li><li>将Change Buffer 中的写操作，作用于原数据页，得到的最新结果的过程就是merge <ul><li>当Change Buffer 中有操作到的数据页被访问会触发merge</li><li>系统后台线程会定期merge</li><li>数据库正常关闭会执行merge</li></ul></li></ul><h3 id="使用时机" tabindex="-1"><a class="header-anchor" href="#使用时机" aria-hidden="true">#</a> 使用时机</h3><ul><li>INSERT：如果是插入数据，只有当<strong>表没有设置主键和唯一约束</strong>，才会使用Change Buffer，否则<strong>插入的时候都要检查数据是否存在重复</strong></li><li>UPDATE：是否使用Change Buffer，取决于<strong>操作的字段是否存在唯一约束</strong>，比如主键和UNIQUE列</li></ul><blockquote><p>为什么涉及聚簇索引和唯一索引的操作就不能用change buffer</p></blockquote><ul><li>操作聚簇索引和唯一索引的时候需要先判断这个操作是否违反唯一性约束</li><li>因此需要先将数据读取到内存，扫描判断插入数据是否会违反唯一性</li><li>因为在唯一性判断的时候，数据页已经被加载到内存，因此数据的修改操作可以直接在内存中进行</li></ul><p>因此唯一索引和聚簇索引的更行不能使用Change Buffer，只有<strong>普通索引</strong>可以使用</p><h3 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h3><blockquote><p>并不是普通索引所有的使用场景，使用Change Buffer都可以加速</p></blockquote><p>merge是真正进行数据更新的时刻，而Change Buffer 的作用就是把更新操作先缓存下来，等到要更新的时候，一次性写入。</p><p>也就是说，Change Buffer 里攒的写命令越多，到时候真正merge的时候，越划算。</p><h4 id="写多读少的场景" tabindex="-1"><a class="header-anchor" href="#写多读少的场景" aria-hidden="true">#</a> 写多读少的场景</h4><blockquote><p>适用的场景</p></blockquote><p>对于写多读少的业务，业务执行写操作后，操作后的数据马上被访问的概率比较小，那么这些命令在Change Buffer 中停留的时间就更长，写入时，写入后，不会立马有磁盘IO，性能好</p><ul><li>比如账单、日志类的系统</li></ul><h4 id="写入后立马会查询" tabindex="-1"><a class="header-anchor" href="#写入后立马会查询" aria-hidden="true">#</a> 写入后立马会查询</h4><blockquote><p>不适用的场景</p></blockquote><p>如果业务更新模式是写完之后马上就会被查询，那么即时数据页不在内存时，先将数据写入Change Buffer ，但写入之后，因为查询操作又立马要把这个页面加载入内存，立马触发merge操作。</p><p>这样随机IO的次数不会减少，反而增加了Change Buffer 的维护代价，因此这种业务模式下，Change Buffer 起了<strong>副作用</strong>：</p><ul><li>先写到缓冲区后，立即加载数据到内存触发merge修改数据</li><li>和在写命令到来时，直接将数据加载到内存修改</li><li>在这种业务模式下，上面两种更新数据的方式性能差不多，但是使用了Change Buffer就多了维护代价</li><li>因此在这种业务模式下，建议关闭Change Buffer</li></ul><h3 id="跟redo-log的关联" tabindex="-1"><a class="header-anchor" href="#跟redo-log的关联" aria-hidden="true">#</a> 跟redo-log的关联</h3><h4 id="更新语句" tabindex="-1"><a class="header-anchor" href="#更新语句" aria-hidden="true">#</a> 更新语句</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t<span class="token punctuation">(</span>id<span class="token punctuation">,</span> k<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span>id1<span class="token punctuation">,</span> k1<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>id2<span class="token punctuation">,</span> k2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>假设当前 k 索引树的状态，查找到位置后，k1 所在的数据页在内存 (buffer pool) 中，k2 所在的数据页不在内存中</p><blockquote><p>查找位置的时候不就已经把数据页读到buffer pool了吗</p></blockquote><ul><li>这里和使用二级索引进行回表的开销是一个道理。比如k1所在的页在k2后面被访问，因为访问的数据很多，k2所在的数据页可能会被挤到LRU链表尾部，所以有可能会被淘汰掉，k2所在的数据页就不会存在于内存中了</li><li>二级索引回表也是，即使之前已经扫描过聚簇索引，但是有可能因为扫描二级索引的时候，加载到内存的聚簇索引的数据页被淘汰，所以回表的时候会有大量的随机IO来磁盘读</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231225103521504.png" alt="image-20231225103521504" tabindex="0" loading="lazy"><figcaption>image-20231225103521504</figcaption></figure><blockquote><p>这条更新语句涉及了哪些区域呢？</p></blockquote><ul><li>内存（buffer pool）</li><li>redo log（ib_log_fileX）</li><li>数据表空间（t.ibd）</li><li>系统表空间（ibdata1）</li></ul><blockquote><p>这条更新语句按顺序做了什么事情？</p></blockquote><ol><li>Page 1 在内存中，直接更新内存；</li><li>Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息</li><li>将上述两个动作记入 redo log 中</li></ol><blockquote><p>这条更新语句的性能怎么样？</p></blockquote><p>执行这条更新语句的成本很低，就写了两处内存，然后合起来写了一次磁盘，还是按顺序写的</p><p>同时，图中的虚线操作，也就是写进磁盘的操作都是异步的，不影响更新的响应时间</p><h4 id="查询语句" tabindex="-1"><a class="header-anchor" href="#查询语句" aria-hidden="true">#</a> 查询语句</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t <span class="token keyword">WHERE</span> k <span class="token operator">in</span> <span class="token punctuation">(</span>k1<span class="token punctuation">,</span> k2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果读语句发生在更新语句后不久，内存中的数据都还在</p><p>那么此时的这两个读操作就与系统表空间（ibdata1）和 redo log（ib_log_fileX）无关了</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231225104210993.png" alt="image-20231225104210993" tabindex="0" loading="lazy"><figcaption>image-20231225104210993</figcaption></figure><blockquote><p>这条查询语句按顺序做了什么事情？</p></blockquote><ol><li><p>读 Page 1 的时候，直接从内存返回。</p></li><li><p>要读 Page 2 的时候，需要把 Page 2 从磁盘读入内存中，然后应用 change buffer 里面的操作日志，生成一个正确的版本并返回结果。</p></li></ol><blockquote><p>WAL 之后如果读数据，是不是一定要读盘，是不是一定要从 redo log 里面把数据更新以后才可以返回？</p></blockquote><p>其实是不用的。虽然磁盘上还是之前的数据，但是这里直接从内存返回结果，结果是正确的。</p><h4 id="两种机制的对比" tabindex="-1"><a class="header-anchor" href="#两种机制的对比" aria-hidden="true">#</a> 两种机制的对比</h4><p>redo log 主要节省的是<strong>随机写磁盘的 IO 消耗</strong>（转成顺序写）</p><p>change buffer 主要节省的则是<strong>随机读磁盘的 IO 消耗</strong></p><hr></div><!--[--><!----><!--]--><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/lgy8888/my_blog.git/edit/main/src/backEnd/MySQL/存储引擎.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><nav class="vp-page-nav"><a aria-label="逻辑架构" class="vp-link nav-link prev nav-link prev" href="/my_blog/backEnd/MySQL/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.html"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><span class="font-icon icon iconfont icon-write" style=""></span>逻辑架构</div></a><a aria-label="索引" class="vp-link nav-link next nav-link next" href="/my_blog/backEnd/MySQL/%E7%B4%A2%E5%BC%95.html"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">索引<span class="font-icon icon iconfont icon-write" style=""></span></div></a></nav><div id="comment" class="giscus-wrapper input-top" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">林光远的个人笔记网站</div><div class="vp-copyright">Copyright © 2024 LGYNB</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/my_blog/assets/app-OTaO6_y0.js" defer></script>
  </body>
</html>
