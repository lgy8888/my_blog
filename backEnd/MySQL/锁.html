<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.0" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.2" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://vuepress-theme-hope-docs-demo.netlify.app/my_blog/backEnd/MySQL/%E9%94%81.html"><meta property="og:site_name" content="林光远的个人笔记"><meta property="og:title" content="锁"><meta property="og:description" content="锁与并发事务 解决并发事务的问题 并发事务访问相同记录的情况可以分为3种读-读：并发事务相继读取相同的记录; 写-写：并发事务相继对相同的记录做出改动; 读-写/写-读：一个事务进行读取操作，另一个进行改动操作。;  读-读并发有什么问题？ 读取操作本身不会对记录产生改动，不会引起什么问题 写-写并发有什么问题？ 写-写并发会发生脏写的问题，..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="LGYNB"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"锁","image":[""],"dateModified":null,"author":[{"@type":"Person","name":"LGYNB","url":"/"}]}</script><link rel="icon" href="/my_blog/favicon.ico"><title>锁 | 林光远的个人笔记</title><meta name="description" content="锁与并发事务 解决并发事务的问题 并发事务访问相同记录的情况可以分为3种读-读：并发事务相继读取相同的记录; 写-写：并发事务相继对相同的记录做出改动; 读-写/写-读：一个事务进行读取操作，另一个进行改动操作。;  读-读并发有什么问题？ 读取操作本身不会对记录产生改动，不会引起什么问题 写-写并发有什么问题？ 写-写并发会发生脏写的问题，...">
    <link rel="preload" href="/my_blog/assets/style-ERUp4lUP.css" as="style"><link rel="stylesheet" href="/my_blog/assets/style-ERUp4lUP.css">
    <link rel="modulepreload" href="/my_blog/assets/app-OTaO6_y0.js"><link rel="modulepreload" href="/my_blog/assets/锁.html-DDZS4CtS.js"><link rel="modulepreload" href="/my_blog/assets/plugin-vue_export-helper-x3n3nnut.js"><link rel="modulepreload" href="/my_blog/assets/锁.html-gGHC61ao.js">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand vp-brand" href="/my_blog/"><img class="vp-nav-logo" src="/my_blog/logo.png" alt="林光远的个人笔记"><!----><span class="vp-site-name hide-in-pad">林光远的个人笔记</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a aria-label="后端技术" class="vp-link nav-link active nav-link active" href="/my_blog/backEnd/"><span class="font-icon icon iconfont icon-back-stage" style=""></span>后端技术<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="Web开发" class="vp-link nav-link nav-link" href="/my_blog/webDevelop/"><span class="font-icon icon iconfont icon-config" style=""></span>Web开发<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="AI技术" class="vp-link nav-link nav-link" href="/my_blog/ai/"><span class="font-icon icon iconfont icon-function" style=""></span>AI技术<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="数据结构与算法" class="vp-link nav-link nav-link" href="/my_blog/coding/"><span class="font-icon icon iconfont icon-calculate" style=""></span>数据结构与算法<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="项目经历" class="vp-link nav-link nav-link" href="/my_blog/projects/"><span class="font-icon icon iconfont icon-code" style=""></span>项目经历<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/lgy8888/my_blog.git" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索本站" autocomplete="off" spellcheck="false" value><!----></form><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-cache" style=""></span><span class="vp-sidebar-title">Redis</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><span class="font-icon icon iconfont icon-mysql" style=""></span><span class="vp-sidebar-title">MySQL</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a aria-label="SQL基础" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/SQL%E5%9F%BA%E7%A1%80.html"><span class="font-icon icon iconfont icon-write" style=""></span>SQL基础<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="SQL原理" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/SQL%E5%8E%9F%E7%90%86.html"><span class="font-icon icon iconfont icon-write" style=""></span>SQL原理<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="数据类型" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"><span class="font-icon icon iconfont icon-write" style=""></span>数据类型<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="数据库设计" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1.html"><span class="font-icon icon iconfont icon-write" style=""></span>数据库设计<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="逻辑架构" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.html"><span class="font-icon icon iconfont icon-write" style=""></span>逻辑架构<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="存储引擎" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html"><span class="font-icon icon iconfont icon-write" style=""></span>存储引擎<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="索引" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E7%B4%A2%E5%BC%95.html"><span class="font-icon icon iconfont icon-write" style=""></span>索引<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="事务" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E4%BA%8B%E5%8A%A1.html"><span class="font-icon icon iconfont icon-write" style=""></span>事务<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="日志" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html"><span class="font-icon icon iconfont icon-write" style=""></span>日志<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="锁" class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active nav-link active vp-sidebar-link vp-sidebar-page active" href="/my_blog/backEnd/MySQL/%E9%94%81.html"><span class="font-icon icon iconfont icon-write" style=""></span>锁<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="锁与并发事务" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#锁与并发事务"><!---->锁与并发事务<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="解决并发事务的问题" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#解决并发事务的问题"><!---->解决并发事务的问题<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="一致性读" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#一致性读"><!---->一致性读<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="锁定读" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#锁定读"><!---->锁定读<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="写操作" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#写操作"><!---->写操作<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="多粒度锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#多粒度锁"><!---->多粒度锁<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="多粒度锁的概念" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#多粒度锁的概念"><!---->多粒度锁的概念<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="意向锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#意向锁"><!---->意向锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="MySQL中的行锁和表锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#mysql中的行锁和表锁"><!---->MySQL中的行锁和表锁<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="存储引擎中的锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#存储引擎中的锁"><!---->存储引擎中的锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="InnoDB中的表级锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#innodb中的表级锁"><!---->InnoDB中的表级锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="InnoDB的行级锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#innodb的行级锁"><!---->InnoDB的行级锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="InnoDB锁的内存结构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#innodb锁的内存结构"><!---->InnoDB锁的内存结构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="MySQL加锁规则" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#mysql加锁规则"><!---->MySQL加锁规则<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="唯一索引" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#唯一索引"><!---->唯一索引<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="非唯一索引" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#非唯一索引"><!---->非唯一索引<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="MySQL死锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#mysql死锁"><!---->MySQL死锁<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="死锁的发生" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#死锁的发生"><!---->死锁的发生<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="产生死锁的原因" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#产生死锁的原因"><!---->产生死锁的原因<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="INSERT语句加行锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#insert语句加行锁"><!---->INSERT语句加行锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="分析是否死锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#分析是否死锁"><!---->分析是否死锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="排查死锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#排查死锁"><!---->排查死锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="避免死锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#避免死锁"><!---->避免死锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="悲观锁和乐观锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#悲观锁和乐观锁"><!---->悲观锁和乐观锁<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="两种锁的定义" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#两种锁的定义"><!---->两种锁的定义<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="两种锁的实现" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#两种锁的实现"><!---->两种锁的实现<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="两种锁如何选择" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/MySQL/%E9%94%81.html#两种锁如何选择"><!---->两种锁如何选择<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a aria-label="性能调优" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/MySQL/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98.html"><span class="font-icon icon iconfont icon-write" style=""></span>性能调优<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-java" style=""></span><span class="vp-sidebar-title">Java</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-OS" style=""></span><span class="vp-sidebar-title">OS</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->锁</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="/" target="_blank" rel="noopener noreferrer">LGYNB</a></span><span property="author" content="LGYNB"></span></span><!----><!----><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 51 分钟</span><meta property="timeRequired" content="PT51M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#锁与并发事务">锁与并发事务</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#解决并发事务的问题">解决并发事务的问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#一致性读">一致性读</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#锁定读">锁定读</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#写操作">写操作</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#多粒度锁">多粒度锁</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#多粒度锁的概念">多粒度锁的概念</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#意向锁">意向锁</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#mysql中的行锁和表锁">MySQL中的行锁和表锁</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#存储引擎中的锁">存储引擎中的锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#innodb中的表级锁">InnoDB中的表级锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#innodb的行级锁">InnoDB的行级锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#innodb锁的内存结构">InnoDB锁的内存结构</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#mysql加锁规则">MySQL加锁规则</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#唯一索引">唯一索引</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#非唯一索引">非唯一索引</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#mysql死锁">MySQL死锁</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#死锁的发生">死锁的发生</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#产生死锁的原因">产生死锁的原因</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#insert语句加行锁">INSERT语句加行锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#分析是否死锁">分析是否死锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#排查死锁">排查死锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#避免死锁">避免死锁</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#悲观锁和乐观锁">悲观锁和乐观锁</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#两种锁的定义">两种锁的定义</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#两种锁的实现">两种锁的实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#两种锁如何选择">两种锁如何选择</a></li><!----><!--]--></ul></li><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h1 id="锁" tabindex="-1"><a class="header-anchor" href="#锁" aria-hidden="true">#</a> 锁</h1><h2 id="锁与并发事务" tabindex="-1"><a class="header-anchor" href="#锁与并发事务" aria-hidden="true">#</a> 锁与并发事务</h2><h3 id="解决并发事务的问题" tabindex="-1"><a class="header-anchor" href="#解决并发事务的问题" aria-hidden="true">#</a> 解决并发事务的问题</h3><p>并发事务访问相同记录的情况可以分为3种</p><ul><li><strong>读-读</strong>：并发事务相继读取相同的记录</li><li><strong>写-写</strong>：并发事务相继对相同的记录做出改动</li><li><strong>读-写/写-读</strong>：一个事务进行读取操作，另一个进行改动操作。</li></ul><blockquote><p><strong>读-读并发有什么问题？</strong></p></blockquote><p>读取操作本身不会对记录产生改动，不会引起什么问题</p><blockquote><p><strong>写-写并发有什么问题？</strong></p></blockquote><p>写-写并发会发生脏写的问题，任何一种隔离级别都不允许这种问题的发生</p><blockquote><p>如何解决这个问题？</p></blockquote><p>所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。</p><p>这个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的</p><blockquote><p>锁结构是什么样子的？</p></blockquote><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。</p><p>比方说事务T1 要对这条记录做改动，就需要生成一个锁结构与之关联：</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240117230336870.png" alt="image-20240117230336870" tabindex="0" loading="lazy"><figcaption>image-20240117230336870</figcaption></figure><p>其实在锁结构里有很多信息，这是其中两个比较重要的属性：</p><ul><li>trx信息：代表这个锁结构是哪个事务生成的。</li><li>is_waiting ：代表当前事务是否在等 <ul><li>is_waiting属性为false，表示该事务获取锁成功，或者说加锁成功</li><li>is_waiting属性为true，表示该事务获取锁失败，或者说加锁失败</li></ul></li></ul><p>比方说事务T2在同一时间也想对这条记录做改动，也需要生成一个锁结构，但是T2很显然加锁是失败的</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240117230538752.png" alt="image-20240117230538752" tabindex="0" loading="lazy"><figcaption>image-20240117230538752</figcaption></figure><p>在事务T1 提交之后，就会把该事务生成的锁结构释放掉，然后看看还有没有别的事务在等待获取锁，发现了事务T2 还在等待获取锁，所以把事务T2 对应的锁结构的is_waiting 属性设置为false ，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2 就算获取到锁</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240117230657609.png" alt="image-20240117230657609" tabindex="0" loading="lazy"><figcaption>image-20240117230657609</figcaption></figure><blockquote><p><strong>读-写并发或者写-读并发会产生什么问题？</strong></p></blockquote><p>这种情况下可能发生脏读、不可重复读、幻读的问题</p><blockquote><p>如何解决这些问题？</p></blockquote><ul><li><u><strong>读操作利用多版本并发控制（MVCC），写操作进行加锁</strong></u><ul><li>MVCC 就是通过生成一个ReadView ，然后通过ReadView 找到符合条件的记录版本</li><li>其实就像是在生成ReadView 的那个时刻做了一次时间静止（就像用相机拍了一个快照），查询语句只能读到在生成ReadView 之前已提交事务所做的更改，在生成ReadView 之前未提交的事务或者之后才开启的事务所做的更改是看不到的。</li><li>写操作肯定针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是<strong>采用MVCC 时， 读-写操作并不冲突</strong>。</li></ul></li><li><u><strong>读、写操作都采用加锁的方式</strong></u><ul><li>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本，比方在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。</li><li>在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候也就需要对其进行加锁操作，这样也就意味着<strong>读操作和写操作也像写-写操作那样排队执行</strong>。</li></ul></li></ul><h3 id="一致性读" tabindex="-1"><a class="header-anchor" href="#一致性读" aria-hidden="true">#</a> 一致性读</h3><blockquote><p>Consistent Reads</p></blockquote><p>事务利用MVCC 进行的读取操作称之为一致性读，或者一致性无锁读，有的地方也称之为快照读</p><p>所有普通的SELECT 语句（ plain SELECT ）在READ COMMITTED 、REPEATABLE READ 隔离级别下都算是一致性读</p><p>一致性读并不会对表中的任何记录做加锁操作，其他事务可以自由的对表中的记录做改动。</p><h3 id="锁定读" tabindex="-1"><a class="header-anchor" href="#锁定读" aria-hidden="true">#</a> 锁定读</h3><blockquote><p>Locking Reads</p></blockquote><h4 id="共享锁和独占锁" tabindex="-1"><a class="header-anchor" href="#共享锁和独占锁" aria-hidden="true">#</a> 共享锁和独占锁</h4><p>在使用加锁的方式解决问题时，既要允许读-读情况不受影响，又要使写-写、读-写或写-读情况中的操作相互阻塞</p><p>MySQL给锁分了两类</p><ul><li>共享锁（Shared Locks）：简称S锁，<strong>在事务要读取一条记录时，需要先获取该记录的S锁</strong></li><li>独占锁/排他锁（Exclusive Locks）：简称X锁，<strong>在事务要改动一条记录时，需要先获取该记录的X锁</strong></li></ul><blockquote><p>这两个锁是什么意思?</p></blockquote><p>S锁是事务读取的时候获取的锁，同一条记录的S锁可以供多个事务共同持有</p><p>X锁是事务修改的时候获取的锁，同一条记录的X锁只能有一个事务持有，持有X锁的事务只能只有X锁</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240117232004282.png" alt="image-20240117232004282" tabindex="0" loading="lazy"><figcaption>image-20240117232004282</figcaption></figure><ul><li>事务A持有记录1的S锁，事务B也可以持有记录1的S锁</li><li>事务A持有记录1的X锁，事务B就不可以持有记录1的S锁或者X锁了</li></ul><h4 id="锁定读的语句" tabindex="-1"><a class="header-anchor" href="#锁定读的语句" aria-hidden="true">#</a> 锁定读的语句</h4><blockquote><p><strong>对读取的记录加S锁</strong></p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> ··· <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>如果当前事务执行了该语句，那么它会为读取到的记录加S锁</li><li>这样允许别的事务继续获取这些记录的S锁（比方说别的事务也使用SELECT ... LOCK IN SHARE MODE 语句来读取这些记录）</li><li>但是不能获取这些记录的X锁（比方说使用SELECT ... FOR UPDATE语句来读取这些记录，或者直接修改这些记录）。</li><li>如果别的事务想要获取这些记录的X锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的S锁释放掉。</li></ul><blockquote><p><strong>对读取的记录加X锁</strong></p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> ··· <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>如果当前事务执行了该语句，那么它会为读取到的记录加X锁</li><li>这样既不允许别的事务获取这些记录的S锁（比方说别的事务使用SELECT ... LOCK IN SHARE MODE 语句来读取这些记录）</li><li>也不允许获取这些记录的X锁（比方也说使用SELECT ... FOR UPDATE 语句来读取这些记录，或者直接修改这些记录）</li><li>如果别的事务想要获取这些记录的S锁或者X锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的X锁释放掉。</li></ul><h3 id="写操作" tabindex="-1"><a class="header-anchor" href="#写操作" aria-hidden="true">#</a> 写操作</h3><h4 id="delete" tabindex="-1"><a class="header-anchor" href="#delete" aria-hidden="true">#</a> DELETE</h4><ul><li>对一条记录做DELETE 操作的过程其实是先在B+ 树中定位到这条记录的位置</li><li>获取一下这条记录的X锁</li><li>执行delete mark 操作。</li><li>可以把这个定位待删除记录在B+ 树中位置的过程看成是一个获取X锁的锁定读。</li></ul><h4 id="update" tabindex="-1"><a class="header-anchor" href="#update" aria-hidden="true">#</a> UPDATE</h4><p>在对一条记录做UPDATE 操作时分为三种情况：</p><ul><li>如果未修改该记录的键值并且<strong>被更新的列占用的存储空间在修改前后未发生变化</strong><ul><li>先在B+ 树中定位到这条记录的位置</li><li>获取一下记录的X锁</li><li>最后在原记录的位置进行修改操作。</li><li>可以把这个定位待修改记录在B+ 树中位置的过程看成是一个获取X锁的锁定读。</li></ul></li><li>如果未修改该记录的键值并且<strong>至少有一个被更新的列占用的存储空间在修改前后发生变化</strong><ul><li>先在B+ 树中定位到这条记录的位置</li><li>获取一下记录的X锁</li><li>将该记录彻底删除掉（就是把记录彻底移入垃圾链表）</li><li>最后再插入一条新记录。</li><li>这个定位待修改记录在B+ 树中位置的过程看成是一个获取X锁的锁定读，新插入的记录由INSERT 操作提供的隐式锁进行保护。</li></ul></li><li>如果<strong>修改了该记录的键值</strong><ul><li>相当于在原记录上做DELETE 操作之后再来一次INSERT 操作</li><li>加锁操作就需要按照DELETE 和INSERT 的规则进行</li></ul></li></ul><h4 id="insert" tabindex="-1"><a class="header-anchor" href="#insert" aria-hidden="true">#</a> INSERT</h4><p>一般情况下，新插入一条记录的操作并不加锁</p><p>InnoDB通过隐式锁来保护这条新插入的记录在本事务提交前不被别的事务访问</p><p>在一些特殊情况下INSERT操作也是会获取锁的</p><h2 id="多粒度锁" tabindex="-1"><a class="header-anchor" href="#多粒度锁" aria-hidden="true">#</a> 多粒度锁</h2><h3 id="多粒度锁的概念" tabindex="-1"><a class="header-anchor" href="#多粒度锁的概念" aria-hidden="true">#</a> 多粒度锁的概念</h3><blockquote><p>什么是粒度？</p></blockquote><p>锁的粒度粗细指的是锁住的对象的大小</p><p>行级锁/行锁是针对记录的锁，粒度较细</p><p>表级锁/表锁是整张表的锁，粒度就较粗</p><p>表锁可以分为S锁和X锁</p><ul><li>给表加S锁： <ul><li>别的事务可以继续获得该表的S锁</li><li>别的事务可以继续获得该表中的某些记录的S锁</li><li>别的事务不可以继续获得该表的X锁</li><li>别的事务不可以继续获得该表中的某些记录的X锁</li></ul></li><li>给表加X锁： <ul><li>别的事务不可以继续获得该表的S锁</li><li>别的事务不可以继续获得该表中的某些记录的S锁</li><li>别的事务不可以继续获得该表的X锁</li><li>别的事务不可以继续获得该表中的某些记录的X锁</li></ul></li></ul><blockquote><p><strong>加深理解</strong></p></blockquote><blockquote><p>角色分配</p></blockquote><p>教学楼——表；教室——行记录；</p><p>学生——针对行记录的只读事务；校领导——针对整个表的只读事务；</p><p>维修工——针对行记录的读写事务；考试——针对整个表的读写事务；</p><blockquote><p>许多学生去同一间教室自习——&gt;许多只读事务并发访问同一条记录</p></blockquote><p>教室一般都是公用的，我们可以随便选教室进去上自习。一间教室可以容纳很多同学同时上自习，每当一个人进去上自习，就相当于在教室门口挂了一把S锁，如果很多同学都进去上自习，相当于教室门口挂了很多把S锁（类似行级别的S锁）。</p><blockquote><p>维修工去教室检修——&gt;读写事务访问行记录</p></blockquote><p>有的时候教室会进行检修，比方说换地板，换天花板，换灯管啥的，这些维修项目并不能同时开展。如果教室针对某个项目进行检修，就不允许别的同学来上自习，也不允许其他维修项目进行，此时相当于教室门口会挂一把X锁（类似行级别的X锁）。</p><blockquote><p>校领导参观教学楼——&gt;只读事务访问整个表</p></blockquote><p>校领导考虑并不想影响同学们上自习，但是此时不能有教室处于维修状态，所以可以在教学楼门口放置一把S锁（类似表级别的S锁）。此时：</p><ul><li>来上自习的学生们看到教学楼门口有S锁，可以继续进入教学楼上自习。</li><li>修理工看到教学楼门口有S锁，则先在教学楼门口等着，啥时候领导走了，把教学楼的S锁撤掉再进入教学楼维修。</li></ul><blockquote><p>学校占用教学楼进行考试——&gt;读写事务访问整个表</p></blockquote><p>此时不允许教学楼中有正在上自习的教室，也不允许对教室进行维修。所以可以在教学楼门口放置一把X锁（类似表级别的X锁）。此时：</p><ul><li>来上自习的学生们看到教学楼门口有X锁，则需要在教学楼门口等着，啥时候考试结束，把教学楼的X锁撤掉再进入教学楼上自习。</li><li>修理工看到教学楼门口有X锁，则先在教学楼门口等着，啥时候考试结束，把教学楼的X锁撤掉再进入教学楼维修。</li></ul><h3 id="意向锁" tabindex="-1"><a class="header-anchor" href="#意向锁" aria-hidden="true">#</a> 意向锁</h3><blockquote><p>上面例子存在问题</p></blockquote><ul><li>如果我们想对教学楼整体上S锁，首先需要确保教学楼中的没有正在维修的教室，如果有正在维修的教室，需要等到维修结束才可以对教学楼整体上S锁。</li><li>如果我们想对教学楼整体上X锁，首先需要确保教学楼中的没有上自习的教室以及正在维修的教室，如果有上自习的教室或者正在维修的教室，需要等到全部上自习的同学都上完自习离开，以及维修工维修完教室离开后才可以对教学楼整体上X锁。</li></ul><p>但是在需要上表锁的时候如何才能知道表中各行记录是否已经被上锁了呢？</p><blockquote><p>解决方案</p></blockquote><p>InnoDB提出了意向锁</p><ul><li>意向共享锁（Intention Shared Lock，IS锁）：当事务准备在某条记录上加S锁时，需要现在表级别加一个IS锁</li><li>意向独占锁（Intention Exclusive Lock ，IX锁）：当事务准备在某条记录上加X锁时，需要先在表级别加一个IX锁</li></ul><blockquote><p>场景对照</p></blockquote><ul><li>如果有学生到教室中上自习，那么他先在整栋教学楼门口放一把IS锁（表级锁），然后再到教室门口放一把S锁（行锁）。</li><li>如果有维修工到教室中维修，那么它先在整栋教学楼门口放一把IX锁（表级锁），然后再到教室门口放一把X锁（行锁）。</li></ul><p>之后：</p><ul><li>如果有领导要参观教学楼，也就是想在教学楼门口前放S锁（表锁）时，首先要看一下教学楼门口有没有IX锁，如果有，意味着有教室在维修，需要等到维修结束把IX锁撤掉后才可以在整栋教学楼上加S锁。</li><li>如果有考试要占用教学楼，也就是想在教学楼门口前放X锁（表锁）时，首先要看一下教学楼门口有没有IS锁或IX锁，如果有，意味着有教室在上自习或者维修，需要等到学生们上完自习以及维修结束把IS锁和IX锁撤掉后才可以在整栋教学楼上加X锁。</li><li>学生在教学楼门口加IS锁时，是不关心教学楼门口是否有IX锁的，维修工在教学楼门口加IX锁时，是不关心教学楼门口是否有IS锁或者其他IX锁的。IS和IX锁只是为了判断当前时间教学楼里有没有被占用的教室用的，也就是在对教学楼加S锁或者X锁时才会用到。</li></ul><p><strong>IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录</strong>，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240118143613855.png" alt="image-20240118143613855" tabindex="0" loading="lazy"><figcaption>image-20240118143613855</figcaption></figure><h2 id="mysql中的行锁和表锁" tabindex="-1"><a class="header-anchor" href="#mysql中的行锁和表锁" aria-hidden="true">#</a> MySQL中的行锁和表锁</h2><h3 id="存储引擎中的锁" tabindex="-1"><a class="header-anchor" href="#存储引擎中的锁" aria-hidden="true">#</a> 存储引擎中的锁</h3><p>对于MyISAM 、MEMORY 、MERGE 这些存储引擎来说，它们只支持表级锁，而且这些引擎并不支持事务，所以使用这些存储引擎的锁一般都是针对当前会话来说的。</p><p>比方说在Session 1 中对一个表执行SELECT 操作，就相当于为这个表加了一个表级别的S锁，如果在SELECT 操作未完成时， Session 2 中对这个表执行UPDATE 操作，相当于要获取表的X锁，此操作会被阻塞，直到Session 1 中的SELECT 操作完成，释放掉表级别的S锁后，Session 2 中对这个表执行UPDATE 操作才能继续获取X锁，然后执行具体的更新语句。</p><p>因为使用MyISAM、MEMORY、MERGE这些存储引擎的表在同一时刻只允许一个会话对表进行写操作，所以这些存储引擎实际上最好用在只读，或者大部分都是读操作，或者单用户的情景下。</p><p>在MyISAM存储引擎中有一个称之为Concurrent Inserts的特性，支持在对MyISAM表读取时同时插 入记录，这样可以提升一些插入速度</p><p>InnoDB 存储引擎既支持表锁，也支持行锁。表锁实现简单，占用资源较少，不过粒度很粗，有时候你仅仅需要锁住几条记录，但使用表锁的话相当于为表中的所有记录都加锁，所以性能比较差。行锁粒度更细，可以实现更精准的并发控制</p><h3 id="innodb中的表级锁" tabindex="-1"><a class="header-anchor" href="#innodb中的表级锁" aria-hidden="true">#</a> InnoDB中的表级锁</h3><h4 id="表锁" tabindex="-1"><a class="header-anchor" href="#表锁" aria-hidden="true">#</a> 表锁</h4><p>在对某个表执行SELECT 、INSERT 、DELETE 、UPDATE 语句时， InnoDB 存储引擎是不会为这个表添加表级别的S锁或者X锁的。</p><p>在对某个表执行一些诸如ALTER TABLE 、DROP TABLE 这类的DDL 语句时，其他事务对这个表并发执 行诸如SELECT 、INSERT 、DELETE 、UPDATE 的语句会发生阻塞，同理，某个事务中对某个表执行 SELECT 、INSERT 、DELETE 、UPDATE 语句时，在其他会话中对这个表执行DDL 语句也会发生阻塞。</p><p>这个过程其实是通过在server层使用元数据锁（英文名： Metadata Locks ，简称MDL ）来实现的，一般情况下也不会使用InnoDB 存储引擎自己提供的表级别的S锁和X锁。</p><ul><li>DDL语句执行时会隐式的提交当前会话中的事务，这主要是DDL语句的执行一般都会在若干个特殊事务中完成，在开启这些特殊事务前，需要将当前会话中的事务提交掉</li></ul><p>InnoDB 存储引擎提供的表级S锁或者X锁是相当鸡肋，只会在一些特殊情况下，比方说崩溃恢复过程中用到</p><blockquote><p>手动获取表级S锁和X锁</p></blockquote><p>在系统变量autocommit=0，innodb_table_locks =1 时，手动获取InnoDB 存储引擎提供的表t 的S锁或者X锁可以这么写：</p><ul><li><code>LOCK TABLES t READ</code> ： InnoDB 存储引擎会对表t 加表级别的S锁。</li><li><code>LOCK TABLES t WRITE</code> ： InnoDB 存储引擎会对表t 加表级别的X锁</li></ul><p>尽量避免在使用InnoDB 存储引擎的表上使用LOCK TABLES 这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已</p><h4 id="元数据锁" tabindex="-1"><a class="header-anchor" href="#元数据锁" aria-hidden="true">#</a> 元数据锁</h4><blockquote><p>MDL，Matadata Lock</p></blockquote><ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li><li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li></ul><p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p><p>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p><p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</p><blockquote><p>MDL 不需要显示调用，那它是在什么时候释放的?</p></blockquote><p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p><p>那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p><ol><li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</li><li>然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</li><li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li></ol><p>那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</p><blockquote><p>为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？</p></blockquote><p>这是因为申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p><p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p><blockquote><p><strong>线上修改表存在的问题</strong></p></blockquote><p>在InnoDB事务中，锁是需要的时候加上，但是不是不需要了就能立马释放的，要等到事务结束之后才释放</p><p>这就导致了在事务还没有结束，也就是还有锁没被释放的时候，MDL锁是无法加上的，DDL就会一直阻塞着</p><table><thead><tr><th>SessionA</th><th>SessionB</th><th>SessionC</th><th>SessionD</th></tr></thead><tbody><tr><td>BEGIN;</td><td></td><td></td><td></td></tr><tr><td>SELECT * FROM user WHERE id= 1；</td><td></td><td></td><td></td></tr><tr><td></td><td>SELECT * FROM user WHERE id= 1；</td><td></td><td></td></tr><tr><td></td><td></td><td>ALTER TABLE user ADD COLUMN test INT;（阻塞）</td><td>SELECT * FROM user WHERE id= 1；（阻塞）</td></tr></tbody></table><ul><li><code>Session A</code>开启一个事务，执行了一个简单的查询语句。</li><li>此时，<code>Session B</code>，执行另一个查询语句，可以成功。</li><li>接着，<code>Session C</code>执行了一个<code>DDL</code>操作，加了个字段，因为<code>Session A</code>的事务没有提交，而且<code>Session A</code>持有<code>MDL</code>读锁，<code>Session C</code>获取不到<code>MDL</code>写锁，所以<code>Session C</code>堵塞等待<code>MDL</code>写锁。</li><li>由于<code>MDL</code>写锁获取优先级高于<code>MDL</code>读锁，因此<code>Session D</code>这个时候也获取不到<code>MDL</code>读锁，等待<code>Session C</code>获取到<code>MDL</code>写锁之后它才能获取到<code>MDL</code>读锁。</li></ul><p><strong>DDL操作之前如果存在长事务，一直不提交，DDL操作就会一直被堵塞，还会间接的影响后面其他的查询，导致所有的查询都被堵塞。</strong></p><h4 id="意向锁-1" tabindex="-1"><a class="header-anchor" href="#意向锁-1" aria-hidden="true">#</a> 意向锁</h4><p>当我们在对使用InnoDB 存储引擎的表的某些记录加S锁之前，那就需要先在表级别加一个IS锁，当我们在对使用InnoDB 存储引擎的表的某些记录加X锁之前，那就需要先在表级别加一个IX锁。</p><p>IS锁和IX锁的使命只是为了后续在加表级别的S锁和X锁时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录</p><h4 id="auto-inc锁" tabindex="-1"><a class="header-anchor" href="#auto-inc锁" aria-hidden="true">#</a> AUTO-INC锁</h4><p>AUTO-INC锁对应的作用是实现自增（AUTO_INCREMENT）</p><p>系统实现这种自动给AUTO_INCREMENT 修饰的列递增赋值的原理主要是两个：</p><ul><li><p>采用AUTO-INC 锁</p><ul><li>在执行插入语句时就在表级别加一个AUTO-INC 锁，然后为每条待插入记录的AUTO_INCREMENT 修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INC 锁释放掉。</li><li>这样一个事务在持有AUTO-INC 锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连续的。</li><li>如果我们的插入语句在执行前不可以确定具体要插入多少条记录（无法预计即将插入记录的数量），比方说使用INSERT ... SELECT 、REPLACE ... SELECT 或者LOAD DATA 这种插入语句，一般是使用AUTO-INC 锁为AUTO_INCREMENT 修饰的列生成对应的值。</li><li>这个AUTO-INC锁的作用范围只是单个插入语句，插入语句执行完成后，这个锁就被释放了</li></ul></li><li><p>采用一个轻量级的锁</p><ul><li>在为插入语句生成AUTO_INCREMENT 修饰的列的值时获取一下这个轻量级锁，然后生成本次插入语句需要用到的AUTO_INCREMENT 列的值之后，就把该轻量级锁释放掉，并不需要等到整个插入语句执行完才释放锁。</li><li>如果我们的插入语句在执行前就可以确定具体要插入多少条记录，比方说我们上边举的关于表t 的例子中，在语句执行前就可以确定要插入2条记录，那么一般采用轻量级锁的方式对AUTO_INCREMENT 修饰的列进行赋值。这种方式可以避免锁定表，可以提升插入性能。</li></ul></li></ul><h3 id="innodb的行级锁" tabindex="-1"><a class="header-anchor" href="#innodb的行级锁" aria-hidden="true">#</a> InnoDB的行级锁</h3><blockquote><p>示例表</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> hero <span class="token punctuation">(</span>
    number <span class="token keyword">INT</span><span class="token punctuation">,</span>
    name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    country <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">KEY</span> idx_name <span class="token punctuation">(</span>name<span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">Engine</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> hero <span class="token keyword">VALUES</span>
    <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;l刘备&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;蜀&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&#39;z诸葛亮&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;蜀&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">&#39;c曹操&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;魏&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token string">&#39;x荀彧&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;魏&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">&#39;s孙权&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;吴&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">--------+------------+---------+</span>
<span class="token operator">|</span> number <span class="token operator">|</span> name 	  <span class="token operator">|</span> country <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">--------+------------+---------+</span>
<span class="token operator">|</span> <span class="token number">1</span> 	 <span class="token operator">|</span> l刘备	     <span class="token operator">|</span> 蜀	  <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">3</span>	 	 <span class="token operator">|</span> z诸葛亮     <span class="token operator">|</span> 蜀		 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">8</span>		 <span class="token operator">|</span> c曹操       <span class="token operator">|</span> 魏  	  <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">15</span>	 <span class="token operator">|</span> x荀彧 		 <span class="token operator">|</span> 魏 	  <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">20</span> 	 <span class="token operator">|</span> s孙权 		 <span class="token operator">|</span> 吴	  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">--------+------------+---------+</span>
<span class="token number">5</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>聚簇索引示意图</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240118150519199.png" alt="image-20240118150519199" tabindex="0" loading="lazy"><figcaption>image-20240118150519199</figcaption></figure><h4 id="record-lock" tabindex="-1"><a class="header-anchor" href="#record-lock" aria-hidden="true">#</a> Record Lock</h4><p>这就是最普通的记录锁，仅仅把一条记录锁上</p><p>官方的类型名称为：LOCK_REC_NOT_GAP</p><p>比方说把number 值为8 的那条记录加一个普通的记录锁</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240118151803777.png" alt="image-20240118151803777" tabindex="0" loading="lazy"><figcaption>image-20240118151803777</figcaption></figure><p>普通的记录锁是有S锁和X锁之分的</p><ul><li>当一个事务获取了一条记录的S记录锁后，其他事务也可以继续获取该记录的S记录锁，但不可以继续获取X记录锁；</li><li>当一个事务获取了一条记录的X记录锁后，其他事务既不可以继续获取该记录的S记录锁，也不可以继续获取X记录锁</li></ul><h4 id="gap-lock" tabindex="-1"><a class="header-anchor" href="#gap-lock" aria-hidden="true">#</a> Gap Lock</h4><p>Gap Lock称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下的幻读问题</p><p>比方说把number 值为8 的那条记录加一个gap锁</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240118152659515.png" alt="image-20240118152659515" tabindex="0" loading="lazy"><figcaption>image-20240118152659515</figcaption></figure><ul><li><p>给number值为8的记录加了间隙锁后，意味着不允许别的事物在number值为8的记录前边的间隙插入新纪录</p></li><li><p>也就是number值区间为<code>(3, 8)</code>之间的新纪录是不允许立刻插入的</p></li><li><p>需要等到拥有间隙锁的事务提交之后才能插入</p></li></ul><p>间隙锁的提出只是为了防止插入幻影记录</p><p>间隙锁也是有分S锁的X锁的，但是它们起的作用是相同的，无论是S间隙锁还是X间隙锁，都不会影响其他事务对这条记录继续加其他锁</p><p>间隙锁除了可以加在用户记录上，也可以加在最大最小记录上</p><ul><li>Infimum 记录，表示该页面中最小的记录。</li><li>Supremum 记录，表示该页面中最大的记录</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240118153201862.png" alt="image-20240118153201862" tabindex="0" loading="lazy"><figcaption>image-20240118153201862</figcaption></figure><p>这样就可以阻止其他事务插入number 值在<code>(20, +∞)</code> 这个区间的新记录</p><h4 id="next-key-lock" tabindex="-1"><a class="header-anchor" href="#next-key-lock" aria-hidden="true">#</a> Next-Key Lock</h4><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p><p>比方说我们把number 值为8 的那条记录加一个next-key锁</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240118153309120.png" alt="image-20240118153309120" tabindex="0" loading="lazy"><figcaption>image-20240118153309120</figcaption></figure><p>next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中</p><p><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p><h4 id="insert-intention-lock" tabindex="-1"><a class="header-anchor" href="#insert-intention-lock" aria-hidden="true">#</a> Insert Intention Lock</h4><p>Insert Intention Lock称为插入意向锁</p><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）</p><p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p><p>比方说我们把number 值为8 的那条记录加一个插入意向锁</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240118153502389.png" alt="image-20240118153502389" tabindex="0" loading="lazy"><figcaption>image-20240118153502389</figcaption></figure><p>比方说现在T1 为number 值为8 的记录加了一个间隙锁，然后T2 和T3 分别想向hero 表中插入number 值分别为4 、5 的两条记录，</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240118153634454.png" alt="image-20240118153634454" tabindex="0" loading="lazy"><figcaption>image-20240118153634454</figcaption></figure><ul><li>由于T1 持有间隙锁，所以T2 和T3 需要生成一个插入意向锁的锁结构并且处于等待状态</li><li>当T1 提交后会把它获取到的锁都释放掉，这样T2 和T3 就能获取到对应的插入意向锁了（本质上就是把插入意向锁对应锁结构的is_waiting 属性改为false ）</li><li>T2 和T3 之间也并不会相互阻塞，它们可以同时获取到number 值为8的插入意向锁，然后执行插入操作</li><li>插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁</li></ul><h3 id="innodb锁的内存结构" tabindex="-1"><a class="header-anchor" href="#innodb锁的内存结构" aria-hidden="true">#</a> InnoDB锁的内存结构</h3><p>InnoDB为了节省空间，如果符合条件，就将这些记录的锁放在同一个锁结构中</p><ul><li>在同一个事务中进行加锁操作</li><li>被加锁的记录在同一个页面中</li><li>加锁的类型是一样的</li><li>等待状态是一样的</li></ul><blockquote><p>InnoDB的锁结构长什么样呢？</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240118154037185.png" alt="image-20240118154037185" tabindex="0" loading="lazy"><figcaption>image-20240118154037185</figcaption></figure><ul><li>锁所在的事务信息： <ul><li>不论是表锁还是行锁，都是在事务执行过程中生成的，哪个事务生成了这个锁结构，这里就记载着这个事务的信息</li><li>该属性是一个指针，可以找到内存中关于该事务的更多信息，比方说事务id是什么</li></ul></li><li>索引信息： <ul><li>对于行锁来说，需要记录一下加锁的记录是属于哪个索引的。</li><li>该属性也是一个指针</li></ul></li><li>表锁／行锁信息： <ul><li>表锁：记载着这是对哪个表加的锁，还有其他的一些信息。</li><li>行锁 <ul><li>Space ID ：记录所在表空间。</li><li>Page Number ：记录所在页号。</li><li>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，<u>用不同的比特位来区分到底是哪一条记录加了锁</u>。为此在行锁结构的末尾放置了一堆比特位，这个n_bits 属性代表使用了多少比特位。</li></ul></li></ul></li><li>type_mode ： <ul><li>这是一个32位的数，被分成了lock_mode 、lock_type rec_lock_type 三个部分</li><li>分别表示锁的模式（IS、IX、S、X、AUTO_INC），锁的类型（表级锁、行级锁），行锁的具体类型（记录锁、间隙锁、临键锁、插入意向锁、其他类型···）</li><li>该属性的最后一位用来表示LOCK_WAIT，也就是当前事务是否处于等待状态（是否获取到锁）</li></ul></li><li>一堆比特位： <ul><li>如果是行锁的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的n_bits 属性表示的</li><li>页面中的每条记录在记录头信息中都包含一个<code>heap_no</code> 属 性，锁结构最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个<code>heap_no</code></li></ul></li></ul><h2 id="mysql加锁规则" tabindex="-1"><a class="header-anchor" href="#mysql加锁规则" aria-hidden="true">#</a> MySQL加锁规则</h2><p><strong>加锁的对象是索引</strong></p><p><strong>加锁的基本单位是 next-key lock</strong></p><ul><li><p><strong>next-key lock 是前开后闭区间，而间隙锁是前开后开区间</strong></p></li><li><p><strong>在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成记录锁或间隙锁</strong></p></li></ul><p>如果是用二级索引（不管是不是非唯一索引，还是唯一索引）进行锁定读查询的时候，除了会对二级索引项加行级锁（如果是唯一索引的二级索引，加锁规则和主键索引相同），而且还会对查询到的记录的主键索引项上加「记录锁」。</p><p>在线上在执行 update、delete、select ... for update 等具有加锁性质的语句，一定要检查语句是否走了索引，<strong>如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了</strong>，这是挺严重的问题。</p><blockquote><p><strong>记忆口诀</strong></p></blockquote><ul><li><strong>遇事不决临键锁</strong>。你可以认为，全部都是加临键锁的，除了下面两个子句提到的例外情况。</li><li><strong>右边缺省间隙锁</strong>。例如你的值只有（1，4，7）三个，但是你查询的条件是 WHERE id &lt; 5，那么加的其实是间隙锁，因为 7 本身不在你的条件范围内。</li><li><strong>等值查询记录锁</strong>。这个其实针对的是主键和唯一索引，普通索引只适用上面两条。</li></ul><h3 id="唯一索引" tabindex="-1"><a class="header-anchor" href="#唯一索引" aria-hidden="true">#</a> 唯一索引</h3><h4 id="等值查询" tabindex="-1"><a class="header-anchor" href="#等值查询" aria-hidden="true">#</a> 等值查询</h4><p>当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同</p><ul><li><p><strong>当查询的记录是「存在」的</strong>，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会<strong>退化成「记录锁」</strong>。</p><ul><li>等值查询记录存在的话直接锁住就行了，没必要用到临键锁</li></ul></li><li><p><strong>当查询的记录是「不存在」的</strong>，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会<strong>退化成「间隙锁」</strong>。</p><ul><li>退化为间隙锁是因为等值查询与左右边界没有关系，也就没必要锁住左右边界的记录</li><li>不能退化为记录锁是因为无法锁住一条不存在的记录，锁结构是跟B+树叶子节点关联的</li></ul></li></ul><h4 id="范围查询" tabindex="-1"><a class="header-anchor" href="#范围查询" aria-hidden="true">#</a> 范围查询</h4><ul><li>针对 <code>&gt;</code> 或 <code>&gt;= </code>的范围查询： <ul><li>如果是 <code>&gt;</code> 条件的范围查询：对扫描到的索引以及最大记录都加上next-key锁</li><li>如果是 <code>&gt;=</code> 条件的范围查询：因为存在等值查询的条件，如果等值查询的记录是存在于表中，那么等值查询到的记录的索引中的 next-key 锁<strong>会退化成记录锁</strong>。</li></ul></li><li>针对 <code>&lt; </code> 或 <code>&lt;=</code> 的范围查询，要看条件值的记录是否存在于表中： <ul><li><strong>当条件值的记录不在表中</strong><ul><li><strong>那么不管是 <code>&lt;</code> 还是 <code>&lt;=</code> 条件的范围查询</strong>，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁<strong>会退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</li></ul></li><li><strong>当条件值的记录在表中</strong><ul><li><strong>如果是 <code>&lt;</code> 条件的范围查询</strong>，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁<strong>会退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；</li><li><strong>如果 <code>&lt;=</code> 条件的范围查询</strong>，扫描到终止范围查询的记录时，该记录的索引 next-key 锁<strong>不会退化成间隙锁</strong>。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</li></ul></li></ul></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/唯一索引加锁流程.jpeg" alt="唯一索引加锁流程" tabindex="0" loading="lazy"><figcaption>唯一索引加锁流程</figcaption></figure><h4 id="唯一索引加锁总结" tabindex="-1"><a class="header-anchor" href="#唯一索引加锁总结" aria-hidden="true">#</a> 唯一索引加锁总结</h4><p>使用唯一索引做等值查询的情况下</p><p>如果有符合条件的记录，则给该记录加上记录锁</p><p>如果没有符合条件的记录，则给该记录的上一条记录和下一条记录之间的间隙加上间隙锁</p><p>使用唯一索引做范围查询的情况下，为所有查询到的索引加上临键锁，视情况而定将临键锁退化成间隙锁或记录锁</p><p>如果是开区间，且边界条件没有记录（跟闭区间但是边界条件没有记录一样）</p><ul><li>加在边界条件内的锁则不变（<code>&gt;</code>）</li><li>加在边界条件外的锁则换成间隙锁（<code>&lt;</code>）</li></ul><p>如果是闭区间，且边界条件有记录</p><ul><li>加在边界条件上的锁不变（<code>&lt;=</code>），但是如果刚好剩它一条记录的话，临键锁会退化为记录锁（<code>&gt;=</code>）</li></ul><h3 id="非唯一索引" tabindex="-1"><a class="header-anchor" href="#非唯一索引" aria-hidden="true">#</a> 非唯一索引</h3><h4 id="等值查询-1" tabindex="-1"><a class="header-anchor" href="#等值查询-1" aria-hidden="true">#</a> 等值查询</h4><p>当我们用非唯一索引进行等值查询的时候，<strong>因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这两个索引都加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁</strong>。</p><p>针对非唯一索引等值查询时，查询的记录存不存在，加锁的规则也会不同：</p><ul><li>当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是<strong>非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁</strong>。</li><li>当查询的记录「不存在」时，<strong>扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁</strong>。</li></ul><h4 id="范围查询-1" tabindex="-1"><a class="header-anchor" href="#范围查询-1" aria-hidden="true">#</a> 范围查询</h4><p>非唯一索引和主键索引的范围查询的加锁是类似的</p><p>不同之处在于<strong>非唯一索引范围查询，索引的 next-key lock 不会有退化为间隙锁和记录锁的情况</strong>，</p><p>也就是<strong>非唯一索引进行范围查询时，对二级索引记录加锁都是加 next-key 锁</strong>。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/非唯一索引加锁流程.jpeg" alt="非唯一索引加锁流程" tabindex="0" loading="lazy"><figcaption>非唯一索引加锁流程</figcaption></figure><h2 id="mysql死锁" tabindex="-1"><a class="header-anchor" href="#mysql死锁" aria-hidden="true">#</a> MySQL死锁</h2><h3 id="死锁的发生" tabindex="-1"><a class="header-anchor" href="#死锁的发生" aria-hidden="true">#</a> 死锁的发生</h3><blockquote><p>存储引擎为InnoDB，隔离级别为可重复读（RR）</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>t_order<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>order_no<span class="token punctuation">`</span></span> <span class="token keyword">int</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>create_date<span class="token punctuation">`</span></span> <span class="token keyword">datetime</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>index_order<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>order_no<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240119152624169.png" alt="image-20240119152624169" tabindex="0" loading="lazy"><figcaption>image-20240119152624169</figcaption></figure><p>假设这时有两事务</p><p>一个事务要插入订单 1007</p><p>另外一个事务要插入订单 1008</p><p>因为需要对订单做幂等性校验，所以两个事务先要查询该订单是否存在，不存在才插入记录，过程如下：</p><table><thead><tr><th>trxA</th><th>trxB</th></tr></thead><tbody><tr><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>SELECT id FROM t_order WHERE order_no = 1007 FOR UPDATE</td><td></td></tr><tr><td></td><td>SELECT id FROM t_order WHERE order_no = 1008 FOR UPDATE</td></tr><tr><td>INSERT INTO t_order (order_no, create_date) VALUES (1007, NOW());<br><strong>阻塞</strong></td><td></td></tr><tr><td></td><td>INSERT INTO t_order (order_no, create_date) VALUES (1008, NOW());<br><strong>阻塞</strong></td></tr></tbody></table><p>两个事务都陷入了等待状态（前提没有打开死锁检测），也就是发生了死锁，因为都在相互等待对方释放锁。</p><p>这里在查询记录是否存在的时候，使用了 <code>select ... for update</code> 语句，目的为了防止事务执行的过程中，有其他事务插入了记录，而出现幻读的问题。</p><p>如果没有使用 <code>select ... for update</code> 语句，而使用了单纯的 select 语句，如果是两个订单号一样的请求同时进来，就会出现两个重复的订单，有可能出现幻读</p><table><thead><tr><th>trxA</th><th>trxB</th></tr></thead><tbody><tr><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>SELECT id FROM t_order WHERE order_no = 1007 FOR UPDATE</td><td></td></tr><tr><td></td><td>SELECT id FROM t_order WHERE order_no = 1007 FOR UPDATE</td></tr><tr><td>INSERT INTO t_order (order_no, create_date) VALUES (1007, NOW());</td><td></td></tr><tr><td></td><td>INSERT INTO t_order (order_no, create_date) VALUES (1007, NOW());</td></tr><tr><td>COMMIT;</td><td>COMMIT;</td></tr></tbody></table><ul><li>发生幻读，数据库中有两条订单号为1007的记录</li></ul><h3 id="产生死锁的原因" tabindex="-1"><a class="header-anchor" href="#产生死锁的原因" aria-hidden="true">#</a> 产生死锁的原因</h3><blockquote><p><strong>事务A执行锁定查语句时的加锁情况</strong></p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> t_order <span class="token keyword">WHERE</span> order_no <span class="token operator">=</span> <span class="token number">1007</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240119154818918.png" alt="image-20240119154818918" tabindex="0" loading="lazy"><figcaption>image-20240119154818918</figcaption></figure><p>共加了两个锁，分别是</p><ul><li>表锁：X类型的意向锁</li><li>行锁：X类型的临键锁</li></ul><p><strong>事务 A 在二级索引（INDEX_NAME : index_order）上加的是 X 型的 next-key 锁，锁范围是<code>(1006, +∞]</code></strong>。</p><p>由于该临键锁是锁在最大记录上的，而最大记录不是一个真实的记录，所以该锁跟间隙锁太大的区别</p><blockquote><p><strong>如何确定范围是<code>(1006,+∞)</code>的？</strong></p></blockquote><p>如果 LOCK_MODE 是 next-key 锁或者间隙锁，那么 LOCK_DATA 就表示锁的范围最右值</p><p>此次的事务 A 的 LOCK_DATA 是 supremum pseudo-record，表示的是 +∞。</p><p>然后锁范围的最左值是 t_order 表中最后一个记录的 index_order 的值，也就是 1006。因此，next-key 锁的范围 <code>(1006, +∞]</code>。</p><blockquote><p><strong>为什么两个插入语句被锁住了，而在事务A之后执行的事务B的锁定查语句没被锁住？</strong></p></blockquote><p>执行插入语句时，会在插入间隙上获取插入意向锁</p><ul><li>插入意向锁与间隙锁是冲突的，所以当其它事务持有该间隙的间隙锁时，需要等待其它事务释放间隙锁之后，才能获取到插入意向锁</li><li>间隙锁与间隙锁之间是兼容的，所以所以两个事务中 <code>select ... for update</code> 语句并不会相互影响</li></ul><p>事务 A 和事务 B 在执行完后 <code>select ... for update</code> 语句后都持有范围为<code>(1006,+∞]</code>的next-key 锁</p><p>而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，导致死锁。</p><blockquote><p><strong>为什么间隙锁和间隙锁之间是兼容的</strong>？</p></blockquote><p><strong>间隙锁的意义只在于阻止区间被插入</strong>，因此是可以共存的。</p><p><strong>一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁</strong>，共享和排他的间隙锁是没有区别的</p><p>他们相互不冲突，且功能相同，即两个事务可以同时持有包含共同间隙的间隙锁。</p><blockquote><p><strong>next-key lock之间是兼容的吗？</strong></p></blockquote><p>next-key lock 是包含间隙锁+记录锁的</p><p>如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。</p><p><strong>但是对于锁在最大最小记录上面的next-key lock来说，由于最大最小记录并不是一个真实的记录，所以两个事务可以同时持有</strong></p><h3 id="insert语句加行锁" tabindex="-1"><a class="header-anchor" href="#insert语句加行锁" aria-hidden="true">#</a> INSERT语句加行锁</h3><p>Insert 语句在正常执行时是不会生成锁结构的，它是靠聚簇索引记录自带的 trx_id 隐藏列来作为<strong>隐式锁</strong>来保护记录的。</p><blockquote><p><strong>什么是隐式锁？</strong></p></blockquote><p>当事务需要加锁的时，如果这个锁不可能发生冲突，InnoDB会跳过加锁环节，这种机制称为隐式锁。</p><p>隐式锁是 InnoDB 实现的一种延迟加锁机制，其特点是只有在可能发生冲突时才加锁，从而减少了锁的数量，提高了系统整体性能。</p><p>隐式锁就是在 Insert 过程中不加锁，只有在特殊情况下，才会将隐式锁转换为显示锁，这里我们列举两个场景。</p><ul><li>如果记录之间加有间隙锁，为了避免幻读，此时是不能插入记录的；</li><li>如果 Insert 的记录和已有记录存在唯一键冲突，此时也不能插入记录</li></ul><h4 id="记录之间有间隙锁" tabindex="-1"><a class="header-anchor" href="#记录之间有间隙锁" aria-hidden="true">#</a> 记录之间有间隙锁</h4><p>每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁</p><p>如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态，现象就是 Insert 语句会被阻塞</p><ul><li>MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁</li><li>只有当锁状态为正常状态时，才代表事务成功获取到了锁</li></ul><blockquote><p>例子</p></blockquote><p>现在 t_order 表中，只有这些数据，<strong>order_no 是二级索引</strong>。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240119212057377.png" alt="image-20240119212057377" tabindex="0" loading="lazy"><figcaption>image-20240119212057377</figcaption></figure><p>现在，事务 A 执行了下面这条语句。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 事务 A</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_order <span class="token keyword">where</span> order_no <span class="token operator">=</span> <span class="token number">1006</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
Empty <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这条锁定读语句会在最大记录上加一个临键锁</li><li>锁定的范围是<code>(1005, +∞]</code></li></ul><p>此时事务B想在这个间隙锁的范围内插入一条记录</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 事务 B</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> t_order<span class="token punctuation">(</span>order_no<span class="token punctuation">,</span> create_date<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1010</span><span class="token punctuation">,</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment"># 阻塞状态</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>事务B的加锁情况</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240119212334717.png" alt="image-20240119212334717" tabindex="0" loading="lazy"><figcaption>image-20240119212334717</figcaption></figure><p>事务 B 的插入操作生成了一个插入意向锁（<code>LOCK_MODE: X,INSERT_INTENTION</code>），锁的状态是等待状态</p><p>意味着事务 B 并没有成功获取到插入意向锁，因此事务 B 发生阻塞</p><h4 id="遇到唯一键冲突" tabindex="-1"><a class="header-anchor" href="#遇到唯一键冲突" aria-hidden="true">#</a> 遇到唯一键冲突</h4><p>如果在插入新记录时，插入了一个与「已有的记录的主键或者唯一二级索引列值相同」的记录（不过可以有多条记录的唯一二级索引列的值同时为NULL，这里不考虑这种情况），此时插入就会失败，然后对于这条记录加上了 <strong>S 型的锁</strong>。</p><ul><li>如果主键索引重复，插入新记录的事务会给已存在的主键值重复的聚簇索引记录<strong>添加 S 型记录锁</strong>。</li><li>如果唯一二级索引重复，插入新记录的事务都会给已存在的二级索引列值重复的二级索引记录<strong>添加 S 型 next-key 锁</strong>。</li></ul><h5 id="主键索引冲突" tabindex="-1"><a class="header-anchor" href="#主键索引冲突" aria-hidden="true">#</a> 主键索引冲突</h5><p>t_order 表中的 id 字段为主键索引，并且已经存在 id 值为 5 的记录</p><p>此时有个事务插入了一条 id 为 5 的记录，就会报主键索引冲突的错误。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t_order <span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Duplicate entry &#39;5&#39; for key &#39;t_order.PRIMARY&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>除了报错之外，给还会给id为5的记录加上一个S记录锁</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240119212650265.png" alt="image-20240119212650265" tabindex="0" loading="lazy"><figcaption>image-20240119212650265</figcaption></figure><p>在隔离级别是「可重复读」的情况下，如果在插入数据的时候，发生了主键索引冲突，插入新记录的事务会给已存在的主键值重复的聚簇索引记录<strong>添加 S 型记录锁</strong></p><h5 id="唯一二级索引冲突" tabindex="-1"><a class="header-anchor" href="#唯一二级索引冲突" aria-hidden="true">#</a> 唯一二级索引冲突</h5><p>t_order 表中的 order_no 字段为唯一二级索引，并且已经存在 order_no 值为 1001 的记录</p><p>此时事务 A插入了 order_no 为 1001 的记录，就出现了报错</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t_order <span class="token punctuation">(</span>order_no<span class="token punctuation">,</span> create_date<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">,</span> <span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Duplicate entry &#39;1001&#39; for key &#39;t_order.index_order&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>除了报错之外，还会给order_no值为1001的记录加上S临键锁</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240119212935249.png" alt="image-20240119212935249" tabindex="0" loading="lazy"><figcaption>image-20240119212935249</figcaption></figure><p>此时如果有另一个事务想要更新这条记录或着锁定读这条记录就会阻塞，因为X锁跟S锁不兼容</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>INSERT INTO t_order (order_no, create_date) VALUES (1001, NOW());</td><td></td></tr><tr><td></td><td>SELECT * FROM t_order WHERE order_no = 1001 FOR UPDATE<br><strong>阻塞</strong></td></tr></tbody></table><h4 id="执行相同的insert语句" tabindex="-1"><a class="header-anchor" href="#执行相同的insert语句" aria-hidden="true">#</a> 执行相同的INSERT语句</h4><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>INSERT INTO t_order (order_no, create_date) VALUES (1001, NOW());</td><td></td></tr><tr><td></td><td>INSERT INTO t_order (order_no, create_date) VALUES (1001, NOW());<br><strong>阻塞</strong></td></tr></tbody></table><p>两个事务的加锁过程</p><ul><li>事务 A 先插入 order_no 为 1006 的记录，可以插入成功，此时对应的唯一二级索引记录被「隐式锁」保护，此时还没有实际的锁结构（执行完这里的时候，你可以看查 performance_schema.data_locks 信息，可以看到这条记录是没有加任何锁的）；</li><li>事务 B 也插入 order_no 为 1006 的记录，由于事务 A 已经插入 order_no 值为 1006 的记录，所以事务 B 在插入二级索引记录时会遇到重复的唯一二级索引列值，此时事务 B 想获取一个 S 型 next-key 锁，但是事务 A 并未提交，<strong>事务 A 插入的 order_no 值为 1006 的记录上的「隐式锁」会变「显示锁」且锁类型为 X 型的记录锁，所以事务 B 向获取 S 型 next-key 锁时会遇到锁冲突，事务 B 进入阻塞状态</strong>。</li></ul><p>并发多个事务的时候，第一个事务插入的记录，并不会加锁，而是会用隐式锁保护唯一二级索引的记录。</p><p>但是当第一个事务还未提交的时候，有其他事务插入了与第一个事务相同的记录，第二个事务就会<strong>被阻塞</strong>，<strong>因为此时第一事务插入的记录中的隐式锁会变为显示锁且类型是 X 型的记录锁，而第二个事务是想对该记录加上 S 型的 next-key 锁，X 型与 S 型的锁是冲突的</strong>，所以导致第二个事务会等待，直到第一个事务提交后，释放了锁。</p><h3 id="分析是否死锁" tabindex="-1"><a class="header-anchor" href="#分析是否死锁" aria-hidden="true">#</a> 分析是否死锁</h3><blockquote><p><strong>字节面试题</strong></p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240119214639408.png" alt="image-20240119214639408" tabindex="0" loading="lazy"><figcaption>image-20240119214639408</figcaption></figure><blockquote><p><strong>分析过程</strong></p></blockquote><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>UPDATE students SET score=100 WHERE id=25;</td><td></td></tr><tr><td></td><td>UPDATE students SET score=100 WHERE id=26;</td></tr><tr><td>INSERT INTO students(id, no, name, age, score) VALUES (25, &#39;s0025&#39;, &#39;sony&#39;, 28, 90);</td><td></td></tr><tr><td></td><td>INSERT INTO students(id, no, name, age, score) VALUES (26, &#39;s0026&#39;, &#39;ace&#39;, 28, 90);</td></tr></tbody></table><ul><li>事务A更新25号记录，此时会先在数据库中按照主键找到25号记录 <ul><li>数据库中找不到25号记录，主键找不到记录时会往后找最近的一条记录，然后给它加一个间隙锁，锁的范围是这条记录跟上一条记录之间，在这里就是<code>(20, 30)</code></li></ul></li><li>事务B更新26号记录，此时还是会先在数据库中按照主键找到26号记录 <ul><li>数据库中找不到25号记录，主键会往后找最近的一条记录，然后给它加一个间隙锁，锁的范围还是<code>(20, 30)</code></li><li>虽然事务A将<code>(20,30)</code>之间用间隙锁锁起来了，但是间隙锁之间是兼容的，所以事务B也会给30号记录加一个间隙锁</li></ul></li><li>事务A接着想插入25号记录 <ul><li>很快发现插入的范围内被加了间隙锁，所以事务A会在这加个插入间隙锁，此时该锁处于WATING状态，也就是阻塞着</li><li>由于事务B还没提交，事务A的插入操作需要等到事务B提交后锁释放后才能继续运行</li></ul></li><li>事务B接着想插入26号记录 <ul><li>很快发现插入的范围内被加了间隙锁，所以事务B会在这加个插入间隙锁，此时该锁处于WATING状态，也就是阻塞着</li><li>由于事务A还没提交，事务B的插入操作需要等到事务A提交后锁释放后才能继续运行</li></ul></li><li>两个事务互相等待对方提交，产生死锁</li></ul><h3 id="排查死锁" tabindex="-1"><a class="header-anchor" href="#排查死锁" aria-hidden="true">#</a> 排查死锁</h3><p>排查死锁首先要学会看死锁日志</p><p>可以通过<code>SHOW ENGINE INNODB STATUS;</code>来查看死锁日志：</p><p>死锁日志分为两个部分</p><p>上半部分说明了事务1在等待什么锁</p><p>下半部分说明了事务2当前持有的锁以及等待的锁</p><p>通过阅读死锁日志，可以清楚的知道两个事务形成了怎么样的循环等待</p><p>加以分析，就可以逆向推断出循环等待的成因，也就是死锁形成的原因。</p><h3 id="避免死锁" tabindex="-1"><a class="header-anchor" href="#避免死锁" aria-hidden="true">#</a> 避免死锁</h3><p>死锁的四个必要条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>。</p><p>只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。</p><ol><li><strong>按相同的顺序来访问记录和表</strong><ul><li>对索引加锁顺序不一致可能会导致死锁，所以如果可以的话，尽量以相同的顺序来访问索引记录和表。</li><li>在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，可以降低出现死锁的可能性</li></ul></li><li><strong>降低隔离级别，避免产生间隙锁</strong><ul><li>间隙锁往往是死锁的真凶，默认情况的隔离级别可重复读（RR）是允许间隙锁的</li><li>如果能够确定幻读和不可重复读对应用的影响不大，可以讲隔离级别改成读已提交（RC），这样可以避免间隙锁导致的死锁</li></ul></li><li><strong>避免全表扫描</strong><ul><li>给表添加合理的索引，全表扫描会给每一条记录都加上锁，死锁的概率会大大增加</li></ul></li><li><strong>一次锁定所有资源</strong><ul><li>MyISAM支支持表锁，它采用一次封锁技术来保证事务之间不会发生死锁</li><li>同样的我们也可以在事务中一次性锁定所有资源，减少死锁的概率</li></ul></li><li><strong>避免大事务</strong><ul><li>尽量将大事务拆成多个小事务来处理，大事务占用资源多，耗时长，与其他事务冲突的概率也比较高</li></ul></li><li><strong>避免同一时间运行同种脚本</strong><ul><li>避免在同一时间点运行多个对同一表进行读写的脚本，特别注意加锁且操作数据量比较大的语句；</li><li>我们经常会有一些定时脚本，避免它们在同一时间点运行；</li></ul></li><li><strong>设置锁等待超时参数</strong><ul><li><code>innodb_lock_wait_timeout</code>，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖跨数据库。</li><li>我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。</li></ul></li></ol><h2 id="悲观锁和乐观锁" tabindex="-1"><a class="header-anchor" href="#悲观锁和乐观锁" aria-hidden="true">#</a> 悲观锁和乐观锁</h2><h3 id="两种锁的定义" tabindex="-1"><a class="header-anchor" href="#两种锁的定义" aria-hidden="true">#</a> 两种锁的定义</h3><h4 id="悲观锁定义" tabindex="-1"><a class="header-anchor" href="#悲观锁定义" aria-hidden="true">#</a> 悲观锁定义</h4><blockquote><p><strong>Pessimistic Lock</strong></p></blockquote><p>就是很悲观，每次去拿数据的时候都认为别人会修改。</p><p>所以每次在拿数据的时候都会上锁。这样别人想拿数据就被挡住，直到悲观锁被释放</p><p><strong>悲观锁中的共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong></p><p>在效率方面，处理加锁的机制会产生额外的开销，还有增加产生死锁的机会。</p><p>另外还会降低并行性，如果已经锁定了一个线程 A，其他线程就必须等待该线程 A 处理完才可以处理</p><p>数据库中的行锁，表锁，读锁（共享锁），写锁（排他锁），以及 <strong>syncronized</strong> 实现的锁均为悲观锁</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/878bb165a2beff2ae05d5de2c526dc7c.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>悲观并发控制实际上是“<strong>先取锁再访问</strong>”的保守策略，为数据处理的安全提供了保证，</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/a8947cfde136dc8fe221bac06c06d7b9.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="乐观锁定义" tabindex="-1"><a class="header-anchor" href="#乐观锁定义" aria-hidden="true">#</a> 乐观锁定义</h4><blockquote><p><strong>Optimistic Lock</strong></p></blockquote><p>就是很乐观，每次去拿数据的时候都认为别人不会修改。</p><p>所以不会上锁，但是如果想要更新数据，则会在更新前检查在读取至更新这段时间别人有没有修改过这个数据。</p><p>如果修改过，则重新读取，再次尝试更新，循环上述步骤直到更新成功（当然也允许更新失败的线程放弃操作）</p><p>乐观锁适用于多读的应用类型，这样可以提高吞吐量</p><p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。</p><p>一般的实现乐观锁的方式就是记录数据版本（version）或者是时间戳来实现，不过使用版本记录是最常用的。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/875d47694413676c0f39ddda24919af0.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>乐观控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。</p><h3 id="两种锁的实现" tabindex="-1"><a class="header-anchor" href="#两种锁的实现" aria-hidden="true">#</a> 两种锁的实现</h3><h4 id="悲观锁的实现" tabindex="-1"><a class="header-anchor" href="#悲观锁的实现" aria-hidden="true">#</a> 悲观锁的实现</h4><p>MySQL的锁机制讲的都是悲观锁</p><p>在进行写操作（增、删、改）的时候或者进行锁定读（select ··· for update）的时候会添加悲观锁</p><h4 id="乐观锁的实现" tabindex="-1"><a class="header-anchor" href="#乐观锁的实现" aria-hidden="true">#</a> 乐观锁的实现</h4><blockquote><p><strong>用版本号实现</strong></p></blockquote><p>给记录增加一个版本号的属性</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/74fe427a10c9e68a1096c259884d722e.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>有用户 A 和用户 B，在同一家店铺去购买同一个商品，但是商品的可购买数量只有一个</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/3d7f4964aec4fe74efa439818f2005c3.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ol><li>首先用户 A 和用户 B 同时将臭豆腐（id=2）的数据查出来</li><li>然后用户 A 先买，用户 A 将（id=1 和 version=0）作为条件进行数据更新，将数量-1，并且将版本号+1。此时版本号变为 1。用户 A 此时就完成了商品的购买</li><li>用户 B 开始买，用户 B 也将（id=1 和 version=0）作为条件进行数据更新</li><li>更新完后，发现更新的数据行数为 0，此时就说明已经有人改动过数据，此时就应该提示用户 B 重新查看最新数据购买</li></ol><h4 id="cas" tabindex="-1"><a class="header-anchor" href="#cas" aria-hidden="true">#</a> CAS</h4><blockquote><p>Compare-and-Swap，比较并替换 / Compare-and-Set，比较并设置</p></blockquote><ol><li>比较：读取到一个值A，在将其更新为B之前，检查原值是否依旧为A（没有被其他线程改动）</li><li>设置 <ul><li>如果是原值，将A更新为B，如何结束</li><li>如果不是原值，则什么的不做</li></ul></li></ol><blockquote><p>什么是CAS？</p></blockquote><p>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，<strong>失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</strong></p><blockquote><p>CAS有什么用？</p></blockquote><p>有了 CAS，就可以实现一个乐观锁，允许多个线程同时读取（因为根本没有加锁操作），但是只有一个线程可以成功更新数据，并导致其他要更新数据的线程回滚重试</p><p>CAS 利用 CPU 指令，从硬件层面保证了操作的原子性，以达到类似于锁的效果。</p><p>乐观锁策略也被称为无锁编程。换句话说，乐观锁其实不是“锁”，它仅仅是一个循环重试 CAS 的算法而已</p><blockquote><p><strong>CAS 会产生 ABA 问题，什么是 ABA 问题，以及如何解决呢？</strong></p></blockquote><p>**ABA 问题：**如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 &quot;ABA&quot;问题。</p><p>**ABA 问题解决：**我们需要加上一个版本号（Version）,在每次提交的时候将版本号+1 操作，那么下个线程去提交修改的时候，会带上版本号去判断，如果版本修改了，那么线程重试或者提示错误信息~</p><h3 id="两种锁如何选择" tabindex="-1"><a class="header-anchor" href="#两种锁如何选择" aria-hidden="true">#</a> 两种锁如何选择</h3><p><strong>悲观锁阻塞事务，乐观锁回滚重试</strong>，它们各有优缺点，不要认为一种一定好于另一种。像<strong>乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候</strong>，这样可以省去锁的开销，加大了系统的整个吞吐量。</p><p><strong>但如果经常产生冲突，上层应用会不断的进行重试，这样反倒是降低了性能</strong>，所以这种情况下用悲观锁就比较合适。</p><p>1、乐观锁并未真正加锁，所以效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。</p><p>2、悲观锁依赖数据库锁，效率低。更新失败的概率比较低。</p><p><strong>随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被使用到生产环境中了，尤其是并发量比较大的业务场景。</strong></p></div><!--[--><!----><!--]--><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/lgy8888/my_blog.git/edit/main/src/backEnd/MySQL/锁.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><nav class="vp-page-nav"><a aria-label="日志" class="vp-link nav-link prev nav-link prev" href="/my_blog/backEnd/MySQL/%E6%97%A5%E5%BF%97.html"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><span class="font-icon icon iconfont icon-write" style=""></span>日志</div></a><a aria-label="性能调优" class="vp-link nav-link next nav-link next" href="/my_blog/backEnd/MySQL/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98.html"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">性能调优<span class="font-icon icon iconfont icon-write" style=""></span></div></a></nav><div id="comment" class="giscus-wrapper input-top" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">林光远的个人笔记网站</div><div class="vp-copyright">Copyright © 2024 LGYNB</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/my_blog/assets/app-OTaO6_y0.js" defer></script>
  </body>
</html>
