<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.0" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.2" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://vuepress-theme-hope-docs-demo.netlify.app/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html"><meta property="og:site_name" content="林光远的个人笔记"><meta property="og:title" content="Redis持久化"><meta property="og:description" content="持久化介绍 Redis是跑在内存里的，当程序重启或者服务崩溃，数据就会全部丢失 如果业务场景希望重启之后数据还在，就需要持久化，即把数据保存到可永久保存的存储设备中 持久化方式 两种方式：RDB(Redis Database)，记录Redis某个时刻的全部数据，这种方式的本质就是数据快照，直接保存二进制数据到磁盘，后续通过加载RDB文件恢复数据; i..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="LGYNB"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Redis持久化","image":[""],"dateModified":null,"author":[{"@type":"Person","name":"LGYNB","url":"/"}]}</script><link rel="icon" href="/my_blog/favicon.ico"><title>Redis持久化 | 林光远的个人笔记</title><meta name="description" content="持久化介绍 Redis是跑在内存里的，当程序重启或者服务崩溃，数据就会全部丢失 如果业务场景希望重启之后数据还在，就需要持久化，即把数据保存到可永久保存的存储设备中 持久化方式 两种方式：RDB(Redis Database)，记录Redis某个时刻的全部数据，这种方式的本质就是数据快照，直接保存二进制数据到磁盘，后续通过加载RDB文件恢复数据; i...">
    <link rel="preload" href="/my_blog/assets/style-ERUp4lUP.css" as="style"><link rel="stylesheet" href="/my_blog/assets/style-ERUp4lUP.css">
    <link rel="modulepreload" href="/my_blog/assets/app-OTaO6_y0.js"><link rel="modulepreload" href="/my_blog/assets/Redis持久化.html-3qe78yeh.js"><link rel="modulepreload" href="/my_blog/assets/plugin-vue_export-helper-x3n3nnut.js"><link rel="modulepreload" href="/my_blog/assets/Redis持久化.html-RoPlZKlB.js">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand vp-brand" href="/my_blog/"><img class="vp-nav-logo" src="/my_blog/logo.png" alt="林光远的个人笔记"><!----><span class="vp-site-name hide-in-pad">林光远的个人笔记</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a aria-label="后端技术" class="vp-link nav-link active nav-link active" href="/my_blog/backEnd/"><span class="font-icon icon iconfont icon-back-stage" style=""></span>后端技术<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="Web开发" class="vp-link nav-link nav-link" href="/my_blog/webDevelop/"><span class="font-icon icon iconfont icon-config" style=""></span>Web开发<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="AI技术" class="vp-link nav-link nav-link" href="/my_blog/ai/"><span class="font-icon icon iconfont icon-function" style=""></span>AI技术<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="数据结构与算法" class="vp-link nav-link nav-link" href="/my_blog/coding/"><span class="font-icon icon iconfont icon-calculate" style=""></span>数据结构与算法<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="项目经历" class="vp-link nav-link nav-link" href="/my_blog/projects/"><span class="font-icon icon iconfont icon-code" style=""></span>项目经历<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/lgy8888/my_blog.git" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索本站" autocomplete="off" spellcheck="false" value><!----></form><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><span class="font-icon icon iconfont icon-cache" style=""></span><span class="vp-sidebar-title">Redis</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a aria-label="分布式系统理论" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA.html"><span class="font-icon icon iconfont icon-write" style=""></span>分布式系统理论<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis数据结构" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis数据结构<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis数据结构面试题汇总" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis数据结构面试题汇总<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis的运作" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E7%9A%84%E8%BF%90%E4%BD%9C.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis的运作<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis的运作面试题汇总" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E7%9A%84%E8%BF%90%E4%BD%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis的运作面试题汇总<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis与客户端" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis与客户端<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis持久化" class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active nav-link active vp-sidebar-link vp-sidebar-page active" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis持久化<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="持久化介绍" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#持久化介绍"><!---->持久化介绍<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="持久化方式" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#持久化方式"><!---->持久化方式<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="两种方式的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#两种方式的区别"><!---->两种方式的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="适用场景" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#适用场景"><!---->适用场景<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="RDB" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#rdb"><!---->RDB<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="开启RDB持久化" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#开启rdb持久化"><!---->开启RDB持久化<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="RDB文件存储位置" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#rdb文件存储位置"><!---->RDB文件存储位置<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="什么时候执行持久化" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#什么时候执行持久化"><!---->什么时候执行持久化<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="RDB执行过程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#rdb执行过程"><!---->RDB执行过程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="RDB快照写时复制" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#rdb快照写时复制"><!---->RDB快照写时复制<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="AOF" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#aof"><!---->AOF<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="开启AOF持久化" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#开启aof持久化"><!---->开启AOF持久化<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="AOF日志记录" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#aof日志记录"><!---->AOF日志记录<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="AOF写入" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#aof写入"><!---->AOF写入<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="AOF三种刷盘策略" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#aof三种刷盘策略"><!---->AOF三种刷盘策略<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="AOF重写" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#aof重写"><!---->AOF重写<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="AOF重写优化" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#aof重写优化"><!---->AOF重写优化<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="混合持久化" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#混合持久化"><!---->混合持久化<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="MP方案" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#mp方案"><!---->MP方案<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="大Key对持久化的影响" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#大key对持久化的影响"><!---->大Key对持久化的影响<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="AOF日志写入" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#aof日志写入"><!---->AOF日志写入<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="AOF重写&amp;RDB快照" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#aof重写-rdb快照"><!---->AOF重写&amp;RDB快照<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="总结" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#总结"><!---->总结<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="持久化对过期键的处理" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#持久化对过期键的处理"><!---->持久化对过期键的处理<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="RDB" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#rdb-1"><!---->RDB<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="AOF" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html#aof-1"><!---->AOF<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a aria-label="Redis持久化面试题汇总" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis持久化面试题汇总<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis高可用" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E9%AB%98%E5%8F%AF%E7%94%A8.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis高可用<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis高可用面试题汇总" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis高可用面试题汇总<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis应用场景" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis应用场景<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis应用场景面试题汇总" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis应用场景面试题汇总<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis设计" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E8%AE%BE%E8%AE%A1.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis设计<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-mysql" style=""></span><span class="vp-sidebar-title">MySQL</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-java" style=""></span><span class="vp-sidebar-title">Java</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-OS" style=""></span><span class="vp-sidebar-title">OS</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->Redis持久化</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="/" target="_blank" rel="noopener noreferrer">LGYNB</a></span><span property="author" content="LGYNB"></span></span><!----><!----><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 26 分钟</span><meta property="timeRequired" content="PT26M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#持久化介绍">持久化介绍</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#持久化方式">持久化方式</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#两种方式的区别">两种方式的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#适用场景">适用场景</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#rdb">RDB</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#开启rdb持久化">开启RDB持久化</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#rdb文件存储位置">RDB文件存储位置</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#什么时候执行持久化">什么时候执行持久化</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#rdb执行过程">RDB执行过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#rdb快照写时复制">RDB快照写时复制</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#aof">AOF</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#开启aof持久化">开启AOF持久化</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#aof日志记录">AOF日志记录</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#aof写入">AOF写入</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#aof三种刷盘策略">AOF三种刷盘策略</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#aof重写">AOF重写</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#aof重写优化">AOF重写优化</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#混合持久化">混合持久化</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#mp方案">MP方案</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#大key对持久化的影响">大Key对持久化的影响</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#aof日志写入">AOF日志写入</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#aof重写-rdb快照">AOF重写&amp;RDB快照</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#总结">总结</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#持久化对过期键的处理">持久化对过期键的处理</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#rdb-1">RDB</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#aof-1">AOF</a></li><!----><!--]--></ul></li><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h1 id="redis持久化" tabindex="-1"><a class="header-anchor" href="#redis持久化" aria-hidden="true">#</a> Redis持久化</h1><h2 id="持久化介绍" tabindex="-1"><a class="header-anchor" href="#持久化介绍" aria-hidden="true">#</a> 持久化介绍</h2><p>Redis是跑在内存里的，当程序重启或者服务崩溃，数据就会全部丢失</p><p>如果业务场景希望重启之后数据还在，就需要持久化，即把数据保存到可永久保存的存储设备中</p><h3 id="持久化方式" tabindex="-1"><a class="header-anchor" href="#持久化方式" aria-hidden="true">#</a> 持久化方式</h3><p>两种方式：</p><ul><li><strong>RDB</strong>(Redis Database)，记录Redis某个时刻的全部数据，这种方式的本质就是数据快照，直接保存二进制数据到磁盘，后续通过加载RDB文件恢复数据</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231110152837022.png" alt="image-20231110152837022" tabindex="0" loading="lazy"><figcaption>image-20231110152837022</figcaption></figure><ul><li><strong>AOF</strong>(Append Only File)，记录执行的每条命令，重启之后通过重放命令来恢复数据，AOF的本质是记录操作日志，后续通过日志重放恢复数据</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231110153016136.png" alt="image-20231110153016136" tabindex="0" loading="lazy"><figcaption>image-20231110153016136</figcaption></figure><h3 id="两种方式的区别" tabindex="-1"><a class="header-anchor" href="#两种方式的区别" aria-hidden="true">#</a> 两种方式的区别</h3><p>RDB是快照恢复，AOF是日志恢复</p><ul><li><strong>体积方面</strong>：相同数据量下，RDB体积更小，因为RDB是记录的二进制紧凑型数据</li><li><strong>恢复速度</strong>：RDB是数据快照，可以直接加载，AOP文件恢复相当于重放情况，RDB会更快</li><li><strong>数据完整性</strong>：AOF记录了每条日志，RDB是每隔一段时间记录一次，用AOF恢复数据通常会更完整</li></ul><h3 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景" aria-hidden="true">#</a> 适用场景</h3><p>三种情况：对数据不怎么重视(缓存)(<strong>都不开</strong>)；对数据非常重视(<strong>都开</strong>)；可以接受丢几分钟的数据(<strong>只开RDB</strong>)</p><p>如果业务本身<strong>只是一个缓存</strong>而不是海量访问，<strong>可以不用开持久化</strong></p><p>如果<strong>对数据非常重视</strong>，可以<strong>同时开启RDB和AOF</strong></p><ul><li>同时开启的情况下，只会用AOF来加载</li><li>在AOF开启的情况下，说明业务对数据一致性要求较高，则如果此时只有RDB文件而没有AOF文件的话，Redis不会用RDB去恢复数据 <ul><li>因为RDB会少很多数据，此时启动Redis会是一个空库</li><li>这种情况下需要手动使用RDB快照恢复数据</li></ul></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231110153947239.png" alt="image-20231110153947239" tabindex="0" loading="lazy"><figcaption>image-20231110153947239</figcaption></figure><p>如果业务<strong>可以接受丢几分钟的数据</strong>，那么建议只开RDB。</p><blockquote><p>这里可以将RDB理解为一种原始且好用的数据备份手段，而AOF则是在业务对数据一致性要求较高的情况下需要打开的plus功能</p></blockquote><p><strong>Redis官方不建议单独开AOF</strong>，因为如果决定要数据备份，那么镜像保存始终是数据库领域非常行之有效的解决方案，所以RDB是默认打开的，而AOF不是</p><blockquote><p><strong>为什么官方不建议单独开AOF</strong></p><p>Redis的官方文档有提到，<strong>RDB 最大限度地提高了 Redis 的性能</strong>，因为 Redis 父进程为了持久化需要做的唯一工作就是派生一个子进程，该子进程将完成其余所有工作。父进程永远不会执行磁盘 I/O 或类似操作。 如果是AOF的话，如果配置的是<strong>Always策略</strong>，那么是<strong>由主进程与磁盘进行交互的</strong> 而且通常 ，Redis大部分的使用场景是用于<strong>缓存，对数据持久化的数据一致性要求并不高</strong>，有的时候甚至不需要持久化，所以更<strong>不需要使用数据一致性程度较高但会带来更大开销的AOF</strong>来完成持久化 对于AOF的开销 首先是<strong>AOF文件会比RDB文件大</strong>，而且<strong>恢复速度也比较慢</strong> 同时，如果AOF文件打到一定的体积，就会<strong>触发AOF重写，会有进一步的CPU开销</strong>，同时重新给过程中也<strong>会占用一定的内存</strong>(因为重写期间的写入会记录在内存的缓冲区中)。</p><p>总结：</p><ol><li>RDB性能比AOF好</li><li>Redis大部分场景对数据一致性要求不高</li><li>AOF的开销大</li><li>AOF无法记录真实的过期时间(会根据命令重置过期时间)</li></ol></blockquote><h2 id="rdb" tabindex="-1"><a class="header-anchor" href="#rdb" aria-hidden="true">#</a> RDB</h2><h3 id="开启rdb持久化" tabindex="-1"><a class="header-anchor" href="#开启rdb持久化" aria-hidden="true">#</a> 开启RDB持久化</h3><p>redis配置文件<code>redis.conf</code>中有三条默认的配置，表示<strong>Redis已经默认开启了RDB持久化</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>save <span class="token number">900</span> <span class="token number">1</span>
save <span class="token number">300</span> <span class="token number">10</span>
save <span class="token number">60</span> <span class="token number">10000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的配置语法是<code>save interval num</code></p><ul><li>表示间隔<code>interval</code>秒，至少有<code>num</code>条写操作，就会激活RDB持久化</li><li>这里的写操作包括增删改</li><li>可以配置多条，表示或的关系，即只要满足以上条件其中之一，就达到了RDB持久化的条件</li><li>这里的<code>save</code>配置执行的是<code>bgsave</code>命令，异步执行RDB持久化</li></ul><blockquote><p>Redis 的快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。</p><p>执行快照是一个比较重的操作。如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。通常可能设置至少 5 分钟才保存一次快照，这时如果 Redis 出现宕机等情况，则意味着最多可能丢失 5 分钟数据。</p><p>RDB 快照的缺点，在服务器发生故障时，<strong>丢失的数据会比 AOF 持久化的方式更多</strong>，因为 <strong>RDB 快照是全量快照的方式，因此执行的频率不能太频繁，否则会影响 Redis 性能</strong></p></blockquote><h3 id="rdb文件存储位置" tabindex="-1"><a class="header-anchor" href="#rdb文件存储位置" aria-hidden="true">#</a> RDB文件存储位置</h3><p>同样在Redis配置文件<code>redis.conf</code>中</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># The filename where to dump the DB</span>
dbfilename dump.rdb

<span class="token comment"># The working directory</span>
<span class="token function">dir</span> /Users/niuniumart/code/redis
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>RDB文件是一个二进制文件，文件头有个<code>REDIS</code>字符串作为标记</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231111123503537.png" alt="image-20231111123503537" tabindex="0" loading="lazy"><figcaption>image-20231111123503537</figcaption></figure><h3 id="什么时候执行持久化" tabindex="-1"><a class="header-anchor" href="#什么时候执行持久化" aria-hidden="true">#</a> 什么时候执行持久化</h3><ul><li>主动执行<code>save</code>命令 <ul><li>Redis会在主线程生成RDB文件，</li><li>由于和执行操作在同一个线程，所以如果写入RDB文件的时间太长，会阻塞主线程</li></ul></li><li>主动执行<code>bgsave</code>命令 <ul><li>Redis会创建一个子进程来生成RDB文件，避免主线程的阻塞</li></ul></li><li>达到持久化配置阈值 <ul><li>Redis可以配置持久化策略，达到策略就会触发持久化</li><li>这里持久化的方式是后台save(backgroudSave)</li><li>由周期函数检查是否达到策略要求，达到就触发bgsave</li></ul></li><li>程序正常关闭的时候执行 <ul><li>在关闭时，Redis会启动一次阻塞式持久化(save)</li><li>正常关闭的数据不会丢失，崩溃才会</li><li>考虑主从同步的话，主节点没崩溃，从节点崩溃了，就算主节点正常关闭也可能丢失数据</li></ul></li><li>主从全量复制发送RDB文件 (也进行一次RDB持久化)</li><li>客户端执行数据库清空命令<code>FLUSHALL</code></li></ul><h3 id="rdb执行过程" tabindex="-1"><a class="header-anchor" href="#rdb执行过程" aria-hidden="true">#</a> RDB执行过程</h3><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231111125618852.png" alt="image-20231111125618852" tabindex="0" loading="lazy"><figcaption>image-20231111125618852</figcaption></figure><p><strong>具体流程</strong>：</p><ol><li>Fork出一个子进程专门做RDB持久化</li><li>子进程写数据到临时的RDB文件</li><li>写完用新的RDB文件替换旧的RDB文件</li></ol><h3 id="rdb快照写时复制" tabindex="-1"><a class="header-anchor" href="#rdb快照写时复制" aria-hidden="true">#</a> RDB快照写时复制</h3><p>执行RDB持久化过程中(<code>bgsave</code>)，Redis依然是可以继续处理操作命令的，也就是数据是能被修改的，这是通过<strong>写时复制</strong>技术实现的</p><ul><li><p>执行<code>bgsave</code>命令，fork创建子进程后，子进程和父进程共享一片内存数据</p></li><li><p>创建子进程时，只会复制父进程的页表，页表指向的物理内存是同一个</p></li><li><p>只有<strong>主线程发生修改内存数据的情况时，物理内存才会被复制一份</strong></p><ul><li>旧的共享内存交给子进程去执行RDB持久化，新的物理内存用于主线程的写操作</li></ul></li></ul><p><strong>写时复制的目的是为了减少创建子进程时的性能损耗，加快创建子进程的速度</strong>，创建子进程的过程中主线程是被阻塞的</p><p>在创建<code>bgsave</code>子进程后，由于共享父进程的所有内存数据，就可以直接读取主进程(父进程)里面的内存数据，并将数据写入RDB文件中</p><ul><li><p>当主线程(父进程)对这些共享的内存数据只执行读操作，那么，主线程（父进程）和 bgsave 子进程相互不影响。</p></li><li><p>当主线程（父进程）要<strong>修改共享数据里的某一块数据</strong>（比如数据 <code>A</code>）时，就会发生写时复制</p><ul><li>这块数据的<strong>物理内存就会被复制一份（数据<code>A&#39;</code>）</strong></li><li>然后<strong>主线程在这个数据副本（数据 <code>A&#39;</code>）进行修改操作</strong>。</li><li><strong>bgsave 子进程可以继续把原来的数据（数据 <code>A</code>）写入到 RDB 文件</strong>。</li></ul></li></ul><p>Redis 在使用 <code>bgsave</code> 持久化RDB快照过程中</p><ul><li>如果<strong>主线程修改了内存数据，不管是否是共享的内存数据，RDB 快照都无法写入主线程刚修改的数据</strong></li><li>因为此时主线程（父进程）的内存数据和子进程的内存数据已经分离了，子进程<strong>写入到 RDB 文件的内存数据只能是原本的内存数据</strong></li><li>如果<strong>系统恰好在 RDB 快照文件创建完毕后崩溃了，那么 Redis 将会丢失主线程在快照期间修改的数据。</strong></li></ul><blockquote><p>极端情况下，<strong>如果所有的共享内存都被修改，则此时的内存占用是原先的 2 倍。</strong></p><p>所以，针对写操作多的场景，我们要留意下快照过程中内存的变化，防止内存被占满了。</p></blockquote><h2 id="aof" tabindex="-1"><a class="header-anchor" href="#aof" aria-hidden="true">#</a> AOF</h2><h3 id="开启aof持久化" tabindex="-1"><a class="header-anchor" href="#开启aof持久化" aria-hidden="true">#</a> 开启AOF持久化</h3><p>在<code>redis.conf</code>配置文件中可以看到</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>appendonly no

<span class="token comment"># The name of the append only file (default:&quot;appendonly.aof&quot;)</span>
appendfileame <span class="token string">&quot;appendonly.aof&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><code>appendonly</code>设置为yes就可以打开AOF</p><ul><li>可以看出Redis官方认为RDB绝大多数时候还是需要的，而AOF更依赖实际的业务场景</li></ul></li><li><p>AOF打开之后，Redis每条更改数据的操作都会记录到AOF文件中</p></li><li><p>当Redis重启，AOF就会重建状态，相当于全部请求重放一次，所以AOF恢复起来会很慢</p></li></ul><p>执行的命令写入AOF文件时，如果带有过期时间，是直接将过期时间写进AOF文件的(7.0之后转成毫秒)</p><ul><li>例如：<code>SET a b EX 1800</code>，过五分钟后，重启Redis服务，执行<code>TTL a</code>，输出的还是1800左右的数值</li></ul><h3 id="aof日志记录" tabindex="-1"><a class="header-anchor" href="#aof日志记录" aria-hidden="true">#</a> AOF日志记录</h3><h4 id="aof日志格式" tabindex="-1"><a class="header-anchor" href="#aof日志格式" aria-hidden="true">#</a> AOF日志格式</h4><p>AOF写入的方式跟Redis本身的协议是一样的</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/337021a153944fd0f964ca834e34d0f2.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><code>*3</code>表示当前命令有三个部分，每部分都是以<code>$+数字</code>开头，后面紧跟着具体的命令、键或值</li><li>这里的<code>数字</code>表示这部分中的命令、键或值一共有多少字节 <ul><li>例如，<code>$3 set</code>表示这部分有 3 个字节，也就是<code>set</code>命令这个字符串的长度。</li></ul></li></ul><h4 id="aof日志记录流程" tabindex="-1"><a class="header-anchor" href="#aof日志记录流程" aria-hidden="true">#</a> AOF日志记录流程</h4><p><strong>执行请求时，每条日志都会写入AOF</strong></p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/28afd536c57a46447ddab0a2062abe84.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="先执行再记录的好处" tabindex="-1"><a class="header-anchor" href="#先执行再记录的好处" aria-hidden="true">#</a> 先执行再记录的好处</h4><p>Redis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处。</p><ul><li><p><strong>避免额外的检查开销</strong></p><ul><li>因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行<strong>命令语法检查</strong>，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。</li><li>而如果先执行写操作命令再记录日志的话，只有在该命令执行成功后，才将命令记录到 AOF 日志里，这样就不用额外的检查开销，<strong>保证记录在 AOF 日志里的命令都是可执行并且正确的</strong>。</li></ul></li><li><p><strong>不会阻塞当前写操作命令的执行</strong></p><ul><li>因为当写操作命令<strong>执行成功后</strong>，才会将命令<strong>记录</strong>到 AOF 日志。</li></ul></li></ul><h4 id="aof持久化功能的潜在风险" tabindex="-1"><a class="header-anchor" href="#aof持久化功能的潜在风险" aria-hidden="true">#</a> <strong>AOF持久化功能的潜在风险</strong></h4><ul><li><p>执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有<strong>丢失的风险</strong>。</p></li><li><p>由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是<strong>可能会给下一个命令带来阻塞风险</strong>。</p><ul><li>因为将<strong>命令写入到日志的这个操作也是在主进程完成的</strong>（执行命令也是在主进程），也就是说这两个操作是同步的。</li></ul></li></ul><h3 id="aof写入" tabindex="-1"><a class="header-anchor" href="#aof写入" aria-hidden="true">#</a> AOF写入</h3><h4 id="aof持久化流程" tabindex="-1"><a class="header-anchor" href="#aof持久化流程" aria-hidden="true">#</a> AOF持久化流程</h4><ol><li>将数据写入AOF缓冲区中，AOF缓冲区名为<code>aof_buf</code>，是个sds数据</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>sds aof_buf<span class="token punctuation">;</span>	/* AOF buffer, written before entering the event loop */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2"><li>通过<code>write()</code>系统调用，将<code>aof_buf</code>缓冲区的数据写入到AOF文件中，然后将AOF文件拷贝到<strong>内核缓冲区(page cache)</strong>。</li><li>刷盘，内核将内核缓冲区的数据写入到磁盘中</li></ol><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/4eeef4dd1bedd2ffe0b84d4eaa0dbdea.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="aof三种刷盘策略" tabindex="-1"><a class="header-anchor" href="#aof三种刷盘策略" aria-hidden="true">#</a> AOF三种刷盘策略</h3><blockquote><p><strong>刷盘</strong>：真正写入到磁盘中称为刷盘</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231112092119676.png" alt="image-20231112092119676" tabindex="0" loading="lazy"><figcaption>image-20231112092119676</figcaption></figure><ul><li><code>appendfsync always</code>：每次请求都刷入AOF，非常慢，非常安全</li><li><code>appendfsync everysec</code>：每秒刷一次盘，足够快了，但是崩溃的场景下会丢失1秒的数据</li><li><code>appendfsync no</code>：不主动刷盘，让操作系统自己刷，一般Linux 每30秒会刷一次盘，这种策略下对性能影响最小，但是如果发生崩溃，丢失的数据会比较多</li></ul><blockquote><p><strong>Redis的建议是方案2</strong></p></blockquote><p>3 种刷盘策略都无法完美解决「<strong>主进程阻塞</strong>」和「<strong>减少数据丢失</strong>」的问题，两个问题是对立的，偏向于一边的话，就会要牺牲另外一边</p><ul><li><strong>Always</strong>：可以最大程度保证数据不丢失，但是由于它每执行一条写操作命令就同步将 AOF 内容写回硬盘，所以是不可避免会影响主进程的性能；</li><li><strong>No</strong> ：是交由操作系统来决定何时将 AOF 日志内容写回硬盘，相比于 Always 策略性能较好，但是操作系统写回硬盘的时机是不可预知的，如果 AOF 日志内容没有写回硬盘，一旦服务器宕机，就会丢失不定数量的数据。</li><li><strong>Everysec</strong>： 策略的话，是折中的一种方式，避免了 Always 策略的性能开销，也比 No 策略更能避免数据丢失，当然如果上一秒的写操作命令日志没有写回到硬盘，发生了宕机，这一秒内的数据自然也会丢失。</li></ul><blockquote><p>如果要<strong>高性能</strong>，就选择 <strong>No</strong> 策略；</p><p>如果要<strong>高可靠</strong>，就选择 <strong>Always</strong> 策略；</p><p>如果<strong>允许数据丢失一点，但又想性能高</strong>，就选择 <strong>Everysec</strong> 策略。</p></blockquote><h4 id="刷盘策略原理" tabindex="-1"><a class="header-anchor" href="#刷盘策略原理" aria-hidden="true">#</a> 刷盘策略原理</h4><blockquote><p><code>fsync()</code> 函数的主要目的是将文件系统中的数据缓冲区中的数据强制写入磁盘，以确保数据的持久性。</p></blockquote><p>三种刷盘策略只是在控制<code>fsync()</code>函数的调用时机</p><p>当应用程序向文件写入数据时，<strong>内核通常先将数据复制到内核缓冲区中，然后排入队列，然后由内核决定何时写入硬盘</strong>。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/f64829ffc2e9e006b090f9aae51035ee-16999312184554.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><strong>Always</strong> 策略就是每次写入 AOF 文件数据后，就执行 <code>fsync()</code> 函数；</li><li><strong>Everysec</strong> 策略就会创建一个异步任务来执行 <code>fsync()</code> 函数；</li><li><strong>No</strong> 策略就是永不执行 <code>fsync()</code> 函数;</li></ul><h3 id="aof重写" tabindex="-1"><a class="header-anchor" href="#aof重写" aria-hidden="true">#</a> AOF重写</h3><blockquote><p>AOF是不断写入的，这就会导致AOF文件不断变大</p></blockquote><h4 id="aof重写的原理" tabindex="-1"><a class="header-anchor" href="#aof重写的原理" aria-hidden="true">#</a> AOF重写的原理</h4><p>针对相同key的操作进行合并，同一个key的set操作，就是后面覆盖前面</p><p>AOF重写机制是在重写的时候，<strong>读取当前数据库的所有键值对，然后将每一个键值对用一条命令记录到新的AOF文件中</strong></p><p>等到<strong>全部记录完后，就将新的AOF文件替换掉现有的AOF文件</strong></p><ul><li>例如：在没有使用重写机制之前，前后执行了<code>SET a b</code>和<code>SET a c</code>两条命令，则AOF文件中会同时记录这两条命令</li><li>如果开启了AOF重写，Redis会读取a最新的value，然后用一条<code>set a c</code>命令记录到新的AOF文件中。</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/723d6c580c05400b3841bc69566dd61b.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="aof重写的好处" tabindex="-1"><a class="header-anchor" href="#aof重写的好处" aria-hidden="true">#</a> AOF重写的好处</h4><p>尽管某个键值对被多条写命令反复修改，<strong>最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对</strong>，代替之前记录这个键值对的多条命令，这样就减少了 AOF 文件中的命令数量。最后在重写工作完成后，将新的 AOF 文件覆盖现有的 AOF 文件。</p><blockquote><p>为什么重写 AOF 的时候，不直接复用现有的 AOF 文件，而是先写到新的 AOF 文件再覆盖过去？</p><p>因为<strong>如果 AOF 重写过程中失败了，现有的 AOF 文件就会造成污染</strong>，可能无法用于恢复使用。所以 AOF 重写过程，先重写到新的 AOF 文件，<strong>重写失败的话，就直接删除这个文件就好，不会对现有的 AOF 文件造成影响</strong>。</p></blockquote><h4 id="aof重写流程" tabindex="-1"><a class="header-anchor" href="#aof重写流程" aria-hidden="true">#</a> AOF重写流程</h4><ol><li><p>当AOF文件大小超过设定阈值，Redis主进程<code>fork</code>一个<code>bgrewriteaof</code>子进程进行AOF重写操作</p><ul><li>子进程<strong>读取数据库中所有的键值对，并将每一条键值对转化成一条命令</strong></li></ul></li><li><p>子进程在工作时不会阻塞主进程，此时主进程除了正常的执行命令和写AOF日志之外，<strong>还需要将日志写入AOF缓冲区</strong></p><ul><li>主进程会<strong>执行客户端发来的命令</strong><ul><li>(写时复制)执行修改命令时会复制一份物理内存(<u>阻塞</u>)并对这份复制的内存进行修改</li></ul></li><li>将执行完的命令<strong>追加到AOF缓冲区</strong>(写AOF日志)</li><li>将执行完的命令<strong>追加到AOF重写缓冲区</strong></li></ul></li><li><p>子进程结束AOF重写之后会<strong>给Redis主进程发送一条信号</strong></p></li><li><p>主进程收到子进程的信号之后会<strong>调用一个信号处理函数</strong>(<u>阻塞</u>)</p><ul><li><strong>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中</strong>，使得新旧两个 AOF 文件所保存的数据库状态一致</li><li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件</li></ul></li><li><p>信号函数执行完后，主进程恢复正常</p></li></ol><blockquote><p>在整个 AOF 后台重写过程中，除了<strong>发生写时复制和信号处理函数执行时会对主进程造成阻塞</strong>，在其他时候，AOF 后台重写都不会影响到主进程。</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70-20230309231944807.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><blockquote><p><strong>后台子进程执行AOF重写的好处</strong></p></blockquote><ul><li>(后台)：避免阻塞主进程</li><li>(子进程)：利用写时复制技术，不用加锁</li></ul><blockquote><p><strong>为什么使用子进程而不用子线程？</strong></p></blockquote><ul><li>使用线程：<strong>多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全</strong>，这样会降低性能</li><li>使用进程：创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「<strong>写时复制</strong>」，<strong>父子进程有独立的数据副本，就不用加锁来保证数据安全</strong>。</li></ul><h2 id="aof重写优化" tabindex="-1"><a class="header-anchor" href="#aof重写优化" aria-hidden="true">#</a> AOF重写优化</h2><h3 id="混合持久化" tabindex="-1"><a class="header-anchor" href="#混合持久化" aria-hidden="true">#</a> 混合持久化</h3><p>混合持久化：用保存RDB快照的方式替换AOF重写过程中子进程的工作</p><p>混合持久化发生在AOF重写阶段。</p><h4 id="开启混合持久化" tabindex="-1"><a class="header-anchor" href="#开启混合持久化" aria-hidden="true">#</a> 开启混合持久化</h4><p>在<code>redis.conf</code>配置文件中修改以下配置</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>aof-use-rdb-preamble <span class="token function">yes</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>开启了混合持久化的文件开头会有<code>REDIS</code>标记</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231114230355807.png" alt="image-20231114230355807" tabindex="0" loading="lazy"><figcaption>image-20231114230355807</figcaption></figure><h4 id="混合持久化的过程" tabindex="-1"><a class="header-anchor" href="#混合持久化的过程" aria-hidden="true">#</a> 混合持久化的过程</h4><p>开启了混合持久化，AOF重写<code>fork</code>出来的子进程就不再去数据库中读取键值对数据并将其转化为命令存入日志了，而是直接使用RDB的方式，将当前数据库的快照以二进制数据的方式直接存入新的AOF文件中。</p><p>而在执行RDB快照的过程中，主进程执行的客户端写命令同样会放入重写缓冲区中</p><p>待RDB快照执行结束后，子进程发一个信号告诉主进程，主进程调用信号执行函数，将AOF重写缓冲区中的命令增加到新的AOF文件中。</p><p>缓冲区中的命令记录完成后，信号执行函数修改AOF文件的名称并覆盖掉旧的AOF文件</p><p>此时新的AOF文件中，前半部分是RDB格式的全量数据，后半部分是AOF格式的增量数据。</p><h4 id="混合持久化的好处" tabindex="-1"><a class="header-anchor" href="#混合持久化的好处" aria-hidden="true">#</a> 混合持久化的好处</h4><p>重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会快很多</strong></p><p>大大降低AOF重写的性能损耗，以及降低AOF文件的存储空间</p><blockquote><p>付出的代价则是降低AOF文件的可读性，但是实际生产中很少出现人读AOF文件的情况</p><p>5.0之后就默认开启AOF混合持久化了</p></blockquote><h4 id="解决问题" tabindex="-1"><a class="header-anchor" href="#解决问题" aria-hidden="true">#</a> 解决问题</h4><p>混合持久化本质上还是AOF，只是重写的时候使用了RDB进行优化，</p><p>混合持久化可以看成是一种折中方案：可读性降低的AOF/性能变差的RDB</p><ul><li>如果考虑对Redis核心处理性能的影响——使用RDB</li><li>如果为了更加可靠的数据记录，尽可能少的丢失数据——使用AOF <ul><li>同时如果对可读性没有太高要求——开启混合持久化</li></ul></li></ul><blockquote><p>实际生产中，关注AOF可读性的情况比较少</p></blockquote><h4 id="数据的加载方式" tabindex="-1"><a class="header-anchor" href="#数据的加载方式" aria-hidden="true">#</a> 数据的加载方式</h4><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231114121143526.png" alt="image-20231114121143526" tabindex="0" loading="lazy"><figcaption>image-20231114121143526</figcaption></figure><h3 id="mp方案" tabindex="-1"><a class="header-anchor" href="#mp方案" aria-hidden="true">#</a> MP方案</h3><h4 id="原有aof重写方案弊端" tabindex="-1"><a class="header-anchor" href="#原有aof重写方案弊端" aria-hidden="true">#</a> 原有AOF重写方案弊端</h4><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231114123256701.png" alt="image-20231114123256701" tabindex="0" loading="lazy"><figcaption>image-20231114123256701</figcaption></figure><ul><li><strong>占用主进程CPU时间</strong><ul><li>在重写期间额外向重写缓冲区<code>aof_rewrite_buf</code>写数据</li><li>通过管道向子进程发送<code>aof_rewrite_buf</code>中的数据</li><li>子进程结束后将剩余<code>aof_rewrite_buf</code>写入临时文件</li></ul></li></ul><blockquote><p>通过管道传递信息给子进程，让子进程写磁盘是3.2引入的优化，更早版本是主进程直接写，这样更容易影响正常需求</p></blockquote><ul><li><strong>额外的内存开销</strong><ul><li>在AOF重写期间，主进程会将fork之后的数据变化同时写入<code>aof_buf</code>和<code>aof_rewrite_buf</code>中，这部分内容是重复的</li><li>而且在子进程读取的时候，还会开辟一块读取内存空间</li></ul></li><li><strong>额外的磁盘开销</strong><ul><li>主进程除了会将执行过的写命令写道<code>aof_buf</code>之外，还会写一份到<code>aof_rewrite_buf</code>中，</li><li><code>aof_buf</code>最终写入旧文件，<code>aof_rewrite_buf</code>最终写入新文件，这相当于两次磁盘消耗，而数据却是一样的</li></ul></li></ul><p>总结为<strong>两个不合理的设计：</strong></p><ul><li>同<strong>时向<code>aof_buf</code>和<code>aof_rewrite_buf</code>写入</strong></li><li><strong>父进程将aof重写缓冲区的数据传给子进程，子进程再将数据写入新文件</strong></li></ul><h4 id="mp-aof方案" tabindex="-1"><a class="header-anchor" href="#mp-aof方案" aria-hidden="true">#</a> MP-AOF方案</h4><p>MP-AOF，全程MultiPartAOF，多部件AOF</p><p>通俗点说就是，原来一个AOF文件，现在多个AOF文件相互配合</p><p>主要有两个Part，这两个部件合组成完整的AOF操作记录</p><ul><li>BASE AOF文件，基础AOF文件，记录了基本命令</li><li>INCR AOF文件，记录了在重写过程中新增的操作命令</li></ul><h4 id="mp-aof方案流程" tabindex="-1"><a class="header-anchor" href="#mp-aof方案流程" aria-hidden="true">#</a> MP-AOF方案流程</h4><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231114225505695.png" alt="image-20231114225505695" tabindex="0" loading="lazy"><figcaption>image-20231114225505695</figcaption></figure><ul><li><p>在重写阶段，主进程直接写进AOF缓冲区就可以</p></li><li><p>AOF缓冲区的数据最终落在新打开的<code>incr.aof</code>文件中</p></li><li><p>子进程就根据fork时的数据库数据，重写并生成一个<code>base.aof</code>文件</p></li><li><p>写完之后更新<code>Mainfest</code>文件</p><ul><li><code>Mainfest</code>文件可以认为是一个配置文件</li><li>描述了当前有效的<code>base.aof</code>和<code>incr.aof</code>是哪个</li></ul></li><li><p>Redis会将旧的<code>base.aof</code>和<code>incr.aof</code>其标记为<code>history.aof</code>文件</p><ul><li>这些<code>history.aof</code>文件会被Redis异步删除掉</li></ul></li></ul><blockquote><p><code>base.aof</code>的全名为<code>appendonly.aof.1.base.rdb</code>——Redis7.0后默认开启混合持久化，所以后缀是rdb，不开启就还是aof</p><p><code>incr.aof</code>的全名为<code>appendonly.aof.1.incr.aof</code></p><p><code>mainfest</code>的全名为<code>appendonly.aof.mainfest</code></p></blockquote><h4 id="解决问题-1" tabindex="-1"><a class="header-anchor" href="#解决问题-1" aria-hidden="true">#</a> 解决问题</h4><ul><li>AOFRW期间不需要<code>aof_rewrite_buf</code></li><li>不需要父进程通过管道传输数据</li></ul><h4 id="mp方案下的数据流向" tabindex="-1"><a class="header-anchor" href="#mp方案下的数据流向" aria-hidden="true">#</a> MP方案下的数据流向</h4><ul><li>AOF缓冲区的数据最终会进入INCR.aof中，也就是说，主进程的所有数据都是流向INCR.aof</li></ul><h2 id="大key对持久化的影响" tabindex="-1"><a class="header-anchor" href="#大key对持久化的影响" aria-hidden="true">#</a> 大Key对持久化的影响</h2><h3 id="aof日志写入" tabindex="-1"><a class="header-anchor" href="#aof日志写入" aria-hidden="true">#</a> AOF日志写入</h3><p><strong>Always</strong>：当使用 Always 策略的时候，如果写入是一个大 Key，主线程在执行 fsync() 函数的时候，阻塞的时间会比较久，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的</p><p><strong>Everysec</strong>：由于是异步执行 <code>fsync()</code> 函数，所以大 Key 持久化的过程（数据同步磁盘）不会影响主线程。</p><p><strong>No</strong>：由于永不执行 <code>fsync()</code> 函数，所以大 Key 持久化的过程不会影响主线程。</p><h3 id="aof重写-rdb快照" tabindex="-1"><a class="header-anchor" href="#aof重写-rdb快照" aria-hidden="true">#</a> AOF重写&amp;RDB快照</h3><h4 id="fork阻塞" tabindex="-1"><a class="header-anchor" href="#fork阻塞" aria-hidden="true">#</a> fork阻塞</h4><p>AOF 重写机制和 RDB 快照（bgsave 命令）的过程，都会分别通过 <code>fork()</code> 函数创建一个子进程来处理任务。</p><p>由于写时复制技术，父进程只会复制自己的页表给子进程</p><p>随着 Redis 存在越来越多的大 Key，那么 Redis 就会占用很多内存，对应的页表就会越大。</p><p>在通过 <code>fork()</code> 函数创建子进程的时候，<strong>内核会把父进程的页表复制一份给子进程，如果页表很大，那么这个复制过程是会很耗时的，那么在执行 fork 函数的时候就会发生阻塞现象</strong></p><p>fork 函数是由 Redis 主线程调用的，如果 fork 函数发生阻塞，那么意味着就会阻塞 Redis 主线程，也就无法处理后续客户端发来的命令</p><p>如果 fork 耗时很大，比如超过1秒，则需要做出优化调整：</p><ul><li>单个实例的内存占用控制在 10 GB 以下，这样 fork 函数就能很快返回。</li><li>如果 Redis 只是当作纯缓存使用，不关心 Redis 数据安全性问题，可以考虑关闭 AOF 和 AOF 重写，这样就不会调用 fork 函数了。</li><li>在主从架构中，要适当调大 <code>repl-backlog-size</code>，避免因为 <code>repl_backlog_buffer</code> 不够大，导致主节点频繁地使用全量同步的方式，全量同步的时候，是会创建 RDB 文件的，也就是会调用 fork 函数。</li></ul><h4 id="写时复制大key的物理内存" tabindex="-1"><a class="header-anchor" href="#写时复制大key的物理内存" aria-hidden="true">#</a> 写时复制大Key的物理内存</h4><p>父进程对大Key进行修改，内核会发生写时复制，会把物理内存复制一份，由于大Key的物理内存是比较大的，所以复制物理内存的时候就会发生阻塞</p><blockquote><p>如果 <strong>Linux 开启了内存大页，会影响 Redis 的性能的</strong>。</p><p>Linux 内核从 2.6.38 开始支持内存大页机制，该机制支持 2MB 大小的内存页分配，而常规的内存页分配是按 4KB 的粒度来执行的。</p><p>如果采用了内存大页，那么即使客户端请求只修改 100B 的数据，在发生写时复制后，Redis 也需要拷贝 2MB 的大页。相反，如果是常规内存页机制，只用拷贝 4KB。</p><p>两者相比，你可以看到，每次写命令引起的<strong>复制内存页单位放大了 512 倍，会拖慢写操作的执行时间，最终导致 Redis 性能变慢</strong>。</p><p>内存大页默认是关闭的</p></blockquote><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p><strong>Redis大Key对持久化的影响</strong>主要分为三个方面</p><ul><li>当AOF刷盘策略配置了Always时，如果此时写入一个大Key，主线程执行<code>fsync()</code>函数时阻塞的时间会比较久</li><li>AOF重写和RDB快照过程中进行的写时复制操作有可能会阻塞主进程 <ul><li><code>fork()</code>子进程过程中，复制页表大小如果过大，阻塞的时间也会较久</li><li>父进程发生写时复制，拷贝大Key的物理内存时阻塞的时间会比较久</li></ul></li></ul><p><strong>大Key除了会影响持久化之外，还会影响其他方面</strong></p><ul><li><strong>客户端超时阻塞</strong>：由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li><li><strong>引发网络阻塞</strong>：每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li><li><strong>阻塞工作线程</strong>：如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li><li><strong>内存分布不均</strong>：集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</li></ul><p><strong>如何避免大 Key 呢</strong></p><ul><li>在设计阶段，把大 key <strong>拆分</strong>成一个一个小 key</li><li>定时检查 Redis 是否存在大 key ，如果该大 key 是可以<strong>删除</strong>的，不要使用 DEL 命令删除，因为该命令删除过程会阻塞主线程，而是用 unlink 命令（Redis 4.0+）删除大 key，因为该命令的删除过程是异步的，不会阻塞主线程。</li></ul><h2 id="持久化对过期键的处理" tabindex="-1"><a class="header-anchor" href="#持久化对过期键的处理" aria-hidden="true">#</a> 持久化对过期键的处理</h2><h3 id="rdb-1" tabindex="-1"><a class="header-anchor" href="#rdb-1" aria-hidden="true">#</a> RDB</h3><p>RDB分为两个过程，一个是生成文件的过程，一个是载入文件的过程</p><p><strong>生成文件</strong></p><p>生成文件时会判断键是否过期，过期了就不放进快照里面</p><p><strong>载入文件</strong></p><p>主节点载入RDB文件时会检查键是否过期，过期了就不恢复出来</p><p>从节点载入RDB文件时不会检查，直接全量恢复，键被删除的时候，主节点会模拟一条DEL命令传给从节点让它们删除该过期键</p><blockquote><p>由于主从服务器在进行数据同步时，从服务器的数据会被清空</p><p>过期键对载入RDB文件的从服务器也不会造成影响</p></blockquote><h3 id="aof-1" tabindex="-1"><a class="header-anchor" href="#aof-1" aria-hidden="true">#</a> AOF</h3><p>AOF分为两种情况，一种是AOF写入，一种是AOF重写</p><p><strong>AOF写入</strong></p><p>AOF写入时不会检测键是否过期，有什么了命令就会写入什么命令，键过期被删除的时候Redis会向AOF文件追加一条DEL命令</p><p><strong>AOF重写</strong></p><p>AOF重写时会检测键是否过期，如果键已经过期，就不会将其转换为命令存入新AOF文件中</p></div><!--[--><!----><!--]--><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/lgy8888/my_blog.git/edit/main/src/backEnd/Redis/Redis持久化.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><nav class="vp-page-nav"><a aria-label="Redis与客户端" class="vp-link nav-link prev nav-link prev" href="/my_blog/backEnd/Redis/Redis%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF.html"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><span class="font-icon icon iconfont icon-write" style=""></span>Redis与客户端</div></a><a aria-label="Redis持久化面试题汇总" class="vp-link nav-link next nav-link next" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB.html"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">Redis持久化面试题汇总<span class="font-icon icon iconfont icon-write" style=""></span></div></a></nav><div id="comment" class="giscus-wrapper input-top" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">林光远的个人笔记网站</div><div class="vp-copyright">Copyright © 2024 LGYNB</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/my_blog/assets/app-OTaO6_y0.js" defer></script>
  </body>
</html>
