<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.0" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.2" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://vuepress-theme-hope-docs-demo.netlify.app/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><meta property="og:site_name" content="林光远的个人笔记"><meta property="og:title" content="Redis数据结构"><meta property="og:description" content="RedisObject Redis是Key-value存储，key只能存String，Value可以存Redis支持的所有数据类型 ```c typedef struct redisObject { unsigned type:4; unsigned encoding:4; unsigned lru:LRU BITS; int refcount; vo..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="LGYNB"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Redis数据结构","image":[""],"dateModified":null,"author":[{"@type":"Person","name":"LGYNB","url":"/"}]}</script><link rel="icon" href="/my_blog/favicon.ico"><title>Redis数据结构 | 林光远的个人笔记</title><meta name="description" content="RedisObject Redis是Key-value存储，key只能存String，Value可以存Redis支持的所有数据类型 ```c typedef struct redisObject { unsigned type:4; unsigned encoding:4; unsigned lru:LRU BITS; int refcount; vo...">
    <link rel="preload" href="/my_blog/assets/style-ERUp4lUP.css" as="style"><link rel="stylesheet" href="/my_blog/assets/style-ERUp4lUP.css">
    <link rel="modulepreload" href="/my_blog/assets/app-OTaO6_y0.js"><link rel="modulepreload" href="/my_blog/assets/Redis数据结构.html-rxfIoI7M.js"><link rel="modulepreload" href="/my_blog/assets/Redis数据结构.html-Ekc2wl8h.js"><link rel="modulepreload" href="/my_blog/assets/plugin-vue_export-helper-x3n3nnut.js">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand vp-brand" href="/my_blog/"><img class="vp-nav-logo" src="/my_blog/logo.png" alt="林光远的个人笔记"><!----><span class="vp-site-name hide-in-pad">林光远的个人笔记</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a aria-label="后端技术" class="vp-link nav-link active nav-link active" href="/my_blog/backEnd/"><span class="font-icon icon iconfont icon-back-stage" style=""></span>后端技术<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="Web开发" class="vp-link nav-link nav-link" href="/my_blog/webDevelop/"><span class="font-icon icon iconfont icon-config" style=""></span>Web开发<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="AI技术" class="vp-link nav-link nav-link" href="/my_blog/ai/"><span class="font-icon icon iconfont icon-function" style=""></span>AI技术<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="数据结构与算法" class="vp-link nav-link nav-link" href="/my_blog/coding/"><span class="font-icon icon iconfont icon-calculate" style=""></span>数据结构与算法<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="项目经历" class="vp-link nav-link nav-link" href="/my_blog/projects/"><span class="font-icon icon iconfont icon-code" style=""></span>项目经历<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/lgy8888/my_blog.git" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索本站" autocomplete="off" spellcheck="false" value><!----></form><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><span class="font-icon icon iconfont icon-cache" style=""></span><span class="vp-sidebar-title">Redis</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a aria-label="分布式系统理论" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA.html"><span class="font-icon icon iconfont icon-write" style=""></span>分布式系统理论<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis数据结构" class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active nav-link active vp-sidebar-link vp-sidebar-page active" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis数据结构<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="RedisObject" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#redisobject"><!---->RedisObject<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="redis存储对象的过程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#redis存储对象的过程"><!---->redis存储对象的过程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="数据类型" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#数据类型"><!---->数据类型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="String" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#string"><!---->String<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="内部实现" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#内部实现"><!---->内部实现<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="基本操作" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#基本操作"><!---->基本操作<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="应用场景" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#应用场景"><!---->应用场景<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="常见面试题" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#常见面试题"><!---->常见面试题<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="SDS" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#sds"><!---->SDS<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="SDS底层实现" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#sds底层实现"><!---->SDS底层实现<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="解决C原生字符串问题" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#解决c原生字符串问题"><!---->解决C原生字符串问题<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="SDS相比于C的原生字符串" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#sds相比于c的原生字符串"><!---->SDS相比于C的原生字符串<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="List" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#list"><!---->List<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="内部实现" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#内部实现-1"><!---->内部实现<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="常用命令" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#常用命令"><!---->常用命令<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="应用场景" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#应用场景-1"><!---->应用场景<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="压缩列表" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#压缩列表"><!---->压缩列表<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="解决问题" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#解决问题"><!---->解决问题<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="ZIPLIST整体结构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#ziplist整体结构"><!---->ZIPLIST整体结构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="ZIPLIST节点结构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#ziplist节点结构"><!---->ZIPLIST节点结构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="ZIPLIST查询数据" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#ziplist查询数据"><!---->ZIPLIST查询数据<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="ZIPLIST更新数据" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#ziplist更新数据"><!---->ZIPLIST更新数据<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="LISTPACK优化" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#listpack优化"><!---->LISTPACK优化<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Hash" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#hash"><!---->Hash<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="内部实现" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#内部实现-2"><!---->内部实现<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="常用命令" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#常用命令-1"><!---->常用命令<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="应用场景" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#应用场景-2"><!---->应用场景<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Set" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#set"><!---->Set<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="内部实现" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#内部实现-3"><!---->内部实现<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="常用命令" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#常用命令-2"><!---->常用命令<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="应用场景" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#应用场景-3"><!---->应用场景<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="HASHTABLE" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#hashtable"><!---->HASHTABLE<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="概述" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#概述"><!---->概述<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="HASHTABLE结构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#hashtable结构"><!---->HASHTABLE结构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Hash表渐进式扩容" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#hash表渐进式扩容"><!---->Hash表渐进式扩容<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="缩容" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#缩容"><!---->缩容<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="SKIPLIST" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#skiplist"><!---->SKIPLIST<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="跳表结构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#跳表结构"><!---->跳表结构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Redis的跳表实现" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#redis的跳表实现"><!---->Redis的跳表实现<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="跳表节点查询过程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#跳表节点查询过程"><!---->跳表节点查询过程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="跳表节点的层数设置" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#跳表节点的层数设置"><!---->跳表节点的层数设置<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Zset" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#zset-1"><!---->Zset<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="内部实现" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#内部实现-4"><!---->内部实现<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="常用命令" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#常用命令-3"><!---->常用命令<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="应用场景" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#应用场景-4"><!---->应用场景<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Stream" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#stream"><!---->Stream<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="概述" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#概述-1"><!---->概述<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="常见命令" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#常见命令"><!---->常见命令<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="应用场景" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#应用场景-5"><!---->应用场景<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="BitMap" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#bitmap"><!---->BitMap<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="介绍" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#介绍"><!---->介绍<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="内部实现" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#内部实现-5"><!---->内部实现<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="常用命令" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#常用命令-4"><!---->常用命令<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="应用场景" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#应用场景-6"><!---->应用场景<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="对象过期时间" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#对象过期时间"><!---->对象过期时间<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="过期时间定义" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#过期时间定义"><!---->过期时间定义<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="过期时间作用" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#过期时间作用"><!---->过期时间作用<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="设置过期时间" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#设置过期时间"><!---->设置过期时间<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="判断是否过期" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#判断是否过期"><!---->判断是否过期<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="键过期删除策略" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#键过期删除策略"><!---->键过期删除策略<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="对象引用计数" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#对象引用计数"><!---->对象引用计数<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="引用计数是什么" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#引用计数是什么"><!---->引用计数是什么<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Redis对象的引用计数" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#redis对象的引用计数"><!---->Redis对象的引用计数<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="连续内存结构和非连续内存结构的优劣" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#连续内存结构和非连续内存结构的优劣"><!---->连续内存结构和非连续内存结构的优劣<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a aria-label="Redis数据结构面试题汇总" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis数据结构面试题汇总<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis的运作" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E7%9A%84%E8%BF%90%E4%BD%9C.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis的运作<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis的运作面试题汇总" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E7%9A%84%E8%BF%90%E4%BD%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis的运作面试题汇总<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis与客户端" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis与客户端<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis持久化" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis持久化<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis持久化面试题汇总" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis持久化面试题汇总<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis高可用" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E9%AB%98%E5%8F%AF%E7%94%A8.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis高可用<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis高可用面试题汇总" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis高可用面试题汇总<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis应用场景" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis应用场景<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis应用场景面试题汇总" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis应用场景面试题汇总<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Redis设计" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/my_blog/backEnd/Redis/Redis%E8%AE%BE%E8%AE%A1.html"><span class="font-icon icon iconfont icon-write" style=""></span>Redis设计<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-mysql" style=""></span><span class="vp-sidebar-title">MySQL</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-java" style=""></span><span class="vp-sidebar-title">Java</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-OS" style=""></span><span class="vp-sidebar-title">OS</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->Redis数据结构</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="/" target="_blank" rel="noopener noreferrer">LGYNB</a></span><span property="author" content="LGYNB"></span></span><!----><!----><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 68 分钟</span><meta property="timeRequired" content="PT68M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#redisobject">RedisObject</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#redis存储对象的过程">redis存储对象的过程</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#数据类型">数据类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#string">String</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#内部实现">内部实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#基本操作">基本操作</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#应用场景">应用场景</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#常见面试题">常见面试题</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#sds">SDS</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#sds底层实现">SDS底层实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#解决c原生字符串问题">解决C原生字符串问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#sds相比于c的原生字符串">SDS相比于C的原生字符串</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#list">List</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#内部实现-1">内部实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#常用命令">常用命令</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#应用场景-1">应用场景</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#压缩列表">压缩列表</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#解决问题">解决问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#ziplist整体结构">ZIPLIST整体结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#ziplist节点结构">ZIPLIST节点结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#ziplist查询数据">ZIPLIST查询数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#ziplist更新数据">ZIPLIST更新数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#listpack优化">LISTPACK优化</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#hash">Hash</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#内部实现-2">内部实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#常用命令-1">常用命令</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#应用场景-2">应用场景</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#set">Set</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#内部实现-3">内部实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#常用命令-2">常用命令</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#应用场景-3">应用场景</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#hashtable">HASHTABLE</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#概述">概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#hashtable结构">HASHTABLE结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#hash表渐进式扩容">Hash表渐进式扩容</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#缩容">缩容</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#skiplist">SKIPLIST</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#跳表结构">跳表结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#redis的跳表实现">Redis的跳表实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#跳表节点查询过程">跳表节点查询过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#跳表节点的层数设置">跳表节点的层数设置</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#zset-1">Zset</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#内部实现-4">内部实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#常用命令-3">常用命令</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#应用场景-4">应用场景</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#stream">Stream</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#概述-1">概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#常见命令">常见命令</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#应用场景-5">应用场景</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#bitmap">BitMap</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#介绍">介绍</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#内部实现-5">内部实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#常用命令-4">常用命令</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#应用场景-6">应用场景</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#对象过期时间">对象过期时间</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#过期时间定义">过期时间定义</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#过期时间作用">过期时间作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#设置过期时间">设置过期时间</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#判断是否过期">判断是否过期</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#键过期删除策略">键过期删除策略</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#对象引用计数">对象引用计数</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#引用计数是什么">引用计数是什么</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#redis对象的引用计数">Redis对象的引用计数</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#连续内存结构和非连续内存结构的优劣">连续内存结构和非连续内存结构的优劣</a></li><!----><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h1 id="redis数据结构" tabindex="-1"><a class="header-anchor" href="#redis数据结构" aria-hidden="true">#</a> Redis数据结构</h1><h2 id="redisobject" tabindex="-1"><a class="header-anchor" href="#redisobject" aria-hidden="true">#</a> RedisObject</h2><p>Redis是Key-value存储，key只能存String，Value可以存Redis支持的所有数据类型</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span>LRU BITS<span class="token punctuation">;</span> 
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>robj<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>type</code>：哪种Redis对象</li><li><code>encoding</code>：表示用哪种底层编码，用OBJECT ENCODING[key]可以看到对应的编码方式</li><li><code>lru</code>：记录对象访问信息，用于内存淘汰</li><li><code>refcount</code>：用于计数，用来描述有多少个指针指向该对象</li><li><code>ptr</code>：内容指针，指向实际内容</li></ul><h3 id="redis存储对象的过程" tabindex="-1"><a class="header-anchor" href="#redis存储对象的过程" aria-hidden="true">#</a> redis存储对象的过程</h3><ol><li>创建 <code>redisObject</code>： <ul><li>存储对象的第一步是创建一个 <code>redisObject</code>，这是Redis内部用于表示各种数据类型的通用数据结构。</li><li><code>redisObject</code> 包括几个属性，其中两个关键属性是 <code>type</code> 和 <code>encoding</code>，它们决定了存储对象的数据类型和内部编码方式。</li></ul></li><li>设置 <code>type</code>： <ul><li>根据将要存储的对象类型（例如字符串、列表、哈希等），设置 <code>redisObject</code> 的 <code>type</code> 属性，以指示数据的类型。</li></ul></li><li>设置 <code>encoding</code>： <ul><li>根据数据的内容和长度，选择适当的编码方式（如int编码、embstr编码、raw编码等）并将其设置为 <code>redisObject</code> 的 <code>encoding</code> 属性。这有助于优化内存使用和操作性能。</li></ul></li><li>存储数据： <ul><li>根据数据类型和编码方式，将实际的数据存储在 <code>redisObject</code> 中</li></ul></li></ol><h2 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型" aria-hidden="true">#</a> 数据类型</h2><ul><li>常见的有五种：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）</strong>。</li><li>新添加四种： <strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）</strong>。</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231129005642085.png" alt="image-20231129005642085" tabindex="0" loading="lazy"><figcaption>image-20231129005642085</figcaption></figure><h2 id="string" tabindex="-1"><a class="header-anchor" href="#string" aria-hidden="true">#</a> String</h2><ul><li>String是最基本的数据对象</li><li>value不仅是字符串，也可以是数字（整数和浮点数）</li><li>value最多可容纳的数据长度是512M</li></ul><h3 id="内部实现" tabindex="-1"><a class="header-anchor" href="#内部实现" aria-hidden="true">#</a> 内部实现</h3><blockquote><p>String类型的底层的数据结构实现主要是<strong>int和SDS（简单动态字符串）</strong></p></blockquote><h4 id="字符串对象的内部编码" tabindex="-1"><a class="header-anchor" href="#字符串对象的内部编码" aria-hidden="true">#</a> 字符串对象的内部编码</h4><h5 id="三种不同的编码类型" tabindex="-1"><a class="header-anchor" href="#三种不同的编码类型" aria-hidden="true">#</a> 三种不同的编码类型</h5><p><strong>int、row、embstr</strong></p><ul><li><code>int</code>编码保存整数类型（浮点类型编码类型同字符串）</li><li><code>row</code>编码保存长字符串类型（len &gt; 32byte）</li><li><code>embstr</code>编码保存段字符串类型（len &lt;= 32 byte），全程为EmbeddedString</li></ul><p><strong>不同编码底层数据结构</strong></p><ul><li><code>int</code>编码对应<code>int</code>数据结构</li><li><code>row</code>和<code>embstr</code>编码对应<code>SDS</code>数据结构</li></ul><p><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/string.png" alt="img" loading="lazy">如果一个字符串对象保存的是整数值，并且这个整数值可以用<code>long</code>类型来表示，那么字符串对象会将整数值保存在字符串对象结构的<code>ptr</code>属性里面（将<code>void*</code>转换成<code>long</code>)，并将字符串对象的编码设置为<code>int</code></p><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用<code>long</code>类型来表示，那么字符串对象会将整数值保存在字符串对象结构的<code>ptr</code>属性里面（将<code>void*</code>转换成<code>long</code>)，并将字符串对象的编码设置为<code>int</code></p><ul><li><code>ptr</code>是字符串对象的一个属性，表示<strong>指向字符串数据的指针</strong></li><li>编码属性也是一个字符串对象的一个属性，用于<strong>表示<code>ptr</code>属性中数据的类型</strong></li><li>通过实现<strong>将<code>void*</code>类型的指针转换为<code>long</code>整数类型的指针</strong>来实现保存整数值的</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/string结构.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>如果字符串对象保存的是一个字符串，并且这个字符串的长度小于等于32字节，那么字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串，并将对象的编码设置为<code>embstr</code><ul><li><code>embstr</code>是编码专门用来保存短字符串的一种优化编码方式</li><li>EMBSTR下的redisObject和SDS是连续的内存 <ul><li>优点是两个结构可以一次性分配空间</li><li>缺点是重新分配空间，整体都需要再分配——所以EMBSTR设计为只读，在任何修改操作之后EMBSTR编码都会变成RAW编码</li></ul></li></ul></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/embstr.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>如果字符串对象保存的是一个字符串，并且这个字符串的长度大于32字节，那么字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串，并将对象的编码设置为<code>row</code></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/raw.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>注意：<code>embstr</code>编码和<code>row</code>编码的边界在Redis的不同版本中是不一样的 <ul><li>redis 2.+ 是32字节</li><li>redis3.0-4.0 是39字节</li><li>redis 5.0 是44字节</li></ul></li></ul><h5 id="embstr和row的不同" tabindex="-1"><a class="header-anchor" href="#embstr和row的不同" aria-hidden="true">#</a> embstr和row的不同</h5><p><code>embstr</code>和<code>row</code>编码都会使用<code>SDS</code>来保存值，但<code>embstr</code>会通过一次内存分配函数来分配一块连续的内存空间来保存<code>redisObject</code>和<code>SDS</code>，而<code>row</code>编码会通过调用两次内存分配函数来分配两块连续的内存空间来保存<code>redisObject</code>和<code>SDS</code></p><ul><li><code>embstr</code>编码将创建字符串对象所需的内存分配次数从<code>row</code>编码的两次降低为一次</li><li>释放<code>embstr</code>编码的字符串对象同样只需要调用一次内存释放函数</li><li><code>embstr</code>编码的字符串对象的所有数据都保存在一块连续的内存里面，可以更好的利用CPU的缓存提升性能</li><li><code>embstr</code>的缺点 <ul><li>字符串的长度增加需要重新分配内存时，整个redisObject和SDS都需要重新分配</li><li>所以<code>embstr</code>编码的字符串对象实际上是只读的，redis没有为<code>embstr</code>编码的字符串对象编写任何响应的修改程序</li><li>当我们对<code>embstr</code>编码的字符串对象执行任何修改命令（例如<code>append</code>）时，程序会先将对象的编码从<code>embstr</code>转换成<code>row</code>，然后再执行修改命令</li><li>EMBSTR编码类型底层使用的是sdshdr8，sdshdr8类型的sds是有预留空间的能力的，但是EMBSTR类型里的sdshdr8，预留空间会被显示设置为0</li></ul></li></ul><h3 id="基本操作" tabindex="-1"><a class="header-anchor" href="#基本操作" aria-hidden="true">#</a> 基本操作</h3><h4 id="普通字符串的基本操作" tabindex="-1"><a class="header-anchor" href="#普通字符串的基本操作" aria-hidden="true">#</a> 普通字符串的基本操作</h4><ul><li>SET, GET, EXISTS, STRLEN, DEL</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 设置 key-value 类型的值</span>
<span class="token operator">&gt;</span> SET name lin
OK
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 根据 key 获得对应的 value</span>
<span class="token operator">&gt;</span> GET name
<span class="token string">&quot;lin&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 判断某个 key 是否存在</span>
<span class="token operator">&gt;</span> EXISTS name
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 返回 key 所储存的字符串值的长度</span>
<span class="token operator">&gt;</span> STRLEN name
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 删除某个 key 对应的值</span>
<span class="token operator">&gt;</span> DEL name
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="批量设置" tabindex="-1"><a class="header-anchor" href="#批量设置" aria-hidden="true">#</a> 批量设置</h4><ul><li>MSET, MGET</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 批量设置 key-value 类型的值</span>
<span class="token operator">&gt;</span> MSET key1 value1 key2 value2 
OK
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 批量获取多个 key 对应的 value</span>
<span class="token operator">&gt;</span> MGET key1 key2 
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;value1&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;value2&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="计数器" tabindex="-1"><a class="header-anchor" href="#计数器" aria-hidden="true">#</a> 计数器</h4><ul><li>INCR, INCRBY, DECR, DECRBY</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 设置 key-value 类型的值</span>
<span class="token operator">&gt;</span> SET number <span class="token number">0</span>
OK
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 将 key 中储存的数字值增一</span>
<span class="token operator">&gt;</span> INCR number
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 将key中存储的数字值加 10</span>
<span class="token operator">&gt;</span> INCRBY number <span class="token number">10</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">11</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 将 key 中储存的数字值减一</span>
<span class="token operator">&gt;</span> DECR number
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 将key中存储的数字值键 10</span>
<span class="token operator">&gt;</span> DECRBY number <span class="token number">10</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="过期" tabindex="-1"><a class="header-anchor" href="#过期" aria-hidden="true">#</a> 过期</h4><p>默认为永不过期</p><ul><li>EXPIRE, TTL</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 设置 key 在 60 秒后过期（该方法是针对已经存在的key设置过期时间）</span>
<span class="token operator">&gt;</span> EXPIRE name <span class="token number">60</span> 
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看数据还有多久过期</span>
<span class="token operator">&gt;</span> TTL name 
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">51</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#设置 key-value 类型的值，并设置该key的过期时间为 60 秒</span>
<span class="token operator">&gt;</span> SET key value EX <span class="token number">60</span>
OK
<span class="token operator">&gt;</span> SETEX key  <span class="token number">60</span> value
OK
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="不存在就插入" tabindex="-1"><a class="header-anchor" href="#不存在就插入" aria-hidden="true">#</a> 不存在就插入</h4><ul><li>SETNX</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 不存在就插入（not exists）</span>
<span class="token operator">&gt;</span>SETNX key value
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h3><h4 id="缓存对象" tabindex="-1"><a class="header-anchor" href="#缓存对象" aria-hidden="true">#</a> 缓存对象</h4><p>使用String来缓存对象有两种方式</p><ul><li>直接缓存整个对象的JSON <ul><li><code>SET user:1 &#39;{&quot;name&quot;:&quot;xiaolin&quot;, &quot;age&quot;:&quot;18&quot;}&#39;</code></li></ul></li><li>采用将key进行分离为user:ID:属性，采用MSET存储，用MGET获取各属性值 <ul><li><code>MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20</code></li></ul></li></ul><h4 id="常规计数" tabindex="-1"><a class="header-anchor" href="#常规计数" aria-hidden="true">#</a> 常规计数</h4><p>因为Redis处理命令是单线程，所以执行命令的过程是原子的</p><p>因此String数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等</p><ul><li>计算文章的阅读量</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 初始化文章的阅读量</span>
<span class="token operator">&gt;</span> SET aritcle:readcount:1001 <span class="token number">0</span>
OK
<span class="token comment">#阅读量+1</span>
<span class="token operator">&gt;</span> INCR aritcle:readcount:1001
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token comment">#阅读量+1</span>
<span class="token operator">&gt;</span> INCR aritcle:readcount:1001
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
<span class="token comment">#阅读量+1</span>
<span class="token operator">&gt;</span> INCR aritcle:readcount:1001
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
<span class="token comment"># 获取对应文章的阅读量</span>
<span class="token operator">&gt;</span> GET aritcle:readcount:1001
<span class="token string">&quot;3&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁" aria-hidden="true">#</a> 分布式锁</h4><p><strong>加锁</strong>：</p><p>SET命令中的NX参数可以实现key不存在才插入，可以用来实现分布式锁</p><ul><li>如果key不存在，则显示插入成功，表示加锁成功</li><li>如果key存在，则显示插入失败，表示加锁失败</li></ul><p>一般会对分布式锁加上过期时间</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>SET lock_key unique_value NX PX <span class="token number">10000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>lock_key</code>：就是key</li><li><code>unique_value</code>：是客户端生成的唯一标识</li><li><code>NX</code>：代表只在lock_key不存在时，才对lock_key进行设置操作</li><li><code>PX 10000</code>：表示设置lock_key的过期时间为10s，这是为了避免客户端发生异常导致无法释放锁 <ul><li><code>PX</code>：代表设置过期时间，以毫秒为单位</li><li><code>EX</code>：代表设置过期时间，以秒为单位</li></ul></li></ul><p><strong>解锁</strong>：</p><p>解锁的过程就是将lock_key键删除，但不能乱删，要保证执行操作的客户端就是加锁的客户端</p><p>解锁的时候需要先判断所的unique_value是否为加锁客户端，是才删除</p><p>解锁有两个操作，需要使用Lua脚本来保证解锁的原子性</p><div class="language-lua line-numbers-mode" data-ext="lua"><pre class="language-lua"><code><span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;get&quot;</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">then</span>
    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;del&quot;</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">else</span>
	<span class="token keyword">return</span> <span class="token number">0</span>
<span class="token keyword">end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就通过SET命令和Lua脚本再Redis单节点上完成了分布式锁的加锁和解锁</p><h4 id="共享session信息" tabindex="-1"><a class="header-anchor" href="#共享session信息" aria-hidden="true">#</a> 共享session信息</h4><p>session信息保存在服务端只适合单系统应用，分布式系统不适用</p><p>用户的session信息存储在不同的服务器会出现重复登录的问题，分布式系统每次会把请求随机分配到不同的服务器</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/Session1.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>借助Redis可以对这些session信息进行统一的存储和管理</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/Session2.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="常见面试题" tabindex="-1"><a class="header-anchor" href="#常见面试题" aria-hidden="true">#</a> 常见面试题</h3><h4 id="redis底层对string做了哪些优化-美团" tabindex="-1"><a class="header-anchor" href="#redis底层对string做了哪些优化-美团" aria-hidden="true">#</a> Redis底层对String做了哪些优化(美团)</h4><p><a href="https://mp.weixin.qq.com/s/Sq86orO-iU3lc20UEBuQiw" target="_blank" rel="noopener noreferrer">原文链接<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><ol><li>简单动态字符串SDS <ul><li>相比较于C原生的字符串，SDS实现的字符串是线程安全的 <ul><li>SDS定义了一个<code>len</code>字段，表示字符串数据的长度，可以用于定位到字符串的末尾，摒弃了C原生字符串用<code>/0</code>结尾的做法，所以SDS可以安全的存取二进制i数据</li></ul></li><li><code>len</code>字段还可以用于$O(1)$时间获取字符串长度 <ul><li>C原生字符串需要遍历才能获取</li></ul></li><li>SDS比C原生字符串多了一部分预留空间 <ul><li>SDS除了<code>len</code>字段之外，还定义了<code>alloc</code>字段，表示字符串对象分配的内存空间大小。<code>alloc - len</code>，即总长度减去已使用的长度，就可以得出预留空间的大小。在修改字符串的时候就有机会可以免除另外分配内存空间的消耗</li></ul></li></ul></li><li>共享字符串池 <ul><li>Redis会将传入的字符串参数放入共享字符串池，不同的key可以指向同一份内存空间</li><li>新增字符串的时候会来共享池里面查询是否存在，若存在则直接指向该内存地址，不存在则新增后将指针指向新的内存地址</li></ul></li><li>编码优化 <ul><li>Redis给String对象提供了三种编码格式，分别是INT，EMBSTR，RAW</li><li>INT编码存整数</li><li>EMBSTR编码存较短的字符串，小于44字节的字符串就存为EMBSTR</li><li>RAW编码存较长的字符串，大于44字节的字符串就存为RAW</li><li>EMBSTR的redisObject和sds数据是连在一起的，有利于CPU高速缓存命中，并且EMBSTR分配和释放内存空间都只需要一次，而RAW需要分配两次</li></ul></li></ol><h4 id="set一个已有的数据会发生什么" tabindex="-1"><a class="header-anchor" href="#set一个已有的数据会发生什么" aria-hidden="true">#</a> Set一个已有的数据会发生什么</h4><ul><li>覆盖原有的值，同时覆盖或擦除键的过期时间</li></ul><h4 id="浮点型在string是用什么表示" tabindex="-1"><a class="header-anchor" href="#浮点型在string是用什么表示" aria-hidden="true">#</a> 浮点型在String是用什么表示</h4><ul><li>用字符串值表示，按照字符阈值取EMBSTR编码或者RAW编码</li></ul><h4 id="string可以有多大" tabindex="-1"><a class="header-anchor" href="#string可以有多大" aria-hidden="true">#</a> String可以有多大</h4><ul><li>5.0.5版本的一个Redis字符串最大为512M</li></ul><h4 id="redis字符串是怎么实现的" tabindex="-1"><a class="header-anchor" href="#redis字符串是怎么实现的" aria-hidden="true">#</a> Redis字符串是怎么实现的</h4><ul><li>Redis字符串底层是String对象，String对象有3种编码方式：INT，EMBSTR，RAW。若存进数值为整型（可以用long表示的整数）就以INT编码存储；若存进字符串，当字符串长度小于等于设定阈值（5.0.5中为44）使用EMBSTR编码，大于阈值则使用RAW编码。</li></ul><h4 id="embstr的阈值为什么是44" tabindex="-1"><a class="header-anchor" href="#embstr的阈值为什么是44" aria-hidden="true">#</a> EMBSTR的阈值为什么是44</h4><ul><li>Redis默认的内存分配器是jemalloc</li><li>jemalloc是以64字节为一内存单元做内存分配的，超出64字节就超过了一内存单元。所以应该尽量在一内存单元内，减少内存寻址，不会消耗分配过多没用到的内存。 <ul><li>局部性访问原理：在一起就不需要跳转</li><li>超过64字节用RAW编码，小于等于64字节视为小字符串，用到EMBSTR编码</li></ul></li><li>redisObject大小为4+4+24+32+64 = 128bits = 16bytes，ptr取最大值64是为了方便跨平台使用</li><li>sdshdr8大小为1+1+1+内联数组大小+1，最后一位是&#39;\0&#39;</li><li>内联数组大小 = 64 - 16(redisObject) - 3(sdshdr非内容属性) - 1(&#39;/0&#39;) = 44</li><li>回答：Redis使用Jemalloc内存分配器，以一内存单元，也就是64字节位阈值区分大小字符串，EMBSTR的边界阈值受64影响，redis对象占用的内存大小由redisObject和sdshdr两部分组成，redisObject16字节，sdshdr中三个字段占3字节，还有一个&#39;\0&#39;占1字节，剩下能存放数据的就剩64-16-3-1 = 44字节</li></ul><h4 id="为什么曾经的embstr阈值为39" tabindex="-1"><a class="header-anchor" href="#为什么曾经的embstr阈值为39" aria-hidden="true">#</a> 为什么曾经的EMBSTR阈值为39</h4><ul><li>3.2之后的版本SDS结构进行了拆分，EMBSTR用的是sdshdr8，总容量和已使用容量字段减少了6个字节，但由于增加了flags字段，所以最终节约了5个字节</li></ul><h4 id="sds有什么用" tabindex="-1"><a class="header-anchor" href="#sds有什么用" aria-hidden="true">#</a> SDS有什么用</h4><ul><li>SDS包含已使用容量字段，$O(1)$时间快速返回字符串长度，C原生字符串许哟$O(n)$</li><li>有预留空间，在扩容时如果预留空间足够，则不用重新分配内存，节约性能，缩容时也可以将减少的空间保留下来，后续可以继续使用</li><li>不再以&#39;\0&#39;作为字符串结束标准，二进制安全，可以很方便的存储一些二进制数据</li></ul><h4 id="sds的扩容过程" tabindex="-1"><a class="header-anchor" href="#sds的扩容过程" aria-hidden="true">#</a> SDS的扩容过程</h4><ul><li>SDS首先检查要添加的新数据是否超过可用空间，若足够，则直接追加，并更新len</li><li>若不够，SDS先计算出合适的新空间大小，根据当前数据长度和将要添加的新数据长度计算得出</li><li>然后分配出一块新的内存空间，将原有数据复制进新空间中并释放旧空间</li><li>更新SDS相关字段，buf指向新的长度，len字段表示新的长度，alloc字段表示分配可用空间</li></ul><h2 id="sds" tabindex="-1"><a class="header-anchor" href="#sds" aria-hidden="true">#</a> SDS</h2><ul><li>C语言中的字符串用一个&#39;/0&#39;结尾的char数组表示</li><li>每次计算字符串长度时间复杂度为$O(n)$</li><li>对字符串进行追加需要重新分配内存</li><li>非二进制安全</li></ul><h3 id="sds底层实现" tabindex="-1"><a class="header-anchor" href="#sds底层实现" aria-hidden="true">#</a> SDS底层实现</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint8_t</span> len<span class="token punctuation">;</span>
    <span class="token class-name">uint8_t</span> alloc<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><code>len</code>：表示使用了多少</p></li><li><p><code>alloc</code>：表示分配了多少内存</p><ul><li>二者的差值<code>alloc-len</code>就是预留空间的大小</li></ul></li><li><p><code>flags</code>：标记是那个分类（sdshdr8、sdshdr16……）</p></li></ul><h3 id="解决c原生字符串问题" tabindex="-1"><a class="header-anchor" href="#解决c原生字符串问题" aria-hidden="true">#</a> 解决C原生字符串问题</h3><ul><li>增加长度字段len，快速返回长度</li><li>增加空余空间（alloc-len），为后续追加数据留余地 <ul><li>预留空间大小为min(len,1M)</li></ul></li><li>不再以&#39;\0&#39;作为判断标准，二进制安全</li></ul><h3 id="sds相比于c的原生字符串" tabindex="-1"><a class="header-anchor" href="#sds相比于c的原生字符串" aria-hidden="true">#</a> SDS相比于C的原生字符串</h3><ul><li><strong>SDS不仅可以存储文本数据，还可以保存二进制数据</strong><ul><li>SDS使用<strong>len属性的值</strong>而不是空字符来<strong>判断字符串是否结束</strong></li><li>SDS的所有<strong>API</strong>都会以<strong>处理二进制的方式来处理SDS存放在buf[]数组里的数据</strong></li></ul></li><li><strong>SDS获取字符串长度的时间复杂度是O(1)</strong><ul><li>C语言的字符串不记录自身长度，所以获取长度(strlen)的复杂度为O(n)</li><li>SDS结构中用len属性记录了字符串长度，所以复杂度是O(1)</li></ul></li><li><strong>Redis的SDS API是安全的，拼接字符串不会造成缓冲区溢出</strong><ul><li>SDS在拼接字符串之前会检查SDS空间是否满足要求</li><li>如果<strong>空间不够会自动扩容</strong>，不会导致缓冲区溢出</li></ul></li></ul><h2 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> List</h2><p>List列表是简单的字符串列表，按照插入顺序排序，可以从头部或尾部向List列表添加元素</p><p>列表的最大长度为$2^{32}-1$，即每个列表支持超过40亿个元素</p><h3 id="内部实现-1" tabindex="-1"><a class="header-anchor" href="#内部实现-1" aria-hidden="true">#</a> 内部实现</h3><h4 id="ziplist和linkedlist" tabindex="-1"><a class="header-anchor" href="#ziplist和linkedlist" aria-hidden="true">#</a> ZIPLIST和LINKEDLIST</h4><p>满足如下条件时使用ZIPLIST编码</p><ul><li>列表对象保存的所有字符串对象长度都小于64字节</li><li>列表对象元素个数少于512个（对LIST来说）</li></ul><p>ZIPLIST底层用压缩列表实现，压缩列表的内存排列很紧凑，可以有效的解决内存空间</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231103200456664.png" alt="image-20231103200456664" tabindex="0" loading="lazy"><figcaption>image-20231103200456664</figcaption></figure><p>如果不满足ZIPLIST的编码的条件，则使用LINKEDLIST编码，用LINKEDLIST编码则是几个String对象的连接结构</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231103212333487.png" alt="image-20231103212333487" tabindex="0" loading="lazy"><figcaption>image-20231103212333487</figcaption></figure><ul><li>ZIPLIST底层偏向数组，LINKEDLIST底层是双向链表</li></ul><p>优点</p><ul><li>ZIPLIST是为了数据较少时节约内存</li><li>LINKEDLIST是为了数据较多时提高更新效率</li></ul><p>缺点</p><ul><li>ZIPLIST数据稍多时插入数据就会导致很多内存复制 <ul><li>ZIPLIST是连续内存空间，插入一个元素会导致内存空间重新分配，并且新节点后面位置的所有节点都需要移动</li></ul></li><li>节点非常多的时候，LINKEDLIST会占用很多内存 <ul><li>指针的开销和内存碎片产生的可能性</li></ul></li></ul><h4 id="quicklist" tabindex="-1"><a class="header-anchor" href="#quicklist" aria-hidden="true">#</a> QUICKLIST</h4><p>QUICKLIST是ZIPLIST和LINKEDLIST的结合体</p><p>QUICKLIST是一个LINKEDLIST，但是其节点不是原先的字符串类型，改成ZIPLIST类型</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231103214000192.png" alt="image-20231103214000192" tabindex="0" loading="lazy"><figcaption>image-20231103214000192</figcaption></figure><ul><li>数据较少时，QUICKLIST的节点就只有一个，此时就相当于一个ZIPLIST</li><li>数据很多时，就同时利用ZIPLIST和LINKEDLIST的优势</li></ul><h3 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令" aria-hidden="true">#</a> 常用命令</h3><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/list.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><strong>创建</strong>一个List对象，分左侧和右侧（也可以用作更新）</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 将一个或多个值value插入到key列表的表头(最左边)，最后的值在最前面</span>
LPUSH key value <span class="token punctuation">[</span>value <span class="token punctuation">..</span>.<span class="token punctuation">]</span> 
<span class="token comment"># 将一个或多个值value插入到key列表的表尾(最右边)</span>
RPUSH key value <span class="token punctuation">[</span>value <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>删除</strong>：针对List对象本身的生成和销毁 <ul><li>DEL命令为同步删除，会阻塞客户端，直到删除成功。</li><li>UNLINK命令为异步删除，取消Key在键空间的关联，让其不能被查到，删除是异步进行，不会阻塞客户端</li><li>阻塞客户端指的是主进程执行删除操作</li></ul></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 删除对象，返回值为删除成功了几个键</span>
DEL key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
UNLINK key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>查询</strong>：范围查询和查询元素个数</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 返回列表key中指定区间内的元素，区间以偏移量start和stop指定，从0开始</span>
<span class="token comment"># 偏移量若为负数，则表示导数的几个元素</span>
LRANGE key start stop
<span class="token comment"># 查看List的长度，即List中元素的个数</span>
LLEN key
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>更新</strong>：追加元素，删除元素，也是分左右</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 移除并返回key列表的头元素</span>
LPOP key     
<span class="token comment"># 移除并返回key列表的尾元素</span>
RPOP key 
<span class="token comment"># 移除值等于value的count个元素</span>
<span class="token comment"># 当count=0则移除所有值value元素，count&gt;0从左到右移除，count&lt;0从右到左移除，返回被移除值的数量</span>
LREM key count value
<span class="token comment"># 从key列表表头弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞</span>
BLPOP key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token function">timeout</span>
<span class="token comment"># 从key列表表尾弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞</span>
BRPOP key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token function">timeout</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="应用场景-1" tabindex="-1"><a class="header-anchor" href="#应用场景-1" aria-hidden="true">#</a> 应用场景</h3><h4 id="消息队列" tabindex="-1"><a class="header-anchor" href="#消息队列" aria-hidden="true">#</a> 消息队列</h4><p>消息队列存取消息时，需要满足三个需求</p><ul><li>消息保序</li><li>处理重复消息</li><li>保证消息可靠</li></ul><p>Redis的List和Stream两种数据类型就可以满足条件</p><h5 id="消息保序" tabindex="-1"><a class="header-anchor" href="#消息保序" aria-hidden="true">#</a> 消息保序</h5><p>List是按照先进先出的顺序对数据进行存储的</p><p>List可以使用<code>LPUSH + RPOP</code>（<code>RPUSH + LPOP</code>）命令来实现消息队列</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/list消息队列.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><p>生产者使用<code>LPUSH key value[value ...]</code>将消息插入到队列头部，若Key不存在，则会创建一个空的队列再插入消息</p></li><li><p>消费者使用<code>RPOP key</code>依次读取队列的消息，先进先出</p></li><li><p><code>BRPOP</code>：<strong>阻塞式读取</strong></p><ul><li>客户端没有读到队列数据时自动阻塞</li><li>直到有新的数据写入队列，再开始读取新数据</li><li>解决了没有新消息写入List，消费者也要不停调用RPOP命令，减少性能损失</li></ul></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/消息队列.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h5 id="处理重复消息" tabindex="-1"><a class="header-anchor" href="#处理重复消息" aria-hidden="true">#</a> 处理重复消息</h5><p>如何判断：</p><ul><li>每个消息都有一个全局的ID</li><li>消费者要记录已经处理过的消息ID，收到新消息后进行比对</li></ul><p>List不会为每个消息生成ID号，实现消息队列的时候<strong>需要自行为每条消息生成一个全局唯一的ID</strong>，生成之后用LPUSH把消息插入List时，需要在消息中包含这个全局ID</p><p>例如：将一条全局ID为111000102、库存量为99的消息插入消息队列</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>LPUSH mq <span class="token string">&quot;111000102:stock:99&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5 id="保证消息可靠性" tabindex="-1"><a class="header-anchor" href="#保证消息可靠性" aria-hidden="true">#</a> 保证消息可靠性</h5><p>消费者从List中读取一条消息之后，List就不会再留存这条消息了</p><p>如果消费者程序在处理这条消息的时候出现故障或宕机，就会导致消息没有处理完成。</p><p>为了留存消息，List类型提供了<code>BRPOPLPUSH</code>命令</p><p>让消费者程序从一个List中读取消息，同时Redis会将这条消息再插入到另一个List中留存</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>BRPOPLPUSH source_key destination_key
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h5><ul><li><strong>消息保序</strong>：使用LPUSH + RPOP</li><li><strong>阻塞读取</strong>：使用BRPOP</li><li><strong>重复消息读取</strong>：生产者自行实现全局唯一ID</li><li><strong>消息的可靠性</strong>：使用BRPOPLPUSH</li></ul><h5 id="缺陷" tabindex="-1"><a class="header-anchor" href="#缺陷" aria-hidden="true">#</a> 缺陷</h5><p>List类型不支持多个消费者消费同一条消息，也就是<strong>不支持消费组的实现</strong></p><h2 id="压缩列表" tabindex="-1"><a class="header-anchor" href="#压缩列表" aria-hidden="true">#</a> 压缩列表</h2><p>压缩列表在Redis中有两种编码方式，一般平常说的压缩列表指的是ZIPLIST，另一种是LISTPACK。</p><p>LISTPACK在Redis5.0引入，在Redis7.0时完全替换了ZIPLIST，是ZIPLIST的进阶版本</p><h3 id="解决问题" tabindex="-1"><a class="header-anchor" href="#解决问题" aria-hidden="true">#</a> 解决问题</h3><p>紧凑型的数据存储结构，能节约内存（节省链表指针的开销），小数据量的时候遍历访问性能好（连续+缓存命中率友好）</p><blockquote><p><strong>局部性原理</strong>：CPU高速缓存的工作原理是基于局部性原理，即数据的访问模式。当程序访问一部分数据，附近的数据也会被加载到高速缓存中，以便下次更快地访问。ZIPLIST的连续存储形式有利于数据的局部性，因为相邻的数据通常在时间上和空间上都相关联。</p><p><strong>内存碎片</strong>分为内部碎片和外部碎片</p><p><strong>内部碎片</strong>是由于采用固定大小的内存分区，当一个进程不能完全使用分给它的固定内存区域时就产生了内部碎片，通常内部碎片难以完全避免 <strong>外部碎片</strong>是由于某些未分配的连续内存区域太小，以至于不能满足任意进程的内存分配请求，从而不能被进程利用的内存区域。</p></blockquote><ul><li>ZIPLIST连续的存储空间一方面可以减少内部内存碎片的产生，另一方面可以利用CPU高速缓存的工作原理，高效访问数据</li></ul><h3 id="ziplist整体结构" tabindex="-1"><a class="header-anchor" href="#ziplist整体结构" aria-hidden="true">#</a> ZIPLIST整体结构</h3><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231104235236612.png" alt="image-20231104235236612" tabindex="0" loading="lazy"><figcaption>image-20231104235236612</figcaption></figure><ul><li><code>zlbytes</code>：表示该ZIPLIST一共占了多少个字节数（包含该属性本身占据字节数）</li><li><code>zltail</code>：尾巴节点，相对于ZIPLIST的开头（起始指针），偏移的字节数。通过这个字段可以快速定位到尾巴节点 <ul><li><code>zltail</code> = 整个ZIPLIST的总字节数(<code>zlbytes</code>) - 最后一个节点(<code>entry3</code>)的字节数 - 结束标识(<code>zlend</code>)的字节数</li><li>例如：现在有一个ZIPLIST，<code>zl</code>指向他的开头，如果要获取<code>tail</code>尾巴节点，即ZIPLIST的最后一个节点，可以<code>zl+zltail</code>的值，这样定位到它。如果没有尾巴节点，就会定位到<code>zlend</code></li></ul></li><li><code>zlen</code>：表示有多少个数据节点，在本例中有3个</li><li><code>zlend</code>：一个特殊的<code>entry</code>节点，表示ZIPLIST的结果</li></ul><h3 id="ziplist节点结构" tabindex="-1"><a class="header-anchor" href="#ziplist节点结构" aria-hidden="true">#</a> ZIPLIST节点结构</h3><ul><li>ZIPLIST的每个节点称为<code>entry</code></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231105120633932.png" alt="image-20231105120633932" tabindex="0" loading="lazy"><figcaption>image-20231105120633932</figcaption></figure><ul><li><p><code>prevlen</code>：表示上一个节点的数据长度，通过这一个字段可以定位到上一个节点的起始地址(开头)，<code>p - prevlen</code>可以跳到前一个节点的开头位置，实现从后往前操作。压缩链表才能够从后往前遍历</p><ul><li>如果前一节点的长度，也就是前一个<code>entry</code>的大小<strong>小于254字节</strong>，那么<code>prevlen</code>属性需要用1字节长的空间来保存这个长度值，255是特殊字符，被<code>zlend</code>用了</li><li>如果前一节点的长度<strong>大于等于254字节</strong>，那么<code>prevlen</code>属性需要用5字节长的空间来保存这个长度值。注意：5个字节中第一个字节为<code>1111 1110</code>，也就是254，标志这是个5字节的<code>prevlen</code>信息，剩下的4字节用来表示大小</li></ul></li><li><p><code>encoding</code>：编码类型。编码类型还包含了一个<code>entry</code>长度信息，可用于正向遍历</p><ul><li><code>encoding</code>中保存的<code>entry</code>长度信息是指<code>entry-data</code>的数据长度</li><li><code>encoding</code>有两部分，前几位标识类型，后几位标识长度</li></ul></li><li><p><code>entry-data</code>：实际的数据</p></li></ul><h3 id="ziplist查询数据" tabindex="-1"><a class="header-anchor" href="#ziplist查询数据" aria-hidden="true">#</a> ZIPLIST查询数据</h3><h4 id="查询ziplist数据总量" tabindex="-1"><a class="header-anchor" href="#查询ziplist数据总量" aria-hidden="true">#</a> 查询ZIPLIST数据总量</h4><ul><li>header定义了记录节点数量的字段zlen，通常$O(1)$时间内就能返回</li><li>但是zlen是2个字节的，当zlen大于65535时，zlen就存不下了，此时zlen等于0，查看到zlen==0就遍历</li><li>这样设计是因为Redis中应用ZIPLIST都是为了节点个数少的场景，所以将zlen设计得较小，节约内存空间 <ul><li>RedisLIST在元素个数&lt;512的时候使用ZIPLIST</li></ul></li></ul><h4 id="查询指定数据的节点" tabindex="-1"><a class="header-anchor" href="#查询指定数据的节点" aria-hidden="true">#</a> 查询指定数据的节点</h4><ul><li>需要遍历整个ZIPLIST，平均时间复杂度是$O(n)$</li></ul><h3 id="ziplist更新数据" tabindex="-1"><a class="header-anchor" href="#ziplist更新数据" aria-hidden="true">#</a> ZIPLIST更新数据</h3><p>ZIPLIST更新就是增加和删除数据(INSERT和DELETE)，不能修改(UPDATE)</p><p>ZIPLIST提供头尾增减的能力，平均复杂度是$O(n)$，因为头部增加节点会导致后面节点后移</p><h4 id="连锁更新" tabindex="-1"><a class="header-anchor" href="#连锁更新" aria-hidden="true">#</a> 连锁更新</h4><p>前面说到，<code>prevlen</code>字段的字节数是1还是5取决于前一节点的字节数是否&gt;=254字节</p><p>假设存在n个大小在250-253字节之间<code>entry</code>的ZIPLIST，在该列表头部新增一个节点</p><ul><li>若该节点大小&lt;254字节，则与普通更新无异样</li><li>若该节点大小&gt;=254字节，则下一个节点的<code>prevlen</code>长度变更为5字节， <ul><li>由于下一个节点的<code>prevlen</code>长度发生改变，导致该节点的现总长度&gt;=254节点，下一个节点的<code>prevlen</code>长度也需要更改</li><li>这样一直更新<code>prevlen</code>的长度，直到出现大小&lt;250字节的<code>entry</code>停止。</li></ul></li></ul><p>这样连续的更新称为<strong>连锁更新</strong></p><p>实际的业务中很少出现这种情况，但是ZIPLIST最大的问题就是<strong>连锁更新所导致的性能不稳定</strong></p><h3 id="listpack优化" tabindex="-1"><a class="header-anchor" href="#listpack优化" aria-hidden="true">#</a> LISTPACK优化</h3><h4 id="listpack的数据结构" tabindex="-1"><a class="header-anchor" href="#listpack的数据结构" aria-hidden="true">#</a> LISTPACK的数据结构</h4><ul><li>LISTPACK的每个节点称为<code>element</code></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231105120621904.png" alt="image-20231105120621904" tabindex="0" loading="lazy"><figcaption>image-20231105120621904</figcaption></figure><ul><li><code>encoding-type</code>：编码类型</li><li><code>element-data</code>：数据类型</li><li><code>element-tot-len</code>：存储整个节点除了它自身之外的长度 <ul><li><code>element-tot-len</code>每个字节的第一个bit位用于标识是否结束(1未结束0结束)，剩下七个bit位用来存储数据大小</li><li>需要找到当前元素的上一个元素时，我们可以从后向前依次查找每个字节，找到上一个<code>element-tot-len</code>字段的结束标识，就能算出上一个字节</li><li>例如：上一个<code>element-tot-len</code>为<code>00000001 10000100</code>，由于每个字节的第一个bit位标识是否结束，这里的<code>element-tot-len</code>总共两个字节，大小为<code>00000001 00000100</code>，即132个字节</li></ul></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231105133745527.png" alt="image-20231105133745527" tabindex="0" loading="lazy"><figcaption>image-20231105133745527</figcaption></figure><h2 id="hash" tabindex="-1"><a class="header-anchor" href="#hash" aria-hidden="true">#</a> Hash</h2><p>Hash是一个键值对（key-value）集合，其中value的形式如:</p><div class="language-JSON line-numbers-mode" data-ext="JSON"><pre class="language-JSON"><code>value=[
    {field1,value1},
    {field2,value2},
    ···,
    {fieldN,valueN}
]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Hash特别适合用于存储<strong>对象</strong></p><p><strong>Hash与String对象的区别</strong></p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/hash.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="内部实现-2" tabindex="-1"><a class="header-anchor" href="#内部实现-2" aria-hidden="true">#</a> 内部实现</h3><p>满足HASH保存的所有值和键的长度都小于64字节以及HASH对象元素个数少于512个就使用<strong>压缩列表</strong>结构</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231105152424179.png" alt="image-20231105152424179" tabindex="0" loading="lazy"><figcaption>image-20231105152424179</figcaption></figure><p>两个条件有一个不满足就使用<strong>HASHTABLE</strong></p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231105152502566.png" alt="image-20231105152502566" tabindex="0" loading="lazy"><figcaption>image-20231105152502566</figcaption></figure><p><strong>Redis7.0中，ZIPLIST数据结构已经废弃，交由LISTPACK数据结构来实现</strong></p><h3 id="常用命令-1" tabindex="-1"><a class="header-anchor" href="#常用命令-1" aria-hidden="true">#</a> 常用命令</h3><h4 id="写操作" tabindex="-1"><a class="header-anchor" href="#写操作" aria-hidden="true">#</a> 写操作</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 存储一个哈希表key的键值</span>
HSET key field value   
<span class="token comment"># 如果field不存在，则为集合对应field设置value数据</span>
HSETNX key field value
<span class="token comment"># 设置多个键值对</span>
HMSET key field value <span class="token punctuation">[</span>field value ···<span class="token punctuation">]</span>
<span class="token comment"># 为哈希表key中field键的值加上增量n</span>
HINCRBY key field n  
<span class="token comment"># 删除指定的field，可以一次删除多个</span>
HDEL key field <span class="token punctuation">[</span>field···<span class="token punctuation">]</span>
<span class="token comment"># 删除HASH的对象</span>
DEL key <span class="token punctuation">[</span>key···<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="读操作" tabindex="-1"><a class="header-anchor" href="#读操作" aria-hidden="true">#</a> 读操作</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 获取哈希表key对应的field键值</span>
HGET key field
<span class="token comment"># 获取全部数据</span>
HGETALL key
<span class="token comment"># 查找hash中元素个数</span>
HLEN key
<span class="token comment"># 从指定位置查询一定数量的数据</span>
HSCAN key cursor <span class="token punctuation">[</span>MATCH pattern<span class="token punctuation">]</span><span class="token punctuation">[</span>COUNT count<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>如果是小数量下，处于ZIPLIST下，COUNT不管填多少都是返回全部，因为ZIPLIST本身就用于小集合，没必要再切分成几段来返回</li></ul><h3 id="应用场景-2" tabindex="-1"><a class="header-anchor" href="#应用场景-2" aria-hidden="true">#</a> 应用场景</h3><h4 id="缓存对象-1" tabindex="-1"><a class="header-anchor" href="#缓存对象-1" aria-hidden="true">#</a> 缓存对象</h4><p>Hash类型的（key，field，value）的结构与对象的（对象id，属性，值）的结构相似，可以用来存储对象</p><p>存储在关系型数据库中的简单用户信息</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/用户信息.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>将用户对象信息存储到Hash类型中</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 存储一个哈希表uid:1的键值</span>
<span class="token operator">&gt;</span> HMSET uid:1 name Tom age <span class="token number">15</span>
<span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 存储一个哈希表uid:2的键值</span>
<span class="token operator">&gt;</span> HMSET uid:2 name Jerry age <span class="token number">13</span>
<span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 获取哈希表用户id为1中所有的键值</span>
<span class="token operator">&gt;</span> HGETALL uid:1
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;name&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;Tom&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;age&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;15&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/hash存储结构.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>String + JSON也可以实现存储对象</li><li>一般对象使用String + JSON存储，对象中频繁变化的属性可以考虑抽出来用Hash类型存储</li></ul><h4 id="购物车" tabindex="-1"><a class="header-anchor" href="#购物车" aria-hidden="true">#</a> 购物车</h4><p>以用户id为key，商品id为field，商品数量为value，恰好构成购物车的3个要素</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/购物车.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>添加商品：<code>HSET cart:{用户id} {商品id} 1</code></li><li>添加数量：<code>HINCRBY cart:{用户id} {商品id} 1</code></li><li>商品总数：<code>HLEN cart{用户id}</code></li><li>删除商品：<code>HDEL cart{用户id} {商品id} </code></li><li>获取购物车所有商品：<code>HGETALL cart:{用户id}</code></li></ul><h2 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> Set</h2><p>Set类型是一个无需并且唯一的键值集合，它的存储顺序不会按照插入的先后顺序存储</p><p>一个集合最多可以存储$2^{32-1}$个元素，</p><p>Set类型除了支持集合内的增删改查，同时还支持多个集合取交集并集差集</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/set.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Set类型和List类型的区别</p><ul><li>List可以存储重复元素，Set只能存储非重复元素</li><li>List是按照元素先后顺序排序，Set是无序方式存储元素</li></ul><h3 id="内部实现-3" tabindex="-1"><a class="header-anchor" href="#内部实现-3" aria-hidden="true">#</a> 内部实现</h3><p>如果集群元素都是整数，且元素个数不超过512个，就可以用INTSET编码。</p><p>INTSET排列紧凑，占用内存少，但是查找需要用2分查找</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231105145732426.png" alt="image-20231105145732426" tabindex="0" loading="lazy"><figcaption>image-20231105145732426</figcaption></figure><p>如果不满足INTSET的结构，就要使用HASHTABLE编码，HASHTABLE的查询效率很高，$O(1)$时间就能查到一个元素是否存在</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231105145818314.png" alt="image-20231105145818314" tabindex="0" loading="lazy"><figcaption>image-20231105145818314</figcaption></figure><h3 id="常用命令-2" tabindex="-1"><a class="header-anchor" href="#常用命令-2" aria-hidden="true">#</a> 常用命令</h3><h4 id="写操作-1" tabindex="-1"><a class="header-anchor" href="#写操作-1" aria-hidden="true">#</a> 写操作</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 往集合key中存入元素，元素存在则忽略，若key不存在则新建</span>
SADD key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 从集合key中删除元素</span>
SREM key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="读操作-1" tabindex="-1"><a class="header-anchor" href="#读操作-1" aria-hidden="true">#</a> 读操作</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 获取集合key中所有元素</span>
SMEMBERS key
<span class="token comment"># 获取集合key中的元素个数</span>
SCARD key
<span class="token comment"># 查看集合元素，指定游标进行查询，可以指定个数</span>
SSCAN key cursor <span class="token punctuation">[</span>MATCH pattern<span class="token punctuation">]</span><span class="token punctuation">[</span>COUNT count<span class="token punctuation">]</span>

<span class="token comment"># 判断member元素是否存在于集合key中</span>
SISMEMBER key member

<span class="token comment"># 从集合key中随机选出count个元素，元素不从key中删除</span>
SRANDMEMBER key <span class="token punctuation">[</span>count<span class="token punctuation">]</span>
<span class="token comment"># 从集合key中随机选出count个元素，元素从key中删除</span>
SPOP key <span class="token punctuation">[</span>count<span class="token punctuation">]</span>

<span class="token comment"># 交集运算——返回在第一个集合里，同时也在后面所有集合都存在的元素</span>
SINTER key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 将交集结果存入新集合destination中</span>
SINTERSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 并集运算——返回所有集合的并集，集合个数大于等于2</span>
SUNION key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 将并集结果存入新集合destination中</span>
SUNIONSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 差集运算——返回第一个集合有，且在后续集合中不存在的元素，集合个数大于等于2</span>
<span class="token comment"># 是以第一个集合和后面比，看第一个集合多了哪些元素</span>
SDIFF key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 将差集结果存入新集合destination中</span>
SDIFFSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="应用场景-3" tabindex="-1"><a class="header-anchor" href="#应用场景-3" aria-hidden="true">#</a> 应用场景</h3><p>集合的主要几个特性，<strong>无序、不可重复、支持并交差</strong>等操作</p><p>Set 类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。</p><p><strong>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞</strong>。</p><p>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。</p><h4 id="点赞" tabindex="-1"><a class="header-anchor" href="#点赞" aria-hidden="true">#</a> 点赞</h4><p>Set类型可以保证<strong>一个用户只点一次赞</strong></p><p>key是文章id，value是用户id</p><p><code>uid:1</code>、<code>uid:2</code>、<code>uid:3</code>三个用户分别对<code>article:1</code>文章点赞</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># uid:1 用户对文章 article:1 点赞</span>
<span class="token operator">&gt;</span> SADD article:1 uid:1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 

<span class="token comment"># uid:2 用户对文章 article:1 点赞</span>
<span class="token operator">&gt;</span> SADD article:1 uid:2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>

<span class="token comment"># uid:3 用户对文章 article:1 点赞</span>
<span class="token operator">&gt;</span> SADD article:1 uid:3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>uid:1</code>用户取消对<code>article:1</code>文章点赞</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> SREM article:1 uid:1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>获取 <code>article:1</code> 文章所有点赞用户 :</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> SMEMBERS article:1
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;uid:3&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;uid:2&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取 <code>article:1</code> 文章的点赞用户数量：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> SCARD article:1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>判断用户 <code>uid:1</code> 是否对文章 <code>article:1</code> 点赞了：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> SISMEMBER article:1 uid:1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>  <span class="token comment"># 返回0说明没点赞，返回1则说明点赞了</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="共同关注" tabindex="-1"><a class="header-anchor" href="#共同关注" aria-hidden="true">#</a> 共同关注</h4><p>Set类型支持交集运算，所以可以用来计算共同关注的好友，公众号等</p><p>key为用户id，value则是关注的公众号id</p><p><code>uid:1</code> 用户关注公众号 id 为 5、6、7、8、9，<code>uid:2</code> 用户关注公众号 id 为 7、8、9、10、11。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># uid:1 用户关注公众号 id 为 5、6、7、8、9</span>
<span class="token operator">&gt;</span> SADD uid:1 <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>

<span class="token comment"># uid:2  用户关注公众号 id 为 7、8、9、10、11</span>
<span class="token operator">&gt;</span> SADD uid:2 <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">10</span> <span class="token number">11</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>uid:1</code> 和 <code>uid:2</code> 共同关注的公众号：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 获取共同关注</span>
<span class="token operator">&gt;</span> SINTER uid:1 uid:2
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;7&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;8&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;9&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>给 <code>uid:2</code> 推荐 <code>uid:1</code> 关注的公众号：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> SDIFF uid:1 uid:2
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;5&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;6&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>验证某个公众号是否同时被 <code>uid:1</code> 或 <code>uid:2</code> 关注:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> SISMEMBER uid:1 <span class="token number">5</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span> <span class="token comment"># 返回0，说明关注了</span>

<span class="token operator">&gt;</span> SISMEMBER uid:2 <span class="token number">5</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span> <span class="token comment"># 返回0，说明没关注</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="抽奖活动" tabindex="-1"><a class="header-anchor" href="#抽奖活动" aria-hidden="true">#</a> 抽奖活动</h4><p>存储活动中奖的用户名，可以保证一个用户不会中两次奖</p><p>key为抽奖活动名，value为员工名称</p><p>将所有员工名称放入抽奖箱</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span>SADD lucky Tom Jerry John Sean Marry Lindy Sary Mark
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>允许重复中奖</p><p>如果允许重复中奖，可以使用 <code>SRANDMEMBER</code> 命令。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 抽取 1 个一等奖：</span>
<span class="token operator">&gt;</span> SRANDMEMBER lucky <span class="token number">1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;Tom&quot;</span>

<span class="token comment"># 抽取 2 个二等奖：</span>
<span class="token operator">&gt;</span> SRANDMEMBER lucky <span class="token number">2</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;Mark&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;Jerry&quot;</span>

<span class="token comment"># 抽取 3 个三等奖：</span>
<span class="token operator">&gt;</span> SRANDMEMBER lucky <span class="token number">3</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;Sary&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;Tom&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;Jerry&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果不允许重复中奖，可以使用 <code>SPOP</code> 命令。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 抽取一等奖1个</span>
<span class="token operator">&gt;</span> SPOP lucky <span class="token number">1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;Sary&quot;</span>

<span class="token comment"># 抽取二等奖2个</span>
<span class="token operator">&gt;</span> SPOP lucky <span class="token number">2</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;Jerry&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;Mark&quot;</span>

<span class="token comment"># 抽取三等奖3个</span>
<span class="token operator">&gt;</span> SPOP lucky <span class="token number">3</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;John&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;Sean&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;Lindy&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="hashtable" tabindex="-1"><a class="header-anchor" href="#hashtable" aria-hidden="true">#</a> HASHTABLE</h2><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h3><p>HASHTABLE可以想象成目录，要看什么内容直接翻目录。</p><p>HASHTABLE可以实现快速索引，通过HASHTABLE只需要$O(1)$的时间就可以查到key对应的value</p><h3 id="hashtable结构" tabindex="-1"><a class="header-anchor" href="#hashtable结构" aria-hidden="true">#</a> HASHTABLE结构</h3><h4 id="dictht" tabindex="-1"><a class="header-anchor" href="#dictht" aria-hidden="true">#</a> dictht</h4><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231105220949245.png" alt="image-20231105220949245" tabindex="0" loading="lazy"><figcaption>image-20231105220949245</figcaption></figure><ul><li><code>table</code>：是一个数组，指向<code>dictEntry</code>结构 <ul><li><code>dictEntry</code>：保存着一个键值对 <ul><li><code>key</code>：保存键值对中的键</li><li><code>value</code>：保存键值对中的值</li><li><code>next</code>：指向下一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，从而解决哈希冲突</li></ul></li></ul></li><li><code>size</code>：记录了哈希表的大小，也就是<code>dictEntry</code>有多少元素空间，一般为 $2^n$，默认为4</li><li><code>sizemask</code>：哈希掩码，用于表示可存储位置，值为<code>size-1</code></li><li><code>used</code>：记录了哈希表目前已有节点(键值对)的数量</li></ul><h4 id="计算元素存储位置" tabindex="-1"><a class="header-anchor" href="#计算元素存储位置" aria-hidden="true">#</a> 计算元素存储位置</h4><p><strong>索引计算公式</strong>：<code>index = Murmurhash2(field) &amp; sizemask</code></p><ol><li><p>通过<code>Murmurhash2</code>算法求出<code>field</code>的哈希值，计算出来的哈希值为32为整数(<code>hash = Murmurhash2(field)</code>)</p><ul><li><code>Murmurhash2</code>算法可以将能够被ASCII码解析的文本转化为一个32位整数 <ul><li>例如：英文，数字，中文···</li></ul></li></ul></li><li><p>将<code>field</code>的哈希值与HASHTABLE的<code>sizemask</code>进行与运算，得出该数据在HASHTABLE中存储的哈希桶索引(<code>index=hash&amp;sizemask</code>)</p><ul><li><code>sizemask</code>：该值为HASHTABLE大小(size) - 1 <ul><li>一般HASHTABLE的<code>size</code>大小都为$2^n$，所以<code>size-1</code>得出来的值转二进制是连续的<code>n-1</code>位1 <ul><li>例如：<code>64 -&gt; (0100 0000)</code>，<code>63 -&gt; (0011 1111)</code></li><li><code>sizemask</code>的作用计算为了限定<code>index</code>的值只能在<code>[0,size)</code>以内</li></ul></li></ul></li></ul></li></ol><h3 id="hash表渐进式扩容" tabindex="-1"><a class="header-anchor" href="#hash表渐进式扩容" aria-hidden="true">#</a> Hash表渐进式扩容</h3><p>一点点扩容，而不是一次性扩容</p><p>为了实现渐进式扩容，Redis没有将dictht直接暴露给上层，而是多封装了一层dict</p><h4 id="dict" tabindex="-1"><a class="header-anchor" href="#dict" aria-hidden="true">#</a> dict</h4><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231105222305899-16993363323961.png" alt="image-20231105222305899" tabindex="0" loading="lazy"><figcaption>image-20231105222305899</figcaption></figure><ul><li><code>type</code>：指向<code>dictType</code>结构的指针，每个<code>dictType</code>都保存了一簇用于操作特定键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数</li><li><code>privdata</code>：保存了需要传给那些类型特定函数的可选参数</li><li><code>ht</code>：是一个包含两个项的数组，数组中的每个项都是一个<code>dictht</code>哈希表 <ul><li>一般情况下，字典只是用<code>ht[0]</code>哈希表，<code>ht[1]</code>哈希表只会在对<code>ht[0]</code>哈希表进行<code>rehash</code>时使用</li></ul></li><li><code>rehashidx</code>：记录了<code>rehash</code>目前的进度 <ul><li>如果目前没有进行<code>rehash</code>，那么它的值为-1</li></ul></li></ul><h4 id="rehash" tabindex="-1"><a class="header-anchor" href="#rehash" aria-hidden="true">#</a> rehash</h4><h5 id="一次性rehash" tabindex="-1"><a class="header-anchor" href="#一次性rehash" aria-hidden="true">#</a> 一次性rehash</h5><p>平时使用的只有一个HASHTABLE，在触发扩容后，就会两个HASHTABLE同时使用</p><p>当向字典添加元素时，发现需要扩容就会进行<code>rehash</code>。<code>rehash</code>大概分为3步：</p><ol><li>给<code>ht[1]</code>分配空间</li><li>将<code>ht[0]</code>的数据迁移到<code>ht[1]</code>中</li><li>迁移完成后，<code>ht[0]</code>的空间会被释放，并把<code>ht[1]</code>设置为<code>ht[0]</code>，然后在<code>ht[1]</code>新创建一个空白的哈希表，为下次的rehash做准备</li></ol><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231105225026314.png" alt="image-20231105225026314" tabindex="0" loading="lazy"><figcaption>image-20231105225026314</figcaption></figure><p>如果<code>ht[0]</code>的数据量非常大，那么在迁移至<code>ht[1]</code>的时候会因为设计大量的数据拷贝，此时可能会对Redis造成阻塞，无法访问其他请求</p><h5 id="渐进式rehash" tabindex="-1"><a class="header-anchor" href="#渐进式rehash" aria-hidden="true">#</a> 渐进式rehash</h5><p>渐进式rehash步骤如下</p><ol><li>给<code>ht[1]</code>分配空间 <ul><li>新表大小为第一个大于等于原表两倍used的2次方幂</li><li>例如：原表used=500，两倍就是1000，第一个大于1000的2次方幂就是1024</li></ul></li><li>在rehash期间，每次哈希表元素进行<strong>增删改查</strong>时，Redis除了会执行对应的操作之外，还会<strong>按顺序</strong>将<code>ht[0]</code>中索引位置上所有的<code>key-value</code>迁移到<code>ht[1]</code>中 <ul><li><strong>按顺序</strong>是指按照<code>rehashidx</code>指向位置的哈希桶，整桶迁移</li><li><code>rehashidx</code>移动到空桶会向下继续移动，但是只能移动10次，10次内找不到就不动了</li><li>对于<strong>新增</strong>操作，如果当前在<code>rehash</code>中，为了不拖慢<code>rehash</code>进度，直接放在<code>ht[1]</code></li><li>对于<strong>查改删</strong>操作，能在<code>ht[0]</code>解决问题就不去访问<code>ht[1]</code>，解决不了再去访问<code>ht[1]</code></li></ul></li><li>随着处理客户端发起的哈希表操作请求越来越多，最终某个时间点会将<code>ht[1]</code>所有 <code>key-value</code> 迁移到<code>ht[0]</code>，从而完成 <code>rehash</code> 操作 <ul><li>移动完成之后，<code>ht[1]</code>和<code>ht[0]</code>的指针会互换，然后删除<code>ht[0]</code>的内存空间</li></ul></li></ol><h4 id="扩容的时机" tabindex="-1"><a class="header-anchor" href="#扩容的时机" aria-hidden="true">#</a> 扩容的时机</h4><p>负载因子(load factor)</p><p><strong>负载因子 = 哈希表已保存节点数量 / 哈希表大小 = <code>used / size</code></strong></p><p>触发 rehash 操作的条件，主要有两个：</p><ul><li>当负载因子<strong>大于等于 1</strong> ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是<strong>没有执行 RDB 快照</strong>或<strong>没有进行 AOF 重写</strong>的时候，就会进行 rehash 操作。</li><li>当负载因子<strong>大于等于 5</strong> 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会<strong>强制进行 rehash</strong> 操作。</li></ul><blockquote><p><strong>为什么rehash要在没有执行快照或重写的时候进行</strong></p></blockquote><ul><li><strong>避免数据移动对AOF重写的影响：</strong> AOF重写时，主进程需要执行写时复制，而rehash操作会导致大量的数据移动。这样，父进程中的内存修改较多，增加了AOF重写的负担，因此在执行AOF重写时，避免了rehash操作，确保AOF重写的效率 <ul><li>AOF重写缓冲区中会存放AOF重写过程中主进程收到的命令，还会存放渐进式rehash的数据迁移命令，双倍负担</li><li>执行客户端发来的更新操作会复制一块内存空间出来操作，执行渐进式rehash的数据迁移命令也会复制一块内存空间出来操作，双倍空间</li></ul></li><li><strong>防止在RDB备份过程中的冲突：</strong> 当执行RDB备份操作时，rehash也会导致数据移动，可能与备份的数据存在冲突。通过在执行RDB备份时避免rehash，确保备份的一致性。</li><li><strong>维持系统性能稳定：</strong> 在执行快照或AOF重写时，系统资源已经被占用，同时进行rehash可能导致性能下降。因此，在这些操作进行时，避免执行rehash有助于维持系统的性能稳定。</li></ul><blockquote><p><strong>如果rehash到一半，再也没有命令来访问这个哈希表了</strong></p></blockquote><ul><li>数据没法完整进行迁移，一直占用着两张表</li><li>这个问题Redis没有解决，也没有分配专门的线程完成数据迁移</li></ul><h3 id="缩容" tabindex="-1"><a class="header-anchor" href="#缩容" aria-hidden="true">#</a> 缩容</h3><ul><li><p>缩容的过程跟扩容一样，都是渐进式的，都是利用<code>ht[0]</code>和<code>ht[1]</code>来完成</p></li><li><p>负载因子小于等于0.1，即负载率&lt;10%，此时进行缩容，新表大小为第一个大于等于原表used的2次方幂</p></li><li><p>如果有<code>BGSAVE</code>或<code>BGREWRITEAOF</code>这两个复制命令，缩容也会受影响，不会进行。</p></li></ul><h2 id="skiplist" tabindex="-1"><a class="header-anchor" href="#skiplist" aria-hidden="true">#</a> SKIPLIST</h2><h3 id="跳表结构" tabindex="-1"><a class="header-anchor" href="#跳表结构" aria-hidden="true">#</a> 跳表结构</h3><p>跳表是链表基础上改进的，实现了一种多层的有序链表，这样的好处是为了快速定位数据</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231106125441298.png" alt="image-20231106125441298" tabindex="0" loading="lazy"><figcaption>image-20231106125441298</figcaption></figure><p>跳表的节点不只有一层，普通链表只能一步一步往后走，而跳表可以一次多走几步。理论上，<strong>层次越高平均步长越大</strong>，但并不是像图中一样绝对均衡，节点的层高是概率随机的。</p><ul><li><strong>查找</strong>分数为35的数据 <ul><li>如果只有原始的链表，那需要走4步</li><li>如果有图中的二级索引，只用走一步，那如果找45呢，其实就是从第1个节点出发，通过二级索引走到35，再查看到下一个节点是65，已经超过了，所以降低到下方的索引，也就是一级索引，往后走一次就可以找到45。</li></ul></li><li><strong>插入</strong>一条score为36的数据 <ul><li>每定位一个元素就判断下一个元素的值是否大于score值 <ul><li>若不大于，则继续定位下一个元素</li><li>若大于，则构造一个新的节点。这里我们假设节点层高随机到3</li></ul></li><li>最后将各层链表补齐，其实就是在每一层进行连接</li></ul></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231106125906221.png" alt="image-20231106125906221" tabindex="0" loading="lazy"><figcaption>image-20231106125906221</figcaption></figure><p>标准的跳表会有如下限制：</p><ul><li>score的值不能重复</li><li>只有前向指针，没有回退指针</li></ul><h3 id="redis的跳表实现" tabindex="-1"><a class="header-anchor" href="#redis的跳表实现" aria-hidden="true">#</a> Redis的跳表实现</h3><p>Redis中只有Zset对象的底层实现用到了跳表，跳表的又是是能支持平均$O(logN)$复杂度的节点查找</p><h4 id="zset" tabindex="-1"><a class="header-anchor" href="#zset" aria-hidden="true">#</a> zset</h4><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zset</span> <span class="token punctuation">{</span>
    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>
    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span>
<span class="token punctuation">}</span> zset<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>dict</code>：哈希表，用来以常数复杂度获取元素权重</li><li><code>zskiplist</code>：跳表，实现数据操作</li></ul><p>Zset对象在执行插入或是更新的过程中，会依次在跳表和哈希表中插入或更新相应的数据，从而保证跳表和哈希表中记录的信息一致</p><h4 id="zskiplist" tabindex="-1"><a class="header-anchor" href="#zskiplist" aria-hidden="true">#</a> zskiplist</h4><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplist</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>header<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> level<span class="token punctuation">;</span>
<span class="token punctuation">}</span> zskiplist<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>header</code>，<code>tail</code>：跳表的头尾节点，便于在$O(1)$时间内访问跳表的头节点和尾节点</li><li><code>length</code>：跳表的长度，跳表节点的数量</li><li><code>level</code>：跳表的最大层数，跳表中层高最大的那个节点的曾数量</li></ul><h4 id="zskiplistnode" tabindex="-1"><a class="header-anchor" href="#zskiplistnode" aria-hidden="true">#</a> zskiplistNode</h4><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231106130108143.png" alt="image-20231106130108143" tabindex="0" loading="lazy"><figcaption>image-20231106130108143</figcaption></figure><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token punctuation">{</span>
    <span class="token comment">//Zset 对象的元素值</span>
    sds ele<span class="token punctuation">;</span>
    <span class="token comment">//元素权重值</span>
    <span class="token keyword">double</span> score<span class="token punctuation">;</span>
    <span class="token comment">//后向指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>backward<span class="token punctuation">;</span>
  
    <span class="token comment">//节点的level数组，保存每层上的前向指针和跨度</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>forward<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> span<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> zskiplistNode<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>ele</code>：SDS结构，用来存储数据</li><li><code>score</code>：节点的分数，浮点型数据</li><li><code>backward</code>：指向上一个节点的回退指针，支持从尾向头遍历(<code>ZREVRANGE</code>) <ul><li>回退指针是用来从后往前遍历跳表的</li><li>回退指针的设置是为了<code>ZREVRANGE</code>命令</li><li>倒序获取有序集合<code>key</code>从<code>start</code>下标到<code>stop</code>下标的元素：<code>ZREVRANGE key start stop [WITHSCORES]</code></li></ul></li><li><code>level</code>：是个<code>zskiplistLevel</code>结构体数组，<code>zskiplistLevel</code>这个结构体包含了两个字段 <ul><li><code>forward</code>：指向该层下一个能跳的节点</li><li><code>span</code>：记录了距离下一个节点的跨度 <ul><li>跨度是用来计算这个节点在跳表中的排名 <ul><li>排名就是头节点到当前节点途径的span之和</li></ul></li><li>跨度的设置是为了<code>ZRANK</code>命令</li><li>查看zset中<code>member</code>的排名索引，从0开始，分数越高排名越高</li></ul></li><li>该数据结构表示每个节点可能是多层结构</li><li><code>level[0]</code>表示第一层，<code>level[1]</code>表示第二层</li></ul></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231106131350327.png" alt="image-20231106131350327" tabindex="0" loading="lazy"><figcaption>image-20231106131350327</figcaption></figure><p><strong>跨度是怎样计算排名的</strong></p><blockquote><ul><li><strong>跳表中的节点都是按序排列</strong>。计算某个节点排名的时候，从头节点到该结点的<strong>查询路径上</strong>，将<strong>沿途访问过的所有层的跨度</strong>累加起来，得到的结果就是目标节点在跳表中的<strong>排名</strong>。</li><li>查找图中节点 3 在跳表中的排名，从头节点开始查找节点 3，查找的过程只经过了一个层（L2），并且层的跨度是 3，所以节点 3 在跳表中的排名是 3。</li></ul></blockquote><p><strong>Redis跳表单个节点有几层</strong></p><blockquote><ul><li>层次的决定需要随机，才能在各个场景<strong>表现出较为平均的性能</strong></li><li>Redis采用<strong>概率均衡</strong>的思路来确定新插入的节点的层数</li><li>Redis跳表决定每一个节点<strong>能否增加一层的概率为25%</strong>，最大层数限制在Redis<strong>5.0是64层</strong>，在Redis<strong>7.0是32层</strong></li></ul></blockquote><p><strong>为什么7.0反而改成32层了？</strong></p><blockquote><ul><li>从现实层面看，一般现实中<strong>达不到</strong>那么大的跳表，10层的跳表就能容纳百万个元素了</li><li>从数学方面看，<strong>概率计算最佳的高度</strong>其实就是32</li><li>而且改成32可以<strong>节省内存</strong>，略微提升性能。</li></ul></blockquote><p><strong>Redis跳表的性能优化了多少</strong></p><blockquote><ul><li>跳表的查找过程是走高层，走得通就跳过去，走不通就往下走，很像二叉树的另一种表现形式、而实际上他们的性能也是差不多的，平均时间复杂度都是$O(logN)$，区别是二叉树最坏的时间复杂度也是$O(logN)$，而跳表最坏的时间复杂度是$O(N)$。但是，实际的生产过程中，体现出来的基本都是跳表中的平均时间复杂度</li><li>有序集合的增删查操作都需要先定位元素位置，跳表将这三个操作的时间复杂度都从$O(N)$降到$O(logN)$</li></ul></blockquote><h3 id="跳表节点查询过程" tabindex="-1"><a class="header-anchor" href="#跳表节点查询过程" aria-hidden="true">#</a> 跳表节点查询过程</h3><p>从头节点的最高层开始，逐一遍历每一层</p><p>遍历到某一层的跳表节点时，会用跳表节点中的SDS类型的元素和权重来判断：</p><ul><li><p>如果当前节点的权重 &lt; 要查找的权重时，跳表会访问该层的下一个节点</p></li><li><p>如果当前节点的权重 = 要查找的权重，并且当前节点的SDS类型数据 &lt; 要查找的数据时，跳表就会访问该层的下一个节点</p></li><li><p>若两个条件都不满足，或下一节点为空时，跳表就会使用目前遍历到的节点的<code>level</code>数组里的下一层指针沿着下一层指针继续查找，这就相当于跳到下一层接着查</p></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231106140649138.png" alt="image-20231106140649138" tabindex="0" loading="lazy"><figcaption>image-20231106140649138</figcaption></figure><p>例如：以上面这个3层级的跳表为例，要查找<code>{ele: &#39;abcd&#39;; score: &#39;4&#39;}</code>节点，查找过程是这样的</p><ul><li>先从头节点的最高层开始，L2指向了<code>{ele: &#39;abc&#39;; score: &#39;3&#39;}</code>节点，判断得权重小于待查找节点，要访问改成的下一个节点</li><li>该层(<code>level[2]</code>)的下一个节点为空节点，所以跳到<code>{ele: &#39;abc&#39;; score: &#39;3&#39;}</code>节点的下一层(<code>level[1]</code>)</li><li><code>{ele: &#39;abc&#39;; score: &#39;3&#39;}</code>节点的<code>level[1]</code>的下一个指针指向<code>{ele: &#39;abcde&#39;; score: &#39;4&#39;}</code>节点，虽然该节点的权重等于待查找节点的权重，但是明显SDS类型数据值不相同，所以会继续跳到<code>{ele: &#39;abc&#39;; score: &#39;3&#39;}</code>节点的下一层(<code>level[0]</code>)去找</li><li><code>{ele: &#39;abc&#39;; score: &#39;3&#39;}</code>节点的<code>level[0]</code>的下一个指针指向了<code>{ele: &#39;abcd&#39;; score: &#39;4&#39;}</code>节点，元素与权重都一致，查找结束。</li></ul><h3 id="跳表节点的层数设置" tabindex="-1"><a class="header-anchor" href="#跳表节点的层数设置" aria-hidden="true">#</a> 跳表节点的层数设置</h3><p>跳表的相邻两层的节点数量的比例会影响跳表的查询性能</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231106143858309.png" alt="image-20231106143858309" tabindex="0" loading="lazy"><figcaption>image-20231106143858309</figcaption></figure><p>像上面这种跳表要查询到后面的节点，基本上就是$O(N)$的时间复杂度了</p><p>所以为了降低查询时间复杂度，我们应该维持好节点之间的层数比例</p><p><strong>跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)</strong>。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231106144027576.png" alt="image-20231106144027576" tabindex="0" loading="lazy"><figcaption>image-20231106144027576</figcaption></figure><p>这就是一个理想比例的跳表</p><p><strong>怎样维持跳表的相邻两层节点数量比例</strong></p><blockquote><ul><li>如果采用新增节点或者删除节点时，来调整跳表节点以维持比例的方法的话，会带来额外的开销。</li><li>Redis 则采用一种巧妙的方法是，<strong>跳表在创建节点的时候，随机生成每个节点的层数</strong>，并没有严格维持相邻两层的节点数量比例为 $2 / 1$ 的情况。</li><li>具体的做法是，<strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。</li><li>这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64。</li><li>虽然我前面讲解跳表的时候，图中的跳表的「头节点」都是 3 层高，但是其实<strong>如果层高最大限制是 64，那么在创建跳表「头节点」的时候，就会直接创建 64 层高的头节点</strong>。</li></ul></blockquote><p><strong>为什么用跳表不用平衡树</strong></p><blockquote><p><strong>内存灵活</strong></p><ul><li>跳表可以通过调整p来灵活设计其内存大小</li><li>可以将其设计得很高，对应的内存就较高，也可以设计的很矮，那内存占用就少了</li></ul><p><strong>范围查找：跳表比平衡树操作简单</strong></p><ul><li>平衡树上，找到指定范围的小值之后，还需要中序遍历的顺序继续寻找其他不超过大值的节点。如果不对平衡树进行改造，这里的中序遍历并不容易实现</li><li>而跳表上进行范围查询就非常简单，只需要找到小值后，对第一层的链表进行若干步遍历就能实现</li></ul><p><strong>算法实现：跳表比平衡树简单</strong></p><ul><li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂</li><li>而跳表的插入和删除只需要修改相邻节点的指针，操作简单快速</li></ul></blockquote><p><strong>为什么用跳表不用B+树</strong></p><blockquote><ul><li><strong>二者应用场景不同，B+树更多用于磁盘型数据库</strong>，它索引层级低（对应树矮），磁盘IO次数就更少，这是它的优势而对于<strong>Redis这种基于内存</strong>的来说，层级高矮不是什么优劣势，因为<strong>不涉及磁盘IO</strong></li><li>B+树需要维护树的结构，</li></ul></blockquote><h2 id="zset-1" tabindex="-1"><a class="header-anchor" href="#zset-1" aria-hidden="true">#</a> Zset</h2><p>有序集合类型，比Set类型多了个排序属性score(分值)</p><p>对于有序集合Zset来说，每个存储元素像待遇由两个值组成</p><ul><li><p>有序集合的元素值</p></li><li><p>排序值</p></li></ul><p>有序集合保留了集合不能由重复成员的特性（Score可以重复）</p><p>不同的是有序集合中的元素可以排序</p><p>按score大小排序，score相等时，按字典序排序（e.g.: b&gt;a）</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/zset-169929069688721.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="内部实现-4" tabindex="-1"><a class="header-anchor" href="#内部实现-4" aria-hidden="true">#</a> 内部实现</h3><p>Zset类型的底层数据是由压缩列表或跳表实现的</p><ul><li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231106205513661-16992905010316.png" alt="image-20231106205513661" tabindex="0" loading="lazy"><figcaption>image-20231106205513661</figcaption></figure><ul><li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构； <ul><li>跳表中包含了SKIPLIST和HASHTABLE两种结构</li><li>HASHTABLE用于在$O(1)$时间内查到成员分数值</li></ul></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231106205646505-16992905038637.png" alt="image-20231106205646505" tabindex="0" loading="lazy"><figcaption>image-20231106205646505</figcaption></figure><p>Redis7.0中，压缩列表已被替换为<code>listpack</code>数据结构</p><h3 id="常用命令-3" tabindex="-1"><a class="header-anchor" href="#常用命令-3" aria-hidden="true">#</a> 常用命令</h3><h4 id="常用操作" tabindex="-1"><a class="header-anchor" href="#常用操作" aria-hidden="true">#</a> 常用操作</h4><h4 id="写操作-2" tabindex="-1"><a class="header-anchor" href="#写操作-2" aria-hidden="true">#</a> 写操作</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 往有序集合key中加入带分值元素</span>
ZADD key score member <span class="token punctuation">[</span><span class="token punctuation">[</span>score member<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>   
<span class="token comment"># 为有序集合key中元素member的分值加上increment</span>
ZINCRBY key increment member 
<span class="token comment"># 往有序集合key中删除元素</span>
ZREM key member <span class="token punctuation">[</span>member<span class="token punctuation">..</span>.<span class="token punctuation">]</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="读操作-2" tabindex="-1"><a class="header-anchor" href="#读操作-2" aria-hidden="true">#</a> 读操作</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 返回有序集合key中元素个数</span>
ZCARD key 

<span class="token comment"># 正序获取有序集合key从start下标到stop下标的元素 ——按位置排序</span>
ZRANGE key start stop <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span>
<span class="token comment"># 返回有序集合中指定分数区间内的成员，分数由低到高排序。 ——按分数排序</span>
ZRANGEBYSCORE key min max <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span> <span class="token punctuation">[</span>LIMIT offset count<span class="token punctuation">]</span>

<span class="token comment"># 返回指定成员区间内的成员，按字典正序排列, 分数必须相同。 ——按字典排序</span>
ZRANGEBYLEX key min max <span class="token punctuation">[</span>LIMIT offset count<span class="token punctuation">]</span>
<span class="token comment"># 返回指定成员区间内的成员，按字典倒序排列, 分数必须相同 ——按字典排序</span>
ZREVRANGEBYLEX key max min <span class="token punctuation">[</span>LIMIT offset count<span class="token punctuation">]</span>

<span class="token comment"># 倒序获取有序集合key从start下标到stop下标的元素</span>
ZREVRANGE key start stop <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span>

<span class="token comment"># 计算min-max积分范围的成员个数</span>
ZCOUNT key min max
<span class="token comment"># 查看zset中member的排名索引，索引从0开始，如果排第一，索引就是0</span>
ZRANK key member
<span class="token comment"># 返回有序集合key中元素member的分值</span>
ZSCORE key member
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例子： 假设有以下有序集合 <code>names</code>：</p><ol><li>Alice (score: 10)</li><li>Bob (score: 10)</li><li>Carol (score: 10)</li><li>Dave (score: 20)</li><li>Eve (score: 20)</li></ol><p>使用 <code>ZRANGEBYLEX names [Alice [Dave</code> 将返回 <code>[Alice, Bob, Carol]</code></p><p>这是按字母顺序的区间查询结果，并且这些成员具有相同的分数</p><blockquote><p>min和max属性可以传<code>[</code>和<code>(</code>，表示区间的闭和开</p></blockquote><h4 id="运算操作" tabindex="-1"><a class="header-anchor" href="#运算操作" aria-hidden="true">#</a> 运算操作</h4><p>相比于 Set 类型，ZSet 类型没有支持差集运算</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 并集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span>
ZUNIONSTORE destkey numberkeys key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span> 
<span class="token comment"># 交集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span>
ZINTERSTORE destkey numberkeys key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="应用场景-4" tabindex="-1"><a class="header-anchor" href="#应用场景-4" aria-hidden="true">#</a> 应用场景</h3><h4 id="排行榜" tabindex="-1"><a class="header-anchor" href="#排行榜" aria-hidden="true">#</a> 排行榜</h4><p>有序集合比较经典的使用场景就是<strong>排行榜</strong></p><p>例如学生成绩的排行榜、游戏积分排行榜、视频播放排名、电商系统中商品销量排名</p><p>以博文点赞排名为例：</p><p>小林发表了5篇博文，分别获得200、40、100、50、150的点赞数</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># arcticle:1 文章获得了200个赞</span>
<span class="token operator">&gt;</span> ZADD user:xiaolin:ranking <span class="token number">200</span> arcticle:1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>

<span class="token comment"># arcticle:2 文章获得了40个赞</span>
<span class="token operator">&gt;</span> ZADD user:xiaolin:ranking <span class="token number">40</span> arcticle:2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>

<span class="token comment"># arcticle:3 文章获得了100个赞</span>
<span class="token operator">&gt;</span> ZADD user:xiaolin:ranking <span class="token number">100</span> arcticle:3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 

<span class="token comment"># arcticle:4 文章获得了50个赞</span>
<span class="token operator">&gt;</span> ZADD user:xiaolin:ranking <span class="token number">50</span> arcticle:4
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>

<span class="token comment"># arcticle:5 文章获得了150个赞</span>
<span class="token operator">&gt;</span> ZADD user:xiaolin:ranking <span class="token number">150</span> arcticle:5
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>文章<code>article:4</code>添加一个赞，可以使用<code>ZINCRBY</code>命令</p><ul><li>为有序集合Key中元素member的分值加上increment</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> ZINCRBY user:xiaolin:ranking <span class="token number">1</span> article:4
<span class="token string">&quot;51&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>查看某篇文章的赞数，使用<code>ZSCORE</code>命令</p><ul><li>返回有序集合key中元素个数</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> ZSCORE user:xiaolin:ranking arcticle:4
<span class="token string">&quot;50&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>获取文章赞数最多的3篇，使用<code>ZREVRANGE</code>命令</p><ul><li>倒序获取有序集合key从start下标到stop下标的元素</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># WITHSCORES 表示把 score 也显示出来</span>
<span class="token operator">&gt;</span> ZREVRANGE user:xiaolin:ranking <span class="token number">0</span> <span class="token number">2</span> WITHSCORES
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;arcticle:1&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;200&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;arcticle:5&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;150&quot;</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;arcticle:3&quot;</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;100&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>获取100 赞到 200 赞的文章，可以使用 ZRANGEBYSCORE 命令</p><ul><li>返回有序集合中指定分数区间内的成员，分数由低到高排序</li></ul></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> ZRANGEBYSCORE user:xiaolin:ranking <span class="token number">100</span> <span class="token number">200</span> WITHSCORES
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;arcticle:3&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;100&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;arcticle:5&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;150&quot;</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;arcticle:1&quot;</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;200&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="延时队列" tabindex="-1"><a class="header-anchor" href="#延时队列" aria-hidden="true">#</a> 延时队列</h4><p>value存操作的事，score存要延时多久</p><p>让后台程序不断轮询查看score到期了没有，到期就取出来执行</p><p>一般可以用于：</p><ul><li>外卖超时取消订单</li><li>电商订单超时未支付取消订单</li><li>打车软件超时没司机接驾取消订单</li></ul><h2 id="stream" tabindex="-1"><a class="header-anchor" href="#stream" aria-hidden="true">#</a> Stream</h2><h3 id="概述-1" tabindex="-1"><a class="header-anchor" href="#概述-1" aria-hidden="true">#</a> 概述</h3><p>Redis Stream 是 Redis 5.0 版本新增加的数据类型，Redis 专门为消息队列设计的数据类型。</p><p>在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：</p><ul><li>pub/sub发布订阅模式，不能持久化也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷；</li><li>List 实现消息队列的方式不能重复消费，一个消息消费完就会被删除，而且生产者需要自行实现全局唯一 ID。</li></ul><p>基于以上问题，Redis 5.0 便推出了 Stream 类型也是此版本最重要的功能，用于完美地实现消息队列，它支持消息的持久化、支持自动生成全局唯一 ID、支持 ack 确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。</p><h3 id="常见命令" tabindex="-1"><a class="header-anchor" href="#常见命令" aria-hidden="true">#</a> 常见命令</h3><ul><li><code>XADD</code>：插入消息，保证有序，可以自动生成全局唯一 ID；</li><li><code>XLEN</code> ：查询消息长度；</li><li><code>XREAD</code>：用于读取消息，可以按 ID 读取数据；</li><li><code>XDEL</code> ： 根据消息 ID 删除消息；</li><li><code>DEL</code> ：删除整个 Stream；</li><li><code>XRANGE</code> ：读取区间消息</li><li><code>XREADGROUP</code>：按消费组形式读取消息；</li><li><code>XPENDING</code> 和 <code>XACK</code>： <ul><li><code>XPENDING</code> 命令可以用来查询每个消费组内所有消费者「已读取、但尚未确认」的消息；</li><li><code>XACK</code> 命令用于向消息队列确认消息处理已完成；</li></ul></li></ul><h3 id="应用场景-5" tabindex="-1"><a class="header-anchor" href="#应用场景-5" aria-hidden="true">#</a> 应用场景</h3><h4 id="基本消息队列" tabindex="-1"><a class="header-anchor" href="#基本消息队列" aria-hidden="true">#</a> 基本消息队列</h4><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231129003203280.png" alt="image-20231129003203280" tabindex="0" loading="lazy"><figcaption>image-20231129003203280</figcaption></figure><ul><li><strong>生产者</strong>通过<code>XADD</code>命令插入一条信息 <ul><li><code>*</code>表示为插入的数据自动生成一个全局唯一的ID</li><li>第一部分<code>1654254953808</code>是数据插入时，以毫秒为单位计算的当前服务器时间；</li><li>第二部分表示插入消息在当前毫秒内的消息序号 <ul><li>这是从 0 开始编号的。例如，“<code>1654254953808-0</code>”就表示在“<code>1654254953808</code>”毫秒内的第 1 条消息</li></ul></li></ul></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> XADD mymq * name xiaolin
<span class="token string">&quot;1654254953808-0&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>消费者</strong>通过<code>XREAD</code>命令从消息队列中读取消息 <ul><li>可以指定一个消息ID，并从这个消息ID的下一条消息开始进行读取</li></ul></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> XREAD STREAMS mymq <span class="token number">1654254953807</span>-0
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;mymq&quot;</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;1654254953808-0&quot;</span>
         <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;name&quot;</span>
            <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;xiaolin&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>如果<strong>想要实现阻塞读（当没有数据时，阻塞住），可以调用 XRAED 时设定 BLOCK 配置项</strong>，实现类似于 BRPOP 的阻塞读取操作。 <ul><li>比如，下面这命令，设置了 BLOCK 10000 的配置项，10000 的单位是毫秒</li><li>表明 XREAD 在读取最新消息时，如果没有消息到来，XREAD 将阻塞 10000 毫秒（即 10 秒），然后再返回</li><li><code>&amp;</code>表示读取最新的消息</li></ul></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> XREAD BLOCK <span class="token number">10000</span> STREAMS mymq $
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">10</span>.00s<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="消费组功能" tabindex="-1"><a class="header-anchor" href="#消费组功能" aria-hidden="true">#</a> 消费组功能</h4><ul><li>Stream 可以使用 <strong>XGROUP 创建消费组</strong><ul><li>创建消费组之后，Stream 可以使用 XREADGROUP 命令让消费组内的消费者读取消息</li><li>创建两个消费组，这两个消费组消费的消息队列是 mymq，都指定从第一条消息开始读取：</li></ul></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 创建一个名为 group1 的消费组，0-0 表示从第一条消息开始读取。</span>
<span class="token operator">&gt;</span> XGROUP CREATE mymq group1 <span class="token number">0</span>-0
OK
<span class="token comment"># 创建一个名为 group2 的消费组，0-0 表示从第一条消息开始读取。</span>
<span class="token operator">&gt;</span> XGROUP CREATE mymq group2 <span class="token number">0</span>-0
OK
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>消费组 group1 内的消费者 consumer1 从 mymq 消息队列中读取所有消息的命令如下</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 命令最后的参数“&gt;”，表示从第一条尚未被消费的消息开始读取。</span>
<span class="token operator">&gt;</span> XREADGROUP GROUP group1 consumer1 STREAMS mymq <span class="token operator">&gt;</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;mymq&quot;</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;1654254953808-0&quot;</span>
         <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;name&quot;</span>
            <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;xiaolin&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><strong>同一个消费组里的消费者不能消费同一条消息</strong></p><ul><li><strong>消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了</strong></li></ul></li><li><p><strong>不同消费组的消费者可以消费同一条消息</strong></p><ul><li><strong>但是有前提条件，创建消息组的时候，不同消费组指定了相同位置开始读取消息</strong></li></ul></li><li><p>使用消费组的目的是让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的</p></li></ul><h4 id="确认机制" tabindex="-1"><a class="header-anchor" href="#确认机制" aria-hidden="true">#</a> 确认机制</h4><p>Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 XACK 命令通知 Streams“消息已经处理完成”。</p><p>消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行 XACK 命令确认消息已经被消费完成</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231129004613316.png" alt="image-20231129004613316" tabindex="0" loading="lazy"><figcaption>image-20231129004613316</figcaption></figure><ul><li>如果消费者没有成功处理消息，它就不会给 Streams 发送 XACK 命令，消息仍然会留存 <ul><li>此时，<strong>消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息</strong></li></ul></li><li>如果消费者成功处理消息，消费者就可以使用XACK命令通知stream删除消息</li></ul><h4 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1" aria-hidden="true">#</a> 总结</h4><ul><li>消息保序：XADD/XREAD</li><li>阻塞读取：XREAD block</li><li>重复消息处理：Stream 在使用 XADD 命令，会自动生成全局唯一 ID；</li><li>消息可靠性：内部使用 PENDING List 自动保存消息，使用 XPENDING 命令查看消费组已经读取但是未被确认的消息，消费者使用 XACK 确认消息；</li><li>支持消费组形式消费数据</li></ul><h4 id="与专业消息队列的差距" tabindex="-1"><a class="header-anchor" href="#与专业消息队列的差距" aria-hidden="true">#</a> 与专业消息队列的差距</h4><p>一个专业的消息队列，必须要做到两大块：</p><ul><li>消息不丢</li><li>消息可堆积</li></ul><blockquote><p><strong>Redis Stream消息会丢失吗</strong></p></blockquote><p>使用一个消息队列，其实就分为三大块：<strong>生产者、队列中间件、消费者</strong>，所以要保证消息就是保证三个环节都不能丢失数据。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231129004917707.png" alt="image-20231129004917707" tabindex="0" loading="lazy"><figcaption>image-20231129004917707</figcaption></figure><ul><li>Redis 生产者会不会丢消息？ <ul><li>取决于生产者对于异常情况的处理是否合理。</li><li>从消息被生产出来，然后提交给 MQ 的过程中，只要能正常收到 （ MQ 中间件） 的 ack 确认响应，就表示发送成功</li><li><strong>所以只要处理好返回值和异常，如果返回异常则进行消息重发，那么这个阶段是不会出现消息丢失的。</strong></li></ul></li><li>Redis 消费者会不会丢消息？ <ul><li>因为 Stream会自动使用内部队列（也称为 <strong>PENDING List</strong>）留存消费组里每个消费者<u>已读取但未被确认的消息</u></li><li>消费者可以在重启后，用 XPENDING 命令查看<u>已读取但尚未确认处理完成的消息</u>。</li><li>等到<strong>消费者执行完业务逻辑后，再发送消费确认 XACK 命令，也能保证消息的不丢失</strong>。</li></ul></li><li>Redis 在以下 2 个场景下，都会导致数据丢失 ——&gt; (Redis本身数据丢失的场景) <ul><li><strong>AOF 持久化</strong>配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能</li><li><strong>主从复制</strong>也是异步的</li></ul></li></ul><p><u><strong>Redis 在队列中间件环节无法保证消息不丢</strong></u></p><p>像 RabbitMQ 或 Kafka 这类专业的队列中间件，在使用时是部署一个集群，生产者在发布消息时，队列中间件通常会写「多个节点」，也就是有多个副本，这样一来，即便其中一个节点挂了，也能保证集群的数据不丢失</p><blockquote><p><strong>Redis Stream 消息可堆积吗</strong></p></blockquote><p>Redis 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致 Redis 的内存持续增长，如果超过机器内存上限，就会面临被 OOM 的风险。</p><ul><li>Redis 的 Stream 提供了可以指定队列最大长度的功能，就是为了避免这种情况发生</li><li>当指定队列最大长度时，队列长度超过上限后，旧消息会被删除，只保留固定长度的新消息</li></ul><p>但 Kafka、RabbitMQ 专业的消息队列它们的数据都是存储在磁盘上，当消息积压时，无非就是多占用一些磁盘空间。</p><h4 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h4><ul><li>Redis 本身可能会丢数据；</li><li>面对消息挤压，内存资源会紧张；</li></ul><h4 id="是否选择stream" tabindex="-1"><a class="header-anchor" href="#是否选择stream" aria-hidden="true">#</a> 是否选择Stream</h4><ul><li>如果你的业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。</li><li>如果你的业务有海量消息，消息积压的概率比较大，并且不能接受数据丢失，那么还是用专业的消息队列中间件吧。</li></ul><h2 id="bitmap" tabindex="-1"><a class="header-anchor" href="#bitmap" aria-hidden="true">#</a> BitMap</h2><h3 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍" aria-hidden="true">#</a> 介绍</h3><p>位图，一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。</p><p>BitMap通过最小的单位bit来进行<code>0|1</code>的设置，表示某个元素的值或者状态，时间复杂度为O(1)。</p><p>由于 bit 是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用<strong>二值统计的场景</strong>。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/bitmap.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="内部实现-5" tabindex="-1"><a class="header-anchor" href="#内部实现-5" aria-hidden="true">#</a> 内部实现</h3><p>Bitmap 本身是<strong>用 String 类型作为底层数据结构</strong>实现的一种统计二值状态的数据类型。</p><p>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。</p><h4 id="怎么理解string-类型是会保存为二进制的字节数组" tabindex="-1"><a class="header-anchor" href="#怎么理解string-类型是会保存为二进制的字节数组" aria-hidden="true">#</a> 怎么理解String 类型是会保存为二进制的字节数组？</h4><ul><li>在Redis中，<strong>String</strong>类型数据实际上是以<strong>二进制的字节数组</strong>形式进行存储的。将一个字符串存储到Redis中时，Redis会将这个字符串转换为对应的二进制表示，并以字节数组的形式进行保存。</li><li>在Java等高级编程语言中，我们通常会将字符串表示为Unicode字符序列，每个字符占用一个或多个字节。（utf-8就是一个中文字符占3个字节，这样一个字符就占了24个比特位）</li><li>但在Redis中，为了更高效地存储和处理数据，它会将字符串转换为二进制形式。每个字符在内存中会被表示为相应的比特位（bit），而不是Unicode字符。这样可以节省存储空间并提高读写性能。</li><li>举个例子，假设你要在Redis中存储一个字符串&quot;Hello&quot;，它由5个字符组成，每个字符需要占用若干字节的存储空间。当这个字符串被存储为二进制字节数组时，每个字符会被转换为相应的比特位。 <ul><li>例如，字符&#39;H&#39;的ASCII码为72，转换为二进制形式为01001000，而字符&#39;e&#39;的ASCII码为101，则转换为01100101。这样，整个字符串&quot;Hello&quot;就被表示为如下的二进制字节数组： 01001000 01100101 01101100 01101100 01101111</li></ul></li></ul><h3 id="常用命令-4" tabindex="-1"><a class="header-anchor" href="#常用命令-4" aria-hidden="true">#</a> 常用命令</h3><h4 id="基本操作-1" tabindex="-1"><a class="header-anchor" href="#基本操作-1" aria-hidden="true">#</a> 基本操作</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>SETBIT key offset value <span class="token comment"># 设置值，offset表示该值在位图中的偏移量，value只能是0或1</span>
GETBIT key offset <span class="token comment"># 获取该键对应的位图中，偏移量为offset的值</span>
BITCOUNT key <span class="token punctuation">[</span>start end <span class="token punctuation">[</span>BYTE <span class="token operator">|</span> BIT<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token comment"># 获取指定范围内值为1的个数，start和end以字节为单位，可以改为以比特位为单位</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="运算操作-1" tabindex="-1"><a class="header-anchor" href="#运算操作-1" aria-hidden="true">#</a> 运算操作</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># BitMap间的运算</span>
<span class="token comment"># operations 位移操作符，枚举值</span>
  AND 与运算 <span class="token operator">&amp;</span>
  OR 或运算 <span class="token operator">|</span>
  XOR 异或 ^
  NOT 取反 ~
<span class="token comment"># result 计算的结果，会存储在该key中</span>
<span class="token comment"># key1 … keyn 参与运算的key，可以有多个，空格分割，not运算只能一个key</span>
<span class="token comment"># 当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0。返回值是保存到 destkey 的字符串的长度（以字节byte为单位），和输入 key 中最长的字符串长度相等。</span>
BITOP <span class="token punctuation">[</span>operations<span class="token punctuation">]</span> <span class="token punctuation">[</span>result<span class="token punctuation">]</span> <span class="token punctuation">[</span>key1<span class="token punctuation">]</span> <span class="token punctuation">[</span>keyn…<span class="token punctuation">]</span>

<span class="token comment"># 返回指定key中第一次出现指定value(0/1)的位置</span>
BITPOS <span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token punctuation">[</span>value<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="应用场景-6" tabindex="-1"><a class="header-anchor" href="#应用场景-6" aria-hidden="true">#</a> 应用场景</h3><h4 id="签到统计" tabindex="-1"><a class="header-anchor" href="#签到统计" aria-hidden="true">#</a> 签到统计</h4><p>签到打卡只需要记录签到（1）和未签到（0）</p><p>一个用户一天签到一个bit位，offset表示时间，例如一个月就31个bit位，一年就365个bit位</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>SETBIT uid:sign:100:202206 <span class="token number">2</span> <span class="token number">1</span> <span class="token comment"># ID为100的用户在2022年6月3日签到</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="判断用户登录状态" tabindex="-1"><a class="header-anchor" href="#判断用户登录状态" aria-hidden="true">#</a> 判断用户登录状态</h4><p>设置key为login_status</p><p>有几个用户就设置几个bit位，offset表示用户ID，但是offset必须从0开始</p><p>在线设置为1，下线设置为0，通过GETBIT判断用户是否在线</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>SETBIT login_status <span class="token number">10086</span> <span class="token number">1</span> <span class="token comment"># ID为10086的用户登录</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="连续签到用户" tabindex="-1"><a class="header-anchor" href="#连续签到用户" aria-hidden="true">#</a> 连续签到用户</h4><p>设置key为每天的日期，offset表示用户的Id，打卡则将offset位置的bit改为1</p><p>将连续的key拿出来，用其value里面的位图做与运算，可以得出这连续的日期key内哪个用户有持续不断的签到</p><p>结果保存在另一个bitmap中，便可得出哪个用户有连续签到，用BITCOUNT便可统计</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>BITOP operation destkey key <span class="token punctuation">[</span>key ···<span class="token punctuation">]</span>

BITOP AND destmap bitmap:01 bitmap:02 bitmap:03 <span class="token comment"># 对key为01，02，03的位图做与运算，统计结果存进destmap中</span>
BITCOUNT destmap <span class="token comment"># 查看连续签到的用户数量</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>operation</code>可以是<code>and</code>、<code>or</code>、<code>not</code>、<code>xor</code></li><li>当BITOP处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作<code>0</code>，空的key也被看作是包含<code>0</code>的字符串序列</li></ul><h4 id="_40亿qq号中查一个是否存在" tabindex="-1"><a class="header-anchor" href="#_40亿qq号中查一个是否存在" aria-hidden="true">#</a> 40亿QQ号中查一个是否存在</h4><p>问题转换：大批量无符号整数数据的处理</p><p>申请一个40亿的位图</p><p>qq号作为offset，是否存在作为value</p><p>遍历qq号码文件，按qq号存入位图中</p><div class="language-BASH line-numbers-mode" data-ext="BASH"><pre class="language-BASH"><code>SETBIT qq_status 1234567890 1
GETBIT qq_status 1234567890
-&gt; 1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="对象过期时间" tabindex="-1"><a class="header-anchor" href="#对象过期时间" aria-hidden="true">#</a> 对象过期时间</h2><h3 id="过期时间定义" tabindex="-1"><a class="header-anchor" href="#过期时间定义" aria-hidden="true">#</a> 过期时间定义</h3><p>Redis的过期时间是给一个key，指定一个时间点，等达到这个时间，数据就被认为是过期数据，可以由Redis进行回收</p><h3 id="过期时间作用" tabindex="-1"><a class="header-anchor" href="#过期时间作用" aria-hidden="true">#</a> 过期时间作用</h3><p>如果不是需要常驻的数据，设置过期时间们可以有效的节约内存</p><p>另外，有些特定场景功能也需要过期时间支持</p><ul><li>缓存：如果存在时间过久，就会导致数据源数据差距过大，设置过期时间可以方便的清除缓存以便后续再次加载进去 <ul><li>分布式锁：需要一定时间之后，数据自动消失，以实现最大占据时间的特性</li></ul></li></ul><h3 id="设置过期时间" tabindex="-1"><a class="header-anchor" href="#设置过期时间" aria-hidden="true">#</a> 设置过期时间</h3><p>以字符串为例</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>SET key value EX seconds		<span class="token comment"># 设置多少秒之后过期</span>
SET key value PX millisecond	<span class="token comment"># 设置多少毫秒后过期</span>
TTL key							<span class="token comment"># 查看还有多久国企</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通用的过期命令是<code>EXPIRE</code>，它可以为所有的数据对象设置过期时间</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>EXPIRE key seconds
EXPIRE key millisecond
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="判断是否过期" tabindex="-1"><a class="header-anchor" href="#判断是否过期" aria-hidden="true">#</a> 判断是否过期</h3><p>当我们<strong>查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中</strong>：</p><ul><li><p>如果不在，则正常读取键值；</p></li><li><p>如果存在，则会获取该 key 的过期时间</p><ul><li>然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。</li></ul></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231118125503624.png" alt="image-20231118125503624" tabindex="0" loading="lazy"><figcaption>image-20231118125503624</figcaption></figure><h3 id="键过期删除策略" tabindex="-1"><a class="header-anchor" href="#键过期删除策略" aria-hidden="true">#</a> 键过期删除策略</h3><p>过期的键实际上不是立刻删除的</p><p>一般过期键清除策略由3种，定时删除、定期删除、惰性删除</p><ul><li><strong>定时删除</strong>：在就设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间到来时，立即执行对键的删除操作。 <ul><li>定时删除对内存比较友好，但是对CPU不太友好，如果某个时间段比较多的key过期，可能会影响命令处理性能</li></ul></li></ul><blockquote><p>定时删除实现起来没有想象中的容易如果出现异常，如key遗漏；或者程序重启，原来的定时器就随着重启消失了，那就需要在启动的时候对过期键进行一些操作，可能是重建定时器，这些都是额外的工作，并且引入了多余的复杂度</p></blockquote><ul><li><p><strong>惰性删除</strong>：指使用的时候，发现key过期了，此时再进行删除。</p><ul><li>这个策略的思路是对应用而言，只要不访问，过期不过期业务都无所谓</li><li>但是这样的代价就是如果某些key一直不来访问，那本该过期的key就变成常驻的key了</li><li>这种策略对CPU最友好，但是对内存不太友好</li></ul></li><li><p><strong>定期删除</strong>：每隔一段时间程序就对数据库进行一次检查，每次删除一部分过期键</p><ul><li>这属于一种渐进式的兜底策略</li></ul></li></ul><p><strong>Redis过期键</strong>采用的是<strong>惰性删除+定期删除</strong>二者结合的方式来操作的</p><blockquote><p>就实际功能而言，其实并不需要那么实时，所以惰性删除是可以考虑的但是处于应删尽删的考虑，要保证没有漏网之鱼，那就需要加上定期删除作为兜底。</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231106223512351.png" alt="image-20231106223512351" tabindex="0" loading="lazy"><figcaption>image-20231106223512351</figcaption></figure><p>Redis每次访问key都会进行检查，若key过期就删除</p><p>定期删除需要关注两个问题</p><ol><li><p>定期删除的频率</p><ul><li>这个取决于Redis周期任务的执行频率，周期任务里面会做关闭过期客户端，删除过期key等一系列任务</li></ul></li><li><p>每次删除的数量</p><ul><li><p>每次检查的数量是写死在代码里的，每次20个，但是这里还是会检查过期key数量占比，大于25%，则再抽出20个来检查，重复流程，这里是个循环</p></li><li><p>Redis为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过25ms</p></li></ul></li></ol><h2 id="对象引用计数" tabindex="-1"><a class="header-anchor" href="#对象引用计数" aria-hidden="true">#</a> 对象引用计数</h2><h3 id="引用计数是什么" tabindex="-1"><a class="header-anchor" href="#引用计数是什么" aria-hidden="true">#</a> 引用计数是什么</h3><p>记录某个内存对象被引用了多少次，是计算机里的一种<strong>内存管理技术</strong></p><p><strong>引用计数大于0</strong>，就代表这个对象<strong>还在被引用</strong></p><p><strong>引用计数等于0</strong>，就说明这个对象已经没有被引用了，<strong>可以被释放了</strong></p><h3 id="redis对象的引用计数" tabindex="-1"><a class="header-anchor" href="#redis对象的引用计数" aria-hidden="true">#</a> Redis对象的引用计数</h3><p><code>redisObject</code>对象的<code>refcount</code>字段就是Redis的引用计数</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span>LRU BITS<span class="token punctuation">;</span> 
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>robj<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当<code>refcount</code>减少到0，就会触发对象的释放</p><p>Redis的引用计数，目前是为整数数据服务的</p><p>Redis会在初始化服务器的时候，创建10000个数值从0-9999的字符串对象。</p><p>当服务器新创建的键需要用到值为0-9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象</p><p><strong>为什么只做0-9999的字符串对象池呢</strong></p><blockquote><ol><li>0-9999的整数，被使用的几率是很大的，有<strong>很多复用场景</strong></li><li><strong>整数存储空比较小</strong>，而每个<code>redisObject</code>内部结构至少占16字节，这比整数本身占据的空间还要大，频繁分配整数是比较大的开销</li><li>要复用对象，就需要进行数值比较，而整数对象进行<strong>比较成本最低</strong>，如果是其他字符串，需要遍历字符串所有字符，而其他如List，ZSet的对比成本就更高了</li></ol><p>综合分析下来，其实计数保留一万个整数，投入产出比很合适的选择</p><p>0-9999共享对象的<code>refcount</code>值为int类型的最大值</p></blockquote><h2 id="连续内存结构和非连续内存结构的优劣" tabindex="-1"><a class="header-anchor" href="#连续内存结构和非连续内存结构的优劣" aria-hidden="true">#</a> 连续内存结构和非连续内存结构的优劣</h2><p><strong>连续内存结构(数组)：</strong></p><ol><li><strong>优点：</strong><ul><li><strong>快速随机访问：</strong> 数组中的元素在内存中是连续存储的，因此可以通过索引快速访问任何元素。 <ul><li>连续的内存结构使得数组的随机访问非常高效，因为可以通过简单的偏移计算来访问任何元素。</li></ul></li><li><strong>高性能：</strong> 由于连续内存结构，数组通常具有较低的内存访问时间，因此性能较好。 <ul><li>数组在内存中是一块连续的内存区域，元素紧密排列。</li><li>由于元素在内存中连续存储，缓存友好(局部性原理)，这意味着更多的数据可以被预加载到CPU缓存中，提高了访问速度</li></ul></li></ul></li><li><strong>局限性：</strong><ul><li><strong>固定大小：</strong> 数组的大小通常是固定的，一旦分配，很难动态调整大小。</li><li><strong>插入和删除操作较慢：</strong> 在数组中执行插入和删除操作时，需要移动元素，因此这些操作可能相对较慢。</li></ul></li></ol><p><strong>非连续内存结构(链表)：</strong></p><ol><li><strong>优点：</strong><ul><li><strong>动态大小：</strong> 链表可以在运行时动态添加或删除元素，因此它们更适合动态数据结构。</li><li><strong>插入和删除操作快速：</strong> 在链表中执行插入和删除操作通常很快，因为不需要移动整个元素。</li></ul></li><li><strong>局限性：</strong><ul><li><strong>慢速随机访问：</strong> 链表的元素不是在连续内存中存储的，因此随机访问通常较慢，需要遍历链表。 <ul><li>这种非连续内存结构导致链表的随机访问较为低效，因为需要跟随指针来访问特定元素，而且可能会导致缓存未命中。</li></ul></li><li><strong>额外的空间开销：</strong> 链表中每个元素通常需要存储指向下一个元素的指针，这会增加额外的内存开销。</li><li><strong>性能不如数组：</strong> 对于某些操作，如查找特定元素或排序，链表的性能通常不如数组。</li></ul></li></ol></div><!--[--><!----><!--]--><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/lgy8888/my_blog.git/edit/main/src/backEnd/Redis/Redis数据结构.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><nav class="vp-page-nav"><a aria-label="分布式系统理论" class="vp-link nav-link prev nav-link prev" href="/my_blog/backEnd/Redis/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA.html"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><span class="font-icon icon iconfont icon-write" style=""></span>分布式系统理论</div></a><a aria-label="Redis数据结构面试题汇总" class="vp-link nav-link next nav-link next" href="/my_blog/backEnd/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB.html"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">Redis数据结构面试题汇总<span class="font-icon icon iconfont icon-write" style=""></span></div></a></nav><div id="comment" class="giscus-wrapper input-top" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">林光远的个人笔记网站</div><div class="vp-copyright">Copyright © 2024 LGYNB</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/my_blog/assets/app-OTaO6_y0.js" defer></script>
  </body>
</html>
