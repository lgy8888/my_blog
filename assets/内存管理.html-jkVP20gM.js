import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as r,c as t,f as o}from"./app-OTaO6_y0.js";const g={},a=o('<h1 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理" aria-hidden="true">#</a> 内存管理</h1><h2 id="虚拟内存" tabindex="-1"><a class="header-anchor" href="#虚拟内存" aria-hidden="true">#</a> 虚拟内存</h2><p>由于用户不能直接操作物理内存，且直接引用真实物理地址会存在诸多问题</p><p>所以需要将进程所使用的地址分割开来——&gt;让操作系统为每个进程分配一套独立的<strong>虚拟地址</strong></p><ul><li>程序所使用的内存地址叫做<strong>虚拟内存地址</strong></li><li>实际存在硬件里面的空间地址叫做<strong>物理内存地址</strong></li></ul><p>进程所持有的虚拟地址会通过CPU芯片中的<strong>MMU</strong>(内存管理单元)来转变为物理地址，然后通过物理地址访问内存</p><p>内存的管理方式有两种：<strong>分段内存管理</strong>和<strong>分页内存管理</strong></p><h2 id="分段内存管理" tabindex="-1"><a class="header-anchor" href="#分段内存管理" aria-hidden="true">#</a> 分段内存管理</h2><h2 id="分页内存管理" tabindex="-1"><a class="header-anchor" href="#分页内存管理" aria-hidden="true">#</a> 分页内存管理</h2><p>分页是将虚拟内存和物理内存切分为一段一段的单元空间，这样连续并且尺寸固定的内存空间称为<strong>页</strong>，Linux中每页大小为<code>4kb</code></p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/bVcRr09.png" alt="image-20231104223521703" tabindex="0" loading="lazy"><figcaption>image-20231104223521703</figcaption></figure><p><strong>页表</strong>存储在内存中，<strong>MMU</strong>就负责将虚拟地址转换为物理地址</p><blockquote><p>有些资料将下图的虚拟地址称为逻辑地址，将交换分区(Swap)称为虚拟地址</p><p>标准叫法是虚拟地址和交换分区</p></blockquote><p><strong>虚拟地址</strong>指的是进程中特有的一套地址空间</p><p>**交换分区(Swap)**是在硬盘上划分出一块空间当内存用，是真实存在的文件</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/tcp_socket.png" alt="image-20231104223618401" tabindex="0" loading="lazy"><figcaption>image-20231104223618401</figcaption></figure><h3 id="解决分段内存管理的问题" tabindex="-1"><a class="header-anchor" href="#解决分段内存管理的问题" aria-hidden="true">#</a> 解决分段内存管理的问题</h3><p>分段内存管理存在<strong>外部内存碎片</strong>和<strong>内存交换效率低</strong>两个问题</p><ul><li><p>内存分页由于内存空间都是预先划分好的， 不会像内存分段在段与段之间产生间隙非常小的内存。页与页之间是紧密排列的，<strong>不会有外部碎片产生</strong>。但是，由于内存分页机制分配内存的最小单位是1页，即使程序不足一页大小，最少页只能分配1页，所以会造成页内内存浪费。内存分页机制会有<strong>内部内存碎片</strong>。</p></li><li><p>操作系统会把正在进行中的“最近没被使用”的内存页面换到磁盘中，称为<strong>换出</strong>(Swap Out)，需要的时候再加载进内存中，称为<strong>换入</strong>(Swap In)。一次性写入磁盘的只有少数几个页，不会花太多时间，<strong>提高了内存交换效率</strong></p></li></ul><p>分页管理的模式使得加载程序的时候<strong>不需要将一次性将整个程序加载到物理内存中</strong>，在完成虚拟内存和物理内存的页间映射后，不用真的将页加载到物理内存中，<strong>只有在需要的时候才将页换入</strong></p><h3 id="缺页异常" tabindex="-1"><a class="header-anchor" href="#缺页异常" aria-hidden="true">#</a> 缺页异常</h3><ul><li><p>当硬件在页表中查找时，发现页不在物理内存中，此时访问不在物理内存中的页，硬件会报一个<strong>缺页异常</strong>（pagefault)。</p></li><li><p>操作系统接收到页错误后，它会在PTE（PageTableEntry,页表项）中查找地址，并将请求发送给硬盘，<strong>将页读取到内存中</strong>。</p></li><li><p>硬盘IO完成后，操作系统会<strong>更新页表</strong>，将此页标记为存在，更新页表项中的字段记录新获取页的内存位置。</p></li></ul><h2 id="写时复制" tabindex="-1"><a class="header-anchor" href="#写时复制" aria-hidden="true">#</a> 写时复制</h2><p><strong>写时复制</strong>(Copy-on-write，COW)，是一种优化策略。</p><p>核心思想：如果有<strong>多个调用者同时请求相同资源（如内存或磁盘上的数据存储）</strong>，他们会<strong>共同获取相同的指针指向相同的资源</strong>，直到<strong>某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给该调用者</strong>，而<strong>其他调用者所见到的最初的资源仍然保持不变</strong>。这过程对其他的调用者都是透明的。</p><p>此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p><p>在 Linux 系统中，调用 <code>fork</code> 系统调用创建子进程时，并不会把父进程所有占用的内存页复制一份，而是与父进程共用相同的内存页，而当子进程或者父进程对内存页进行修改时才会进行复制</p><h3 id="虚拟内存和物理内存" tabindex="-1"><a class="header-anchor" href="#虚拟内存和物理内存" aria-hidden="true">#</a> 虚拟内存和物理内存</h3><p>应用程序使用的是 <strong>虚拟内存</strong>。而虚拟内存地址需要映射到物理内存地址才能使用，如果使用没有映射的<strong>虚拟内存地址</strong>，将会导致<strong>缺页异常</strong>。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231104223618401.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>进程A与进程B的相同 <strong>虚拟内存地址</strong> 映射到不同的 <strong>物理内存地址</strong>，这就是不同进程的相同虚拟内存地址互不影响的原因。</p><h3 id="共享内存" tabindex="-1"><a class="header-anchor" href="#共享内存" aria-hidden="true">#</a> 共享内存</h3><p><strong>虚拟内存</strong>需要与<strong>物理内存</strong> 进行映射才能使用，如果不同进程的虚拟内存地址映射到相同的 物理内存地址，那么就实现了共享内存的机制</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/view.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>由于进程A的 <strong>虚拟内存M</strong> 与进程B的 <strong>虚拟内存M&#39;</strong> 映射到相同的 <strong>物理内存G</strong>，所以当修改进程A <strong>虚拟内存M</strong> 的数据时，进程B <strong>虚拟内存M&#39;</strong> 的数据也会跟着改变。</p><h3 id="写时复制原理" tabindex="-1"><a class="header-anchor" href="#写时复制原理" aria-hidden="true">#</a> 写时复制原理</h3><p>Linux <strong>为了加速创建子进程过程与节省内存使用</strong>，实现了 <strong>写时复制</strong> 的机制。其原理大概如下：</p><ul><li>创建子进程时，将父进程的 <strong>虚拟内存</strong> 与 <strong>物理内存</strong> 映射关系复制到子进程中，并将<strong>内存设置为只读</strong>（设置为只读是为了当对内存进行写操作时触发 <strong>缺页异常</strong>）。</li><li>当子进程或者父进程对内存数据进行修改时，便会触发 <strong>写时复制</strong> 机制：将原来的内存页复制一份新的，并重新设置其内存映射关系，<strong>将父子进程的内存读写权限设置为可读写</strong>。</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231104223521703.png" alt="preview" tabindex="0" loading="lazy"><figcaption>preview</figcaption></figure><h3 id="写时复制的好处" tabindex="-1"><a class="header-anchor" href="#写时复制的好处" aria-hidden="true">#</a> 写时复制的好处</h3><p>当创建子进程时，父子进程指向相同的 <strong>物理内存</strong>，而不是将父进程所占用的 <strong>物理内存</strong> 复制一份</p><p>这样做的好处有两个：</p><ul><li><strong>加速创建子进程的速度。</strong></li><li><strong>减少进程对物理内存的使用。</strong></li></ul>',43),s=[a];function i(e,p){return r(),t("div",null,s)}const l=n(g,[["render",i],["__file","内存管理.html.vue"]]);export{l as default};
