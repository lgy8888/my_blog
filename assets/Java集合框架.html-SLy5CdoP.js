import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as n,c as s,f as e}from"./app-OTaO6_y0.js";const t={},o=e(`<h1 id="java集合框架" tabindex="-1"><a class="header-anchor" href="#java集合框架" aria-hidden="true">#</a> Java集合框架</h1><h2 id="容器java实现" tabindex="-1"><a class="header-anchor" href="#容器java实现" aria-hidden="true">#</a> 容器Java实现</h2><h3 id="接口" tabindex="-1"><a class="header-anchor" href="#接口" aria-hidden="true">#</a> 接口</h3><p>为了规范容器的行为，统一设计，JCF定义了15种容器接口</p><blockquote><p>JCF（Java Collections Framework，Java中运用最为广泛的Java集合类）</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240215140453108.png" alt="image-20240215140453108" tabindex="0" loading="lazy"><figcaption>image-20240215140453108</figcaption></figure><ul><li>容器主要包括Collection和Map两种，Collection存储着对象的集合，Map存储着键值对（两个对象）的映射表</li><li>Map接口没有继承自Collection接口，因为<code>Map</code>表示的是关联式容器而不是集合 <ul><li>Java提供了从Map转到Collection的方法，可以方便的将Map切换到集合视图</li></ul></li><li>Stack（栈）的功能已经被<code>JDK1.6</code>引入的Deque取代</li></ul><h3 id="实现" tabindex="-1"><a class="header-anchor" href="#实现" aria-hidden="true">#</a> 实现</h3><blockquote><p><code>java.util.*</code>中的接口的实现类如下</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240215141026319.png" alt="image-20240215141026319" tabindex="0" loading="lazy"><figcaption>image-20240215141026319</figcaption></figure><ul><li>虚线表示实现，实现表示继承</li><li>灰色的表示不推荐使用</li><li>List顺序存储，允许重复，set不允许重复</li><li>Queue和List的区别在于强调顺序，但并非按索引访问</li></ul><p>Java容器中只能放对象</p><p>对于基本类型（int，long，float，double等）需要将其包装成对象类型（Integer，Long，Float，Double等）才能放入容器内</p><h2 id="容器特性原理" tabindex="-1"><a class="header-anchor" href="#容器特性原理" aria-hidden="true">#</a> 容器特性原理</h2><h3 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> Map</h3><p>以键值对的形式存储和操作数据的容器类型</p><h4 id="treemap" tabindex="-1"><a class="header-anchor" href="#treemap" aria-hidden="true">#</a> TreeMap</h4><p>基于红黑树实现的一种提供顺序访问的Map</p><ul><li>实现SortedMap接口，能够把元素根据键Key排序。默认是升序列，使用Iterator遍历时回拿到一个升序的记录序列</li><li>因为需要排序，所以键Key需要定义比较大小的逻辑 <ul><li>具体顺序可以由 <u>实现Comparable接口</u> 或 <u>自定义Comparator</u> 来决定，或者根据键的自然顺序来判断</li></ul></li></ul><blockquote><p><strong>两种自定义比较规则的方法</strong></p></blockquote><ul><li><strong>实现 Comparable 接口</strong>： 如果键的类实现了 Comparable 接口，那么就可以在类中重写 <code>compareTo()</code> 方法，定义对象之间的自然排序规则。这样，TreeMap 在添加元素时就会依据对象的自然顺序来排序。</li><li><strong>自定义 Comparator</strong>： 如果无法或不想修改键的类，或者希望在不同的情况下使用不同的比较规则，可以创建一个实现 Comparator 接口的比较器类。Comparator 接口中有一个 <code>compare()</code> 方法，可以在其中定义自定义的比较逻辑。然后在创建 TreeMap 时，将该比较器传入，以指定按照这个比较器定义的规则来排序元素。</li></ul><blockquote><p><strong>Comparable 和 Comparator 的区别</strong></p></blockquote><ul><li>使用 Comparable 接口是直接在对象的类中定义了比较规则，而使用 Comparator 接口则是在单独的类中定义了比较规则，可以在不同的场景中重复使用。</li><li>如果一个类实现了 Comparable 接口，那么其对象之间的比较规则是固定的，无法在不同的场景中使用不同的比较规则；而使用 Comparator 则可以在需要时传入不同的比较器，实现灵活的比较规则切换。</li></ul><h4 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap" aria-hidden="true">#</a> HashMap</h4><h5 id="hashmap的特性" tabindex="-1"><a class="header-anchor" href="#hashmap的特性" aria-hidden="true">#</a> HashMap的特性</h5><ul><li>**访问速度快：**基于散列表，访问速度快——$O(1)$。进行put或者get操作可以达到常数时间的性能</li><li>**无序：**元素之间没有顺序</li><li>**键唯一，值不唯一：**HashMap最多只允许一条记录的键为null，但允许多条记录的值为null</li><li>**非线程安全：**需要保证线程安全推荐使用并发包中的ConcurrentHashMap <ul><li>HashMap没有做并发处理，多线程使用会出问题</li></ul></li></ul><h5 id="hashmap的实现" tabindex="-1"><a class="header-anchor" href="#hashmap的实现" aria-hidden="true">#</a> HashMap的实现</h5><ul><li>Java7中采用 <u>数组+链表</u> 实现；</li><li>Java8中使用 <u>数组+链表+红黑树</u> 实现</li></ul><blockquote><p><strong>Java7中HashMap实现分析</strong></p></blockquote><p>Java7中，实现HashMap是采用（数组+链表）的方式</p><p>即解决元素哈希冲突的方式是通过链表将元素串起来（拉链法）</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240215143108669.png" alt="image-20240215143108669" tabindex="0" loading="lazy"><figcaption>image-20240215143108669</figcaption></figure><blockquote><p><code>contructor</code></p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// aka 16</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	···
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>HashMap初始化的时候可以指定初始容量和负载因子，如果不指定会有默认值</li><li><code>initialCapacity</code>：初始容量，默认为16</li><li><code>loadFactor</code>：负载因子，默认为0.75。即元素个数达到总容量的75%时会触发扩容操作</li><li>初始容量指定了初始<code>table</code>的大小，负载因子用来指定自动扩容的临界值 <ul><li>当<code>entry</code>的个数超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希</li><li>对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数</li></ul></li></ul><p>扩容过程：</p><ol><li><strong>创建一个新的更大的数组</strong>，通常是<strong>当前容量的两倍</strong>。</li><li>将原数组中的所有元素<strong>重新计算hash值</strong>，并<strong>根据新的数组大小计算出新的index并重新分配到新的位置上</strong>。</li><li><strong>如果发生了哈希冲突</strong>，即多个元素计算得到的位置相同，<strong>用拉链法解决冲突</strong>。</li><li><strong>扩容完成后，新的数组会取代旧的数组成为HashMap的存储容器</strong>。</li></ol><blockquote><p><code>get()</code></p></blockquote><p><code>get(Object key)</code>方法根据指定的key值返回对应的value</p><p>该方法调用了<code>getEntry(Object key)</code>得到相应的entry，然后返回<code>entry.getValue()</code>，所以<code>getEntry()</code>是算法的核心</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240215152318921.png" alt="image-20240215152318921" tabindex="0" loading="lazy"><figcaption>image-20240215152318921</figcaption></figure><ol><li>首先是通过<code>hash()</code>函数得到对应bucket的下标 <ul><li>哈希桶下标计算公式（跟Redis的HashTable一样）：<code>index = hash &amp; (newCapacity - 1) </code></li></ul></li><li>然后依次遍历冲突链表，通过<code>key.equals(k)</code>的方法来判断是否是要找到那个key</li></ol><blockquote><p><code>put()</code></p></blockquote><p><code>put(K key, V value)</code>方法是将指定的键值对添加到map里面。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240215154754242.png" alt="image-20240215154754242" tabindex="0" loading="lazy"><figcaption>image-20240215154754242</figcaption></figure><ol><li>该方法首先会对map进行一次查找，看看是否包含此元组</li><li>如果已经包含则直接返回，查找过程类似<code>getEntry()</code>方法</li><li>如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的entry，插入方式为头插法</li></ol><blockquote><p><code>remove()</code></p></blockquote><p><code>remove(Object key)</code>的作用是删除key对应的entry，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>种实现的</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240215155020229.png" alt="image-20240215155020229" tabindex="0" loading="lazy"><figcaption>image-20240215155020229</figcaption></figure><ol><li><code>removeEntryForKey()</code>方法首先会找到key值对应的entry</li><li>然后删除该entry（修改链表相应的引用），查找过程跟<code>getEntry()</code>类似</li></ol><blockquote><p><strong>Java8中HashMap实现分析</strong></p></blockquote><p>Java8中对HashMap做了一些修改，引入了红黑树，采用（数组+链表+红黑树）的方式实现</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240215155154239.png" alt="image-20240215155154239" tabindex="0" loading="lazy"><figcaption>image-20240215155154239</figcaption></figure><ul><li>查找的时候，根据hash值可以快速定位到数组的具体下表，但是之后却得顺着链表一个个比较下去才能找到，时间复杂度取决于链表，为$O(n)$</li><li>为了降低这部分的开销，在Java8中，当容量（哈希桶的容量，bucket size）达到64个时，且链表中的元素达到8个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为$O(logN)$</li><li>Java7中使用Entry来代表每个HashMap中的数据节点，Java8中使用Node，基本没有区别，都是key，value，hash和next四个属性，但是Node只能表示链表的情况，红黑树需要用TreeNode <ul><li>链表转换为红黑树时所有的Node都会转换成TreeNode</li></ul></li></ul><h4 id="linkedhashmap" tabindex="-1"><a class="header-anchor" href="#linkedhashmap" aria-hidden="true">#</a> LinkedHashMap</h4><p>HashMap的子类，使用双向链表来维护元素的插入顺序，Iterator遍历时可以拿到这个顺序</p><p>顺序为插入顺序或者最近最少使用（LRU）顺序，可以在构造时用参数指定</p><ul><li>true表示访问顺序（LRU顺序），false表示插入顺序</li><li>put、get、compute都算作使用</li><li>这个LRU机制可以用于建设对象的缓存和淘汰机制，将最近很少使用的对象给释放掉</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * Constructs an empty <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token class-name">LinkedHashMap</span></span></span><span class="token punctuation">}</span> instance with the
 * specified initial capacity, load factor and ordering mode.
 *
 * <span class="token keyword">@param</span>  <span class="token parameter">initialCapacity</span> the initial capacity
 * <span class="token keyword">@param</span>  <span class="token parameter">loadFactor</span>      the load factor
 * <span class="token keyword">@param</span>  <span class="token parameter">accessOrder</span>     the ordering mode - <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token boolean">true</span></span></span><span class="token punctuation">}</span> for
 *         access-order, <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token boolean">false</span></span></span><span class="token punctuation">}</span> for insertion-order
 * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">IllegalArgumentException</span></span> if the initial capacity is negative
 *         or the load factor is nonpositive
 */</span>
<span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span>
                     <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span>
                     <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>accessOrder <span class="token operator">=</span> accessOrder<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="hashtable" tabindex="-1"><a class="header-anchor" href="#hashtable" aria-hidden="true">#</a> HashTable</h4><blockquote><p>不推荐使用</p></blockquote><p>功能跟HashMap类似，具有并发安全性，但是已经不推荐使用，因为并发效率低</p><p>不需要考虑并发的场景使用HashMap，需要考虑并发的场景使用ConcurrentHashMap</p><h3 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> List</h3><h4 id="arraylist" tabindex="-1"><a class="header-anchor" href="#arraylist" aria-hidden="true">#</a> ArrayList</h4><p>基于动态数组实现，特性基本与数组一致</p><blockquote><p>结构示意图</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240215193158767.png" alt="image-20240215193158767" tabindex="0" loading="lazy"><figcaption>image-20240215193158767</figcaption></figure><ul><li><code>size</code>：当前数组实际存储的元素个数</li><li><code>capacity</code>：容量，表示数组能够容纳的元素个数 <ul><li>new一个默认的ArrayList时，初始化的容量为0，只有当第一次插入元素之后，容量才会被初始化为<code>DEFAUT_CAPACITY = 10</code></li></ul></li></ul><h5 id="arraylist的特性" tabindex="-1"><a class="header-anchor" href="#arraylist的特性" aria-hidden="true">#</a> ArrayList的特性</h5><ul><li><p><strong>性能特性跟数组一样</strong></p><ul><li><p>查询效率高，支持快速随机访问</p></li><li><p>中间插入和删除数据的效率低，需要前后挪动数据</p></li></ul></li><li><p>底层采<strong>用Object[]数组存储数据</strong>，能容纳任何类型的对象</p></li><li><p><strong>线程不安全</strong></p></li></ul><h5 id="arraylist的扩容" tabindex="-1"><a class="header-anchor" href="#arraylist的扩容" aria-hidden="true">#</a> ArrayList的扩容</h5><blockquote><p><strong>存入的数据大于容量时怎么办？</strong></p></blockquote><p>当插入新元素时，会<strong>先校验数组大小是否能容纳所有元素</strong>，如果<strong>不满足就扩容</strong></p><p>扩容会<strong>先创建一个新的数组，然后将现有的数组数据拷贝给新的数组</strong></p><blockquote><p><strong>新的数组有多大？</strong></p></blockquote><p><strong>每次数组容量的增长大约是原容量的1.5倍</strong>，也就是扩大一半。</p><p>扩容操作的代价是很高的，实际使用的时候需要尽量避免数组容量扩张</p><blockquote><p><strong>如何避免数组容量扩张？</strong></p></blockquote><ul><li><strong>定制专属容器：<strong>当我们可预知要保存的元素多少时，要在</strong>构造ArrayList实例时指定其容量</strong>，以避免数组扩容的发生</li><li><strong>一次性扩容：<strong>根据实际插入情况，提前通过</strong>调用<code>ensureCapacity()</code>方法来手动增加ArrayList示例的容量</strong>，以减少递增式扩容发生 <ul><li>例如，已知后面会陆续插入100个数据，就可以提前调用<code>ensureCapacity()</code>确保数组可以再容纳100个，而不是等插入的时候去多次阶段的扩容</li></ul></li></ul><h4 id="linkedlist" tabindex="-1"><a class="header-anchor" href="#linkedlist" aria-hidden="true">#</a> LinkedList</h4><blockquote><p>结构示意图</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20240215203920741.png" alt="image-20240215203920741" tabindex="0" loading="lazy"><figcaption>image-20240215203920741</figcaption></figure><blockquote><p>源码</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">;</span>
<span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> last<span class="token punctuation">;</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token class-name">E</span> item<span class="token punctuation">;</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">;</span>

    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>头尾指针：链表维护了头尾两个指针</strong>，分别指向LinkedList的头和尾 <ul><li>当链表元素为0时，这两指针指向null</li><li>通过这两个指针可以快速找到头尾元素，因此LinkedList也可以用作栈，队列，双向队列</li></ul></li><li><strong>节点：<strong>列表中所有元素包装成Node节点存入，因为的双向链表，所以</strong>Node节点分别有一个向前和向后的指针</strong>， <ul><li><strong>头节点的向前指针和尾节点的向后指针都指向null</strong></li></ul></li><li><strong>性能：****下标相关的操作都是线性时间（$O(n)$，需要遍历整个链表去找）</strong>；而在<strong>首尾删除元素只需要常数时间（$O(1)$）</strong><ul><li>由于链表和数组的差异，<strong>插入和删除操作不会导致前后元素的挪动，只需要指针变化</strong></li></ul></li><li>**线程不安全：**如果需要多个线程并发访问，可以先采用<code>Collections.synchronizedList()</code>方法对其包装</li></ul><h4 id="vector" tabindex="-1"><a class="header-anchor" href="#vector" aria-hidden="true">#</a> Vector</h4><blockquote><p>不推荐使用</p></blockquote><p>基于数组实现，特性与ArrayList类似，不再推荐使用</p><ul><li>线程安全：使用线程同步能力，多线程互斥写入Vector</li></ul><h3 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> Set</h3><p>元素集合，元素独一无二，不能重复</p><h4 id="treeset" tabindex="-1"><a class="header-anchor" href="#treeset" aria-hidden="true">#</a> TreeSet</h4><blockquote><p><strong>基于红黑树实现</strong></p></blockquote><ul><li>使用二叉树原理，对元素进行排序。插入元素时需要调整树的结构，将元素放到指定的位置，支持自然顺序访问，但是添加、删除、包含等操作要相对抵消（$O(logN)$的时间）</li><li>因为需要排序，所以必须具备比较大小的能力。基础包装类Integer，String等可以默认支持排序。如果自定义类，则需要实现Comparable接口，定义自定义类的对象如何比较大小</li></ul><h4 id="hashset" tabindex="-1"><a class="header-anchor" href="#hashset" aria-hidden="true">#</a> HashSet</h4><blockquote><p>实现逻辑与HashMap几乎一致</p></blockquote><ul><li>底层使用HashMap存储数据，所有元素的value统一为PRESENT；只用HashMap的key作为Set的集合</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">;</span>

    <span class="token comment">// Dummy value to associate with an Object in the backing Map</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token constant">PRESENT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>HashSet的所有操作几乎都是直接调用HashMap的方法来实现的，所以非常简单</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token constant">PRESENT</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token operator">==</span><span class="token constant">PRESENT</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="linkedhashset" tabindex="-1"><a class="header-anchor" href="#linkedhashset" aria-hidden="true">#</a> LinkedHashSet</h4><ul><li>底层通过LinkedHashMap来保存所有元素</li><li>继承HashSet，操作上与父类相同，直接调用父类方法即可</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token class-name">LinkedHashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="queue" tabindex="-1"><a class="header-anchor" href="#queue" aria-hidden="true">#</a> Queue</h3><h4 id="priorityqueue" tabindex="-1"><a class="header-anchor" href="#priorityqueue" aria-hidden="true">#</a> PriorityQueue</h4><p>基于堆结构实现，可以用它来实现优先队列</p><p>特性与堆结构类似</p><hr>`,109),p=[o];function l(i,c){return n(),s("div",null,p)}const d=a(t,[["render",l],["__file","Java集合框架.html.vue"]]);export{d as default};
