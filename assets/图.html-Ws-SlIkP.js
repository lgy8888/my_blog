import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as l,f as e}from"./app-OTaO6_y0.js";const n={},g=e(`<h1 id="图" tabindex="-1"><a class="header-anchor" href="#图" aria-hidden="true">#</a> 图</h1><h2 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h2><ul><li>有向图</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230624134950343.png" alt="image-20230624134950343" tabindex="0" loading="lazy"><figcaption>image-20230624134950343</figcaption></figure><ul><li>无向图</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230626140809698.png" alt="image-20230624135014178" tabindex="0" loading="lazy"><figcaption>image-20230624135014178</figcaption></figure><ul><li><p>完全图</p><ul><li>在一个无向图中，若任意两个顶点之间都有一条直接边相邻接，则称该图为无向完全图</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230626140726852.png" alt="image-20230626140726852" tabindex="0" loading="lazy"><figcaption>image-20230626140726852</figcaption></figure><ul><li>在一个有向图中，若任意两个顶点之间都有方向相反的两条弧相邻接，则称该图为有向完全图</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230624135014178.png" alt="image-20230626140809698" tabindex="0" loading="lazy"><figcaption>image-20230626140809698</figcaption></figure></li><li><p>带权的图称为网络</p></li></ul><h2 id="度" tabindex="-1"><a class="header-anchor" href="#度" aria-hidden="true">#</a> 度</h2><ul><li><p>度是顶点的属性</p></li><li><p>度指的是该顶点相邻的边的数量</p></li><li><p>在有向图中，度分为入度和出度</p><ul><li>入度指箭头进来的数量</li><li>出度指箭头出去的数量</li></ul></li></ul><h2 id="路径" tabindex="-1"><a class="header-anchor" href="#路径" aria-hidden="true">#</a> 路径</h2><ul><li>路径被定义为从一个顶点到另一个顶点的一系列连续边</li><li>路径长度 <ul><li>不考虑权重，长度就是边的数量</li><li>考虑权重，长度就是权重累加</li></ul></li></ul><h2 id="环" tabindex="-1"><a class="header-anchor" href="#环" aria-hidden="true">#</a> 环</h2><ul><li>有向图中，从一个顶点开始，可以通过若干条有向边返回到该顶点，那么就形成一个环</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230624134907294.png" alt="image-20230624134907294" tabindex="0" loading="lazy"><figcaption>image-20230624134907294</figcaption></figure><h2 id="图的连通性" tabindex="-1"><a class="header-anchor" href="#图的连通性" aria-hidden="true">#</a> 图的连通性</h2><ul><li>如果两个顶点之间存在路径，则两个顶点是连通的</li><li>所有顶点都连通，则该图被称为连通图</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230624135132170.png" alt="image-20230624135132170" tabindex="0" loading="lazy"><figcaption>image-20230624135132170</figcaption></figure><ul><li>若子图连通，则称为连通分量，也称为极大连通子图</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230624135152667.png" alt="image-20230624135152667" tabindex="0" loading="lazy"><figcaption>image-20230624135152667</figcaption></figure><ul><li>在有向图中，若图中任意一对顶点vi, vj，从vi到vj有路径，反过来也有，则称该图为强连通图</li><li>有向图的极大强连通子图称为强连通分量</li></ul><h2 id="图的邻接表存储结构" tabindex="-1"><a class="header-anchor" href="#图的邻接表存储结构" aria-hidden="true">#</a> 图的邻接表存储结构</h2><ul><li><p>用一个顺序表存储顶点的集合</p></li><li><p>用邻接表存储图的边的集合</p><p>邻接表：采用单链表存储与一个顶点相关联的所有边</p></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230624135332688.png" alt="image-20230623220945015" tabindex="0" loading="lazy"><figcaption>image-20230623220945015</figcaption></figure><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230624135747380.png" alt="image-20230623221004520" tabindex="0" loading="lazy"><figcaption>image-20230623221004520</figcaption></figure><h2 id="邻接表存储结构的特点" tabindex="-1"><a class="header-anchor" href="#邻接表存储结构的特点" aria-hidden="true">#</a> 邻接表存储结构的特点</h2><ul><li>无向图中顶点vi的度位第i个单链表中的节点数</li><li>有向图邻接表中： <ul><li>顶点vi的出度为第i个单链表中的节点个数</li><li>顶点vi的入度为整个单链表中邻接点域值是i的节点个数</li></ul></li><li>有向图的逆邻接表：有向图中对每个结点建立以vi为头的弧的单链表（入边）</li><li>网络（带权图）：可在邻接表中的节点中定义表示该边权值的数据域</li></ul><h2 id="图的邻接矩阵存储结构" tabindex="-1"><a class="header-anchor" href="#图的邻接矩阵存储结构" aria-hidden="true">#</a> 图的邻接矩阵存储结构</h2><ul><li><p>用一个顺序表存储顶点的集合</p></li><li><p>用邻接矩阵存储图的边的集合</p><p>邻接矩阵：表示图中各顶点之间邻接关系的矩阵</p></li></ul><h2 id="图的表示" tabindex="-1"><a class="header-anchor" href="#图的表示" aria-hidden="true">#</a> 图的表示</h2><h3 id="无向图" tabindex="-1"><a class="header-anchor" href="#无向图" aria-hidden="true">#</a> 无向图</h3><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230623221933909.png" alt="image-20230624135332688" tabindex="0" loading="lazy"><figcaption>image-20230624135332688</figcaption></figure><ul><li>用<strong>邻接矩阵</strong>表示为：</li></ul><div class="language-邻接矩阵 line-numbers-mode" data-ext="邻接矩阵"><pre class="language-邻接矩阵"><code>  A B C D
A 0 1 1 0
B 1 0 0 1
C 1 0 0 1
D 0 1 1 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>用<strong>邻接表</strong>表示为：（better）</li></ul><div class="language-邻接表 line-numbers-mode" data-ext="邻接表"><pre class="language-邻接表"><code>A -&gt; B -&gt; C
B -&gt; A -&gt; D
C -&gt; A -&gt; D
D -&gt; B -&gt; C
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="有向图" tabindex="-1"><a class="header-anchor" href="#有向图" aria-hidden="true">#</a> 有向图</h3><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230623221719513.png" alt="image-20230624135747380" tabindex="0" loading="lazy"><figcaption>image-20230624135747380</figcaption></figure><ul><li>用<strong>邻接矩阵</strong>表示为：</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>  A B C D
A 0 1 1 0
B 0 0 0 1
C 0 0 0 1
D 0 0 0 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>用<strong>邻接表</strong>表示为：（better）</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>A -&gt; B -&gt; C
B -&gt; D
C -&gt; D
D -&gt; empty
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="不带权图" tabindex="-1"><a class="header-anchor" href="#不带权图" aria-hidden="true">#</a> 不带权图</h3><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230623221004520.png" alt="image-20230623221933909" tabindex="0" loading="lazy"><figcaption>image-20230623221933909</figcaption></figure><p><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230623221733893.png" alt="image-20230623221719513" loading="lazy"> <img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230623222111412.png" alt="image-20230623221733893" loading="lazy"></p><h3 id="带权图" tabindex="-1"><a class="header-anchor" href="#带权图" aria-hidden="true">#</a> 带权图</h3><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230623220945015.png" alt="image-20230623222151768" tabindex="0" loading="lazy"><figcaption>image-20230623222151768</figcaption></figure><p><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230623222151768.png" alt="image-20230623222111412" loading="lazy"><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230623222128239.png" alt="image-20230623222128239" loading="lazy"></p><h3 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h3><ul><li>无向图的邻接矩阵对称，可压缩存储；有n个顶点的无向图需要存储空间为$n(n+1)/2$</li><li>有向图邻接矩阵不一定对称；有n个顶点的有向图需要存储空间为$n^2$</li><li>无向图中顶点vi的度TD(vi)是邻接矩阵A中第i行元素之和</li><li>有向图中 <ul><li>顶点vi的出度是A中第i行元素之和</li><li>顶点vi的入读是A中第i列元素之和</li></ul></li></ul><h2 id="图的遍历" tabindex="-1"><a class="header-anchor" href="#图的遍历" aria-hidden="true">#</a> 图的遍历</h2><h3 id="深度优先搜索遍历" tabindex="-1"><a class="header-anchor" href="#深度优先搜索遍历" aria-hidden="true">#</a> 深度优先搜索遍历</h3><ul><li>DFS（Depth First Search）</li><li>从图的某一顶点Vi出发，访问此顶点</li><li>然后依次从V0的未被访问的邻接点出发，深度优先遍历图，直至图中所有和V0相通的顶点都被访问到</li><li>若此时图中尚有顶点未被访问，则另选图中一个未被访问的顶点作起点，重复上述过程，直至图中所有顶点都被访问为止</li></ul><h3 id="广度优先搜索遍历" tabindex="-1"><a class="header-anchor" href="#广度优先搜索遍历" aria-hidden="true">#</a> 广度优先搜索遍历</h3><ul><li>BFS（Breadth First Search）</li><li>从图的某一顶点V出发，访问此顶点后，依次访问V的各个未曾访问过的邻接点</li><li>然后分别从这些邻接点出发，广度优先遍历图，直至图中所有已被访问的顶点的邻接点都被访问到</li><li>若此时图中尚有顶点未被访问，则另选图中一个未被访问的顶点作起点，重复上述过程，直至图中所有顶点都被访问为止</li></ul><h2 id="最小生成树" tabindex="-1"><a class="header-anchor" href="#最小生成树" aria-hidden="true">#</a> 最小生成树</h2><h3 id="mst性质" tabindex="-1"><a class="header-anchor" href="#mst性质" aria-hidden="true">#</a> MST性质</h3><ul><li><strong>最小生成树性质</strong>（Minimum Spanning Tree)：设G=(V，E)是一个连通网，U是顶点集V的一个真子集。若（u，v）是一条具有最小权值（代价）的边，其中u∈U，v∈V-U，则必存在一棵包含边（u，v）的最小生成树。</li></ul><h3 id="prim算法" tabindex="-1"><a class="header-anchor" href="#prim算法" aria-hidden="true">#</a> prim算法</h3><ul><li>从任意一结点开始，将该结点与其余结点看成两个整体</li><li>在这两个整体之间连接的边中选取权值最小的边纳入到初始结点所在整体中</li><li>将初始结点和纳入结点看成整体，将其余结点看成另一个整体</li><li>重复第二步</li><li>直到所有的结点都被纳入到初始结点所在整体中</li><li>逐步纳入点形成生成树，称为“加点法”</li></ul><h3 id="kruskal算法" tabindex="-1"><a class="header-anchor" href="#kruskal算法" aria-hidden="true">#</a> Kruskal算法</h3><ul><li>将所有边和权值组成一个集合，按权值从小到大排序</li><li>复原边集合中各条边到原图中 <ul><li>若复原之后未形成环，则继续复原</li><li>若形成环，则丢弃该边，继续复原下一条边</li></ul></li><li>复原到最后形成的就是最小生成树</li><li>逐步增加生成树的边，称为“加边法”</li></ul><h2 id="最短路径" tabindex="-1"><a class="header-anchor" href="#最短路径" aria-hidden="true">#</a> 最短路径</h2><ul><li>求某一源点到其余各顶点的最短路径</li><li>求任意两顶点之间的最短路径</li></ul><h3 id="dijkstra算法" tabindex="-1"><a class="header-anchor" href="#dijkstra算法" aria-hidden="true">#</a> Dijkstra算法</h3><ul><li>以一个点为起始点</li><li>找该点能够到达的点，记录其从起点到该点的最短路径长度和该点的前驱结点</li><li>选取这些路径长度中最短的路径，标记该点</li><li>以该标记点为起点，继续找该点能够达到的点</li><li>每次从未标记的节点中选择距离起点最近的结点标记</li><li>计算标记点能够达到的点，记录其从起点到该点的最短路径长度和前驱结点</li><li>直到所有节点都标记</li></ul>`,65),r=[g];function d(t,s){return a(),l("div",null,r)}const h=i(n,[["render",d],["__file","图.html.vue"]]);export{h as default};
