import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as i,c as a,f as l}from"./app-OTaO6_y0.js";const r={},o=l('<h1 id="redis设计" tabindex="-1"><a class="header-anchor" href="#redis设计" aria-hidden="true">#</a> Redis设计</h1><h2 id="过期时间" tabindex="-1"><a class="header-anchor" href="#过期时间" aria-hidden="true">#</a> 过期时间</h2><h3 id="前置知识" tabindex="-1"><a class="header-anchor" href="#前置知识" aria-hidden="true">#</a> 前置知识</h3><h4 id="缓存命中率" tabindex="-1"><a class="header-anchor" href="#缓存命中率" aria-hidden="true">#</a> 缓存命中率</h4><p>缓存命中率是用来衡量缓存效果的关键指标，计算方式是缓存命中次数除以查询总次数</p><p>在实践中，应该把缓存命中率提高到90%以上</p><blockquote><p>缓存命中率受到业务影响，有些业务是无法做到90%以上的</p></blockquote><h4 id="实现过期机制" tabindex="-1"><a class="header-anchor" href="#实现过期机制" aria-hidden="true">#</a> 实现过期机制</h4><blockquote><p>四种思路</p></blockquote><ul><li>定时删除：是指针对每一个需要被删除的对象启动一个计时器，到期之后直接删除</li><li>延时队列：把对象放到一个延迟队列里面。当从队列里取出这个对象的时候，就说明它已经过期了，这时候就可以删除</li><li>惰性删除：指每次要使用对象的时候，检查一下这个对象是不是已经过期了。如果已经过期了，那么直接删除</li><li>定期删除：指每隔一段时间就遍历对象，找到已经过期的对象删除掉</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231212201937906.png" alt="image-20231212201937906" tabindex="0" loading="lazy"><figcaption>image-20231212201937906</figcaption></figure><blockquote><p>大部分的缓存框架，如Redis，都使用了惰性删除+定期删除结合的策略，定时删除和延时队列对于缓存场景来说，性能太差</p></blockquote><h3 id="基本思路" tabindex="-1"><a class="header-anchor" href="#基本思路" aria-hidden="true">#</a> 基本思路</h3><h4 id="优化过期时间" tabindex="-1"><a class="header-anchor" href="#优化过期时间" aria-hidden="true">#</a> 优化过期时间</h4><ul><li>调大过期时间，提高缓存命中率，提高性能 <ul><li>Redis中缓存了更多的key，占用了更多内存</li></ul></li><li>减少过期时间，减少Redis消耗</li></ul><h4 id="选惰性-定期的原因" tabindex="-1"><a class="header-anchor" href="#选惰性-定期的原因" aria-hidden="true">#</a> 选惰性+定期的原因</h4><blockquote><p>为什么不能立刻删除？</p></blockquote><p><strong>定时删除缺点</strong></p><p>在数据量大的情况下，key 太多了，一个 key 一个计时器，Redis 承受不住那么大的计时器开销。</p><p>修改过期时间的时候，要重置计时器的时间，这会进一步带来额外的开销。</p><p><strong>延时队列缺点</strong></p><p>延迟队列的本身开销很大，尤其是在 key 很多的情况下。</p><p>修改过期时间需要调整延迟队列中各个 key 的顺序。</p><p>延迟队列一般需要一个线程配合使用，如果引入这个线程，那么 Redis 就需要做更多并发控制，性能会下降。</p><h4 id="redis定期删除流程" tabindex="-1"><a class="header-anchor" href="#redis定期删除流程" aria-hidden="true">#</a> Redis定期删除流程</h4><blockquote><p>如何控制定期删除开销</p></blockquote><p>Redis会在每一次循环中遍历DB</p><p><strong>针对每一个DB</strong></p><ul><li>如果DB里面存放的key都没有设置过期时间，那么遍历下一个DB</li><li>从设置了过期字典的Key中抽一批，默认一批是25个</li><li>逐个检查这些key，如果这个key已经过期，就执行删除</li><li>每遍历16个key，就检测执行时间 <ul><li>如果执行时间超过阈值，中断这一次定期删除</li><li>中断后下一次定期删除会从下一个DB开始</li></ul></li><li>Redis会设定一个过期Key的占比阈值（25%）</li><li>如果这批过期的key比例超过这个阈值，那么就从当前DB抽取下一批key来继续检查</li><li>如果这批过期的key比例少于这个阈值，那么就终止这次检查</li></ul><h4 id="持久化处理过期key" tabindex="-1"><a class="header-anchor" href="#持久化处理过期key" aria-hidden="true">#</a> 持久化处理过期key</h4><blockquote><p>Redis的持久化是怎么处理过期key的</p></blockquote><p>对于RDB来说，<strong>主库不读不写，从库原封不动</strong></p><ul><li>在主库加载 RDB 的时候，也会忽略 RDB 中已经过期的 key。</li><li>从库则是整个 RDB 都加载进来 <ul><li>因为从库在加载完 RDB 之后，很快就能从主库里面收到删除的指令，从而删除这个过期的 key。</li></ul></li></ul><p>对于AOF来说，不管 Redis 是定期删除，还是懒惰删除过期 key，<strong>Redis 都会记录一条 DEL 命令</strong>，AOF重写会忽略过期的key</p><h3 id="亮点方案" tabindex="-1"><a class="header-anchor" href="#亮点方案" aria-hidden="true">#</a> 亮点方案</h3><h4 id="确定过期时间" tabindex="-1"><a class="header-anchor" href="#确定过期时间" aria-hidden="true">#</a> 确定过期时间</h4><blockquote><p>如何设置一个合理的过期时间？</p></blockquote><p>一般是根据<strong>缓存容量</strong>和<strong>缓存命中率</strong>来确定过期时间的</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231212203916403.png" alt="image-20231212203916403" tabindex="0" loading="lazy"><figcaption>image-20231212203916403</figcaption></figure><ul><li>缓存命中率越高，需要的缓存容量越多</li></ul><p>最佳的做法还是通过模拟线上流量来做测试，<strong>不断延长过期时间，直到满足命中率的要求</strong>。</p><p>如果公司的缓存资源不足，就需要通过缩短过期时间来换取缓存容量，代价就是缓存命中率的降低</p><blockquote><p>如何确定缓存命中率的要求？</p></blockquote><p>根据用户体验来确定</p><ul><li>要求 90% 的用户都能直接命中缓存，以保证响应时间在 100ms 以内，那么命中率就不能低于 90%。</li></ul><p>根据公司规定的平均响应时间来确定</p><p>公司规定了平均响应时间，根据自己接口命中缓存和不命中缓存的响应时间，就可以推断出来命中率应该多高</p><ul><li>如果公司要求<strong>平均响应时间</strong>是 300ms，<strong>命中缓存响应时间</strong>是 100ms，<strong>没命中缓存的响应时间</strong>是 1000ms</li><li>假设命中率是 p，那么 p 要满足 $100 \\times p +1000 \\times (1-p) = 300$</li></ul>',48),t=[o];function s(d,n){return i(),a("div",null,t)}const c=e(r,[["render",s],["__file","Redis设计.html.vue"]]);export{c as default};
