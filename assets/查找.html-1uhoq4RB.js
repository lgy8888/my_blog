import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as l,c as a,f as e}from"./app-OTaO6_y0.js";const n={},r=e(`<h1 id="查找" tabindex="-1"><a class="header-anchor" href="#查找" aria-hidden="true">#</a> 查找</h1><h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h2><ul><li><p>查找——也叫检索，是根据给定的某个值，在表中确定一个关键字等于给定值的记录或数据元素</p></li><li><p>关键字——是数据元素中某个数据项的值，它可以标识一个数据元素</p></li><li><p>查找方法评价</p><ul><li><p>查找速度</p></li><li><p>占用存储空间多少</p></li><li><p>算法本身复杂程度</p></li><li><p><strong>平均查找长度ASL</strong>(Average Search Length)：为确定记录在表中的位置，需和给定值进行比较的关键字的个数的期望值叫查找算法的ASL</p></li><li><p>ASL：对含有n个记录的表，$ASL=∑_{i=1}^np_i c_i $</p></li><li><p>$p_i $为查找表中第i个元素的概率，$∑_{i=1}^np_i =1$ $c_i $为找到表中第i个元素所需比较次数</p></li></ul></li></ul><h2 id="顺序查找" tabindex="-1"><a class="header-anchor" href="#顺序查找" aria-hidden="true">#</a> 顺序查找</h2><ul><li><p>查找过程：从表的一端开始逐个进行记录的关键字和给定值的比较</p></li><li><p>比较次数：</p><p>查找第1个元素： 1</p><p>查找第2个元素：2</p><p>……….</p><p>查找第n个元素： n</p><p>查找第i个元素： n+1-i</p><p>查找失败： n+1</p></li><li><p>设表中每个元素查找概率相等：$p_i=1/n$</p><p>$ASL=∑_{i=1}^np_i c_i $</p><p>​ $=1/n ∑_{i=1}^ni$</p><pre><code>   $=1/n⋅(n(n+1))/2$

  $=(n+1)/2$
</code></pre></li></ul><h2 id="折半查找" tabindex="-1"><a class="header-anchor" href="#折半查找" aria-hidden="true">#</a> 折半查找</h2><ul><li><p>查找过程：每次将待查记录所在区间缩小一半</p></li><li><p>适用条件：采用顺序存储结构的有序表</p></li><li><p>算法评价</p><ul><li><strong>判定树</strong>：描述查找过程的二叉树叫判定树</li><li>有n个结点的判定树的深度为$floor(log_2n)+1$</li><li>折半查找法在查找过程中进行的比较次数最多不超过其判定树的深度</li></ul></li></ul><h3 id="构建判定树" tabindex="-1"><a class="header-anchor" href="#构建判定树" aria-hidden="true">#</a> 构建判定树</h3><ul><li>取表数据最小为low，最大为high，取中间位置数据为mid</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230627134235849.png" alt="image-20230626221358393" tabindex="0" loading="lazy"><figcaption>image-20230626221358393</figcaption></figure><ul><li>将mid挑出，作为判定树的根结点</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230626225215448.png" alt="image-20230626221423449" tabindex="0" loading="lazy"><figcaption>image-20230626221423449</figcaption></figure><ul><li>接下来分别操作mid左右两边的数据</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230627134305725.png" alt="image-20230626221457777" tabindex="0" loading="lazy"><figcaption>image-20230626221457777</figcaption></figure><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230627140628135.png" alt="image-20230626221536973" tabindex="0" loading="lazy"><figcaption>image-20230626221536973</figcaption></figure><ul><li>循环直至所以数据都在树上</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230627140441168.png" alt="image-20230626222427640" tabindex="0" loading="lazy"><figcaption>image-20230626222427640</figcaption></figure><h3 id="判定树的作用" tabindex="-1"><a class="header-anchor" href="#判定树的作用" aria-hidden="true">#</a> 判定树的作用：</h3><ul><li><p>红色结点为表中数据，从根结点到任一结点的结点个数（包含根结点）就是该节点通过二分查找的查找次数</p></li><li><p>蓝色结点表示查找失败，其到根结点的节点个数同样反映了查找失败对应的查找次数</p></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230627134251468.png" alt="image-20230626222901225" tabindex="0" loading="lazy"><figcaption>image-20230626222901225</figcaption></figure><ul><li>查找成功的$ASL_1 = (1+2+2+3+3+3) / 6$</li><li>查找成功的$ASL_2 = (3+4+4+4+4+4+4)/7$</li></ul><h3 id="折半查找的asl" tabindex="-1"><a class="header-anchor" href="#折半查找的asl" aria-hidden="true">#</a> 折半查找的ASL</h3><ul><li><p>设表长$n=2^h-1$,$h=log_2⁡( n+1)$,即判定树是深度为h的满二叉树</p></li><li><p>设表中每个记录的查找概率相等$p_i=1/n$</p></li><li><p>则：$ASL=∑_{i=1}^np_i c_i $</p><p>$=1/n ∑_{i=1}^nc_i $</p><p>$=1/n ∑_{j=1}<sup>hj⋅2</sup>(j-1) $</p><p>$=(n+1)/n log_2⁡( n+1)-1$</p><p>$≈log_2⁡( n+1)-1$s</p></li></ul><h2 id="索引分块查找" tabindex="-1"><a class="header-anchor" href="#索引分块查找" aria-hidden="true">#</a> 索引分块查找</h2><ul><li>查找过程：将表分成几块，块内无序，块间有序；先确定待查记录所在块，再在块内查找</li><li>适用条件：分块有序表</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230627140639711.png" alt="image-20230626223418244" tabindex="0" loading="lazy"><figcaption>image-20230626223418244</figcaption></figure><h3 id="步骤" tabindex="-1"><a class="header-anchor" href="#步骤" aria-hidden="true">#</a> 步骤</h3><ul><li>建立索引表，将各个分块中值最大的数据取出，作为索引表的最大关键字和上界，将最小的数据取出，作为索引表的下界</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230627134258181.png" alt="image-20230626225215448" tabindex="0" loading="lazy"><figcaption>image-20230626225215448</figcaption></figure><ul><li>此时索引表是有序的而索引表对应的各分块是无序的</li><li>使用索引表的最大关键字进行<strong>折半查找</strong>，锁定最后low所在的索引</li><li>进入该索引对应的分块中，使用<strong>顺序查找</strong>，找到所求的关键字</li></ul><h3 id="asl" tabindex="-1"><a class="header-anchor" href="#asl" aria-hidden="true">#</a> ASL</h3><ul><li>$ASL_{bs} = ASL_b + ASL_w$</li></ul><h2 id="比较" tabindex="-1"><a class="header-anchor" href="#比较" aria-hidden="true">#</a> 比较</h2><table><thead><tr><th></th><th>顺序查找</th><th>二分查找</th><th>分块查找</th></tr></thead><tbody><tr><td>ASL</td><td>最大</td><td>最小</td><td>二者之间</td></tr><tr><td>表结构</td><td>任意</td><td>有序表</td><td>分块有序表</td></tr><tr><td>存储结构</td><td>顺序存储结构线性链表</td><td>顺序存储结构</td><td>顺序存储结构线性链表</td></tr></tbody></table><h2 id="哈希查找" tabindex="-1"><a class="header-anchor" href="#哈希查找" aria-hidden="true">#</a> 哈希查找</h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3><ul><li><p>基本思想：在记录的存储地址和它的关键字之间建立一个确定的对应关系；这样，不经过比较，一次存取就能得到所查元素的查找方法</p></li><li><p>定义</p><ul><li>哈希函数——在记录的关键字与记录的存储地址之间建立的一种对应关系叫哈希函数</li><li>哈希函数是一种映象，是从关键字空间到存储地址空间的一种映象</li><li>哈希函数可写成：$addr(a_i)=H(k_i)$ <ul><li>$ai$是表中的一个元素</li><li>$addr(a_i)$是$a_i$的存储地址</li><li>$k_i$是$a_i$的关键字</li></ul></li></ul></li><li><p>哈希表：应用哈希函数，由记录的关键字确定记录在表中的地址，并将记录放入此地址，这样构成的表叫哈希表</p></li><li><p>哈希查找：又叫<strong>散列查找</strong>，利用哈希函数进行查找的过程叫哈希查找</p></li><li><p>特点</p><ul><li>哈希函数只是一种映象，所以哈希函数的设定很灵活，只要使任何关键字的哈希函数值都落在表长允许的范围之内即可</li><li>key1 != key2，但 H(key1)=H(key2) 的现象叫<strong>冲突</strong></li><li>具有相同函数值的两个关键字，叫该哈希函数的<strong>同义词</strong></li><li>哈希函数通常是一种压缩映象，所以冲突不可避免，只能尽量减少；同时，冲突发生后，应该有处理冲突的方法</li></ul></li></ul><h3 id="常见的哈希函数" tabindex="-1"><a class="header-anchor" href="#常见的哈希函数" aria-hidden="true">#</a> 常见的哈希函数</h3><h4 id="除余法-除留余数法" tabindex="-1"><a class="header-anchor" href="#除余法-除留余数法" aria-hidden="true">#</a> <strong>除余法/除留余数法</strong></h4><ul><li>构造：取关键字被某个不大于哈希表表长m的数p除后所得余数作哈希地址，即$H(key)=nkey MOD p$，$p &lt;= m$</li><li>n为关键字的系数，p为被取余数</li><li>特点 <ul><li>简单、常用，可与上述几种方法结合使用</li><li>P的选取很重要；p选的不好，容易产生同义词哈希函数的构造方法</li></ul></li></ul><h4 id="数字分析法" tabindex="-1"><a class="header-anchor" href="#数字分析法" aria-hidden="true">#</a> <strong>数字分析法</strong></h4><ul><li>构造：对关键字进行分析，<strong>取关键字的若干位或其组合</strong>作哈希地址</li><li>适于关键字位数比哈希地址位数大，且可能出现的关键字事先知道的情况</li></ul><h4 id="折叠法" tabindex="-1"><a class="header-anchor" href="#折叠法" aria-hidden="true">#</a> <strong>折叠法</strong></h4><ul><li>构造：将关键字<strong>分割成位数相同的几部分，然后取这几部分的叠加和</strong>（舍去进位）做哈希地址</li><li>种类 <ul><li>移位叠加：将分割后的几部分低位对齐相加</li><li>间界叠加：从一端沿分割界来回折送，然后对齐相加</li><li>适于关键字位数很多，且每一位上数字分布大致均匀情况</li></ul></li></ul><h4 id="直接定址法" tabindex="-1"><a class="header-anchor" href="#直接定址法" aria-hidden="true">#</a> <strong>直接定址法</strong></h4><ul><li>构造：取关键字或关键字的某个<strong>线性函数</strong>作哈希地址，即$H(key)=key$ 或 $H(key)=a·key+b$</li><li>特点 <ul><li>直接定址法所得地址集合与关键字集合大小相等，不会发生冲突</li><li>实际中能用这种哈希函数的情况很少</li></ul></li></ul><h4 id="随机数法" tabindex="-1"><a class="header-anchor" href="#随机数法" aria-hidden="true">#</a> <strong>随机数法</strong></h4><ul><li>构造：取关键字的<strong>随机函数值</strong>作哈希地址，即$H(key)=random(key)$</li><li>适于关键字长度不等的情况</li></ul><h4 id="选取哈希函数-考虑以下因素" tabindex="-1"><a class="header-anchor" href="#选取哈希函数-考虑以下因素" aria-hidden="true">#</a> <strong>选取哈希函数，考虑以下因素</strong></h4><ul><li><p>计算哈希函数所需时间</p></li><li><p>关键字长度</p></li><li><p>哈希表长度（哈希地址范围）</p></li><li><p>关键字分布情况</p></li><li><p>记录的查找频率</p></li></ul><h3 id="处理冲突的方法" tabindex="-1"><a class="header-anchor" href="#处理冲突的方法" aria-hidden="true">#</a> 处理冲突的方法</h3><h4 id="链地址法" tabindex="-1"><a class="header-anchor" href="#链地址法" aria-hidden="true">#</a> 链地址法</h4><ul><li><p>方法：将所有关键字为同义词的记录<strong>存储在一个单链表中</strong>，并用一维数组存放头指针</p></li><li><p>拉链法的优点</p><ul><li><p>比较好的解决冲突</p></li><li><p>实现插入和删除比较方便</p></li><li><p>查找速度快</p></li><li><p>当装填因子&lt;1时，浪费存储空间多</p></li></ul></li></ul><h4 id="开放定址法" tabindex="-1"><a class="header-anchor" href="#开放定址法" aria-hidden="true">#</a> 开放定址法</h4><ul><li><p>方法：当冲突发生时，形成一个探查序列；沿此序列逐个地址探查，直到找到一个空位置（开放的地址），将发生冲突的记录放到该地址中，即$H_i=(H(key)+d_i)MOD m，i=1,2,…k(k&lt;=m-1)$</p></li><li><p>即：若遇到冲突，则寻找下一个空位置进行存储</p></li><li><p>其中：H(key)——哈希函数</p><pre><code>  	m——哈希表表长
  
  								     di——增量序列
</code></pre></li><li><p>分类</p><ul><li>线性探测再散列：$d_i=1,2,3,……m-1$</li><li>二次探测再散列：$d_i=1²,-1²,2²,-2²,3²,……±k²(k&lt;=m/2)$</li><li>伪随机探测再散列：$d_i=伪随机数序列$</li></ul></li><li><p>ASL算法</p><ul><li>成功：将每个关键字通过哈希函数运算得出的原值代入散列表中，以此为起点开始顺序查找，所有关键字的查找次数累加再除以总关键字数得出$ASL_{succ}$</li><li>失败：从散列表的起始位置出发，遍历散列表的每一个格子，以遍历到的格子为起点，开始顺序查找，找到空格视为失败，遍历到结束后将所有格子的失败查找次数累加再除以总散列表格数得出$ASL_{unsucc}$</li></ul></li></ul>`,55),t=[r];function d(h,g){return l(),a("div",null,t)}const u=i(n,[["render",d],["__file","查找.html.vue"]]);export{u as default};
