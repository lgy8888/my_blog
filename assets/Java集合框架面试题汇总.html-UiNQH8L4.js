import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as l,c as e,f as i}from"./app-OTaO6_y0.js";const h={},p=i('<h1 id="java集合框架面试题汇总" tabindex="-1"><a class="header-anchor" href="#java集合框架面试题汇总" aria-hidden="true">#</a> Java集合框架面试题汇总</h1><h2 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> Map</h2><h3 id="讲一下hashmap的工作原理" tabindex="-1"><a class="header-anchor" href="#讲一下hashmap的工作原理" aria-hidden="true">#</a> 讲一下HashMap的工作原理</h3><blockquote><p>HashMap的底层实现</p></blockquote><p>HashMap底层是Hash数组和单向链表实现，数组中的每个元素都是链表</p><blockquote><p>HashMap的元素操作</p></blockquote><p>HashMap通过<code>put()</code>方法存储对象，通过<code>get()</code>方法获取对象</p><p>存储对象时，将要存储的键和值分别传给<code>put(K value, V value)</code>方法</p><ol><li>调用哈希函数<code>hash(K)</code>计算键key的哈希值，结合数组长度获得数组下表</li><li>判断是否需要扩容，要的话就先扩容 <ul><li>当容器中元素个数大于<code>capacity * loadfactor</code>时进行扩容</li><li>扩容分为四步 <ol><li>创建一个新的数组，新数组的大小是原数组的两倍</li><li>将原数组里面的元素键拿出来重新计算哈希值，然后结合新的数组长度计算出新的索引，插入新索引位置 <ul><li><code>index = hash &amp; (newCapacity - 1)</code></li></ul></li><li>如果遇到哈希冲突，用拉链法解决哈希冲突，Java7中用链表，Java8中用链表/红黑树</li><li>扩容结束后用新数组替换旧数组，作为HashMap存储容器</li></ol></li></ul></li><li>执行插入逻辑 <ul><li>如果key的哈希值在HashMap中不存在，则执行插入</li><li>如果key的哈希值在HashMap中存在，且二者相同（equals返回true），则更新键值对</li><li>如果key的哈希值在HashMap中存在，且二者不相同（equals返回false），说明发生哈希冲突了 <ul><li>Java7中插入链表的头部</li><li>Java8中插入链表的尾部，并且当链表中的元素达到8个时，会将链表转换为红黑树 <ul><li>此时桶的数量必须大于64，小于64的话只会扩容</li></ul></li></ul></li></ul></li></ol><p>获取对象时，将key传给<code>get(K key)</code>方法</p><ol><li>调用哈希函数<code>hash(K)</code>计算key的哈希值，结合哈希数组的容量计算出该key对应的索引</li><li>找到该key对应数组位置的链表，顺序遍历链表</li><li>用<code>equals()</code>方法查找key对应的value</li></ol><h3 id="hashmap的put-流程" tabindex="-1"><a class="header-anchor" href="#hashmap的put-流程" aria-hidden="true">#</a> HashMap的put()流程</h3><p>将要存储的键和值分别传给<code>put(K value, V value)</code>方法</p><ol><li>调用哈希函数<code>hash(K)</code>计算键key的哈希值，结合数组长度获得数组下表</li><li>判断是否需要扩容，要的话就先扩容 <ul><li>当容器中元素个数大于<code>capacity * loadfactor</code>时进行扩容</li><li>扩容分为四步 <ol><li>创建一个新的数组，新数组的大小是原数组的两倍</li><li>将原数组里面的元素键拿出来重新计算哈希值，然后结合新的数组长度计算出新的索引，插入新索引位置 <ul><li><code>index = hash &amp; (newCapacity - 1)</code></li></ul></li><li>如果遇到哈希冲突，用拉链法解决哈希冲突，Java7中用链表，Java8中用链表/红黑树</li><li>扩容结束后用新数组替换旧数组，作为HashMap存储容器</li></ol></li></ul></li><li>执行插入逻辑 <ul><li>如果key的哈希值在HashMap中不存在，则执行插入</li><li>如果key的哈希值在HashMap中存在，且二者相同（equals返回true），则更新键值对</li><li>如果key的哈希值在HashMap中存在，且二者不相同（equals返回false），说明发生哈希冲突了 <ul><li>Java7中插入链表的头部</li><li>Java8中插入链表的尾部，并且当链表中的元素达到8个时，会将链表转换为红黑树 <ul><li>此时桶的数量必须大于64，小于64的话只会扩容</li></ul></li></ul></li></ul></li></ol><h3 id="hashmap的长度为什么是2的幂次方" tabindex="-1"><a class="header-anchor" href="#hashmap的长度为什么是2的幂次方" aria-hidden="true">#</a> HashMap的长度为什么是2的幂次方</h3><p>为了能让HashMap存取高效，尽量减少碰撞，也就是要尽量把数据分配均匀</p><p>Hash值的范围前后加起来大概有40亿的映射空间，没办法直接拿来用，需要将其再次映射到一个定义的哈希数组内</p><p>用计算得到的哈希值跟数组的长度做模运算（$%$），得到的余数才是对应的数组下标</p><p>因为做与运算（$&amp;$）比作模运算快得多，而在n为2的幂次方时，可以用 $(n-1)&amp;hash$ 来代替 $n%hash$</p><p>所以HashMap的长度需要为2的幂次方</p><h3 id="hashmap多线程操作导致死循环问题" tabindex="-1"><a class="header-anchor" href="#hashmap多线程操作导致死循环问题" aria-hidden="true">#</a> HashMap多线程操作导致死循环问题</h3><p>JDK1.7及以前版本的HashMap在多线程环境下扩容时可能存在死循环问题</p>',22),o=[p];function s(c,d){return l(),e("div",null,o)}const r=a(h,[["render",s],["__file","Java集合框架面试题汇总.html.vue"]]);export{r as default};
