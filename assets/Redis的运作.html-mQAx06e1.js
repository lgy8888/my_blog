import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as i,f as s}from"./app-OTaO6_y0.js";const n={},o=s(`<h1 id="redis的运作" tabindex="-1"><a class="header-anchor" href="#redis的运作" aria-hidden="true">#</a> Redis的运作</h1><h2 id="redis在内存中的存储" tabindex="-1"><a class="header-anchor" href="#redis在内存中的存储" aria-hidden="true">#</a> Redis在内存中的存储</h2><h3 id="数据库结构" tabindex="-1"><a class="header-anchor" href="#数据库结构" aria-hidden="true">#</a> 数据库结构</h3><p>redisDb代表Redis数据库结构</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// from Redis 5.0.5</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">{</span>
    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>
    dict <span class="token operator">*</span>expires<span class="token punctuation">;</span>
    dict <span class="token operator">*</span>blocking_ keys<span class="token punctuation">;</span>
    dict <span class="token operator">*</span>ready_keys<span class="token punctuation">;</span>
    dict <span class="token operator">*</span>watched keys<span class="token punctuation">;</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> avg_ttl<span class="token punctuation">;</span>
    list <span class="token operator">*</span>defrag_later<span class="token punctuation">;</span>
<span class="token punctuation">}</span>redisDb<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="数据字典" tabindex="-1"><a class="header-anchor" href="#数据字典" aria-hidden="true">#</a> 数据字典</h4><p>平时添加数据就是往<code>dict</code>里面加</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dict</span> <span class="token punctuation">{</span>
    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span>
    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> rehashidx<span class="token punctuation">;</span>  
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> iterators<span class="token punctuation">;</span>
<span class="token punctuation">}</span>dict<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231107195236771.png" alt="image-20231107195236771" tabindex="0" loading="lazy"><figcaption>image-20231107195236771</figcaption></figure><ul><li><code>redisDb</code>即数据库对象，指向数据字典<code>dict</code></li><li><code>dict</code>数据字典中包含了我们平常存储的k-v数据，k为字符串对象，v支持任意Redis对象</li></ul><h5 id="添加数据" tabindex="-1"><a class="header-anchor" href="#添加数据" aria-hidden="true">#</a> 添加数据</h5><p>将键值对添加到<code>dict</code>字典中去，<code>key</code>必须为<code>String</code>对象，<code>value</code>可以是任意对象</p><h5 id="查询数据" tabindex="-1"><a class="header-anchor" href="#查询数据" aria-hidden="true">#</a> 查询数据</h5><p>在<code>dict</code>中找到对应的<code>key</code></p><h5 id="更新数据" tabindex="-1"><a class="header-anchor" href="#更新数据" aria-hidden="true">#</a> 更新数据</h5><p>对已经赋值的key对象的任何变更操作都是更新</p><h5 id="删除数据" tabindex="-1"><a class="header-anchor" href="#删除数据" aria-hidden="true">#</a> 删除数据</h5><p>把key和value都从dict结构中删除</p><h4 id="过期键" tabindex="-1"><a class="header-anchor" href="#过期键" aria-hidden="true">#</a> 过期键</h4><p>Redis数据都可以设置过期键，过期键存在<code>expires</code>字典上</p><p>给上面的key都设置过期时间</p><p>设置TTL之后，Redis会在expire中存对应key的<strong>过期时间戳</strong></p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231107200606367.png" alt="image-20231107200606367" tabindex="0" loading="lazy"><figcaption>image-20231107200606367</figcaption></figure><blockquote><p>注意：这里的<code>dict</code>和<code>expires</code>中的<code>key</code>对象其实存储的都是String对象指针，所以并不会重复占用内容</p></blockquote><h2 id="redis线程" tabindex="-1"><a class="header-anchor" href="#redis线程" aria-hidden="true">#</a> Redis线程</h2><p>Redis的<strong>核心处理逻辑</strong>是单线程的</p><blockquote><p><strong>核心处理逻辑</strong>：Redis在处理客户端请求时包括(Socket读)、解析、执行、内容返回(Socket写)等都由一个顺序串行的主线程处理</p></blockquote><p>其他辅助模块会有一些多线程、多进程的功能</p><ul><li>复制模块用的是多线程</li><li>某些异步模块从4.0开始用的是多线程，例如UNLINK、FLUSHALL ASYNC、FLUSHDB ASYNC等非阻塞的删除操作</li><li>网络I/O解包在6.0之后用的是多线程</li></ul><p>但是这种分支模块都只是辅助，最核心的还是处理架构，Redis这块一直都是单线程的</p><h3 id="redis为何选择单线程" tabindex="-1"><a class="header-anchor" href="#redis为何选择单线程" aria-hidden="true">#</a> Redis为何选择单线程</h3><p>Redis是<strong>内存k-v存储</strong>，是做<strong>短平快的热点数据处理</strong>，一般来说会执行的很快，执行本身不应该成为瓶颈</p><p><strong>瓶颈通常在网络I/0</strong>，所以<strong>处理逻辑多线程并不会有太多的收益</strong></p><p>同时，Redis本身秉持<strong>高效简介</strong>的理念，代码的简单性，可维护性是Redis一直以来的追求</p><p>引入<strong>多线程带来的复杂性</strong>远比想象的要大，而且<strong>多线程会引入额外成本</strong></p><h4 id="引入多线程的复杂性" tabindex="-1"><a class="header-anchor" href="#引入多线程的复杂性" aria-hidden="true">#</a> 引入多线程的复杂性</h4><ul><li><p>引入多线程后，<strong>Redis原先的顺序执行特性就不复存在</strong>，为了支持事务的原子性，隔离性，Redis就不得不引入一些很复杂的实现</p></li><li><p>Redis的数据结构可以说是极其高效，在单线程模式下做了很多特性的优化，如果引入多线程，那么<strong>所有的底层数据结构都要改为线程安全</strong>，这会是极其复杂的工作</p></li></ul><blockquote><p><strong>线程安全</strong>：可以反向理解为多个线程共享变量会出现的问题，为了线程安全(也就是让多个线程有秩序的访问共享数据)，一般可以用锁，甚至是一些愿意操作。单线程自己操作自己数据，不存在线程安全问题</p></blockquote><ul><li>多线程模式也是的程序调试更加复杂和麻烦，会带来<strong>额外的开发成本及运营成本</strong>，也更容易犯错</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231107202246925.png" alt="image-20231107202246925" tabindex="0" loading="lazy"><figcaption>image-20231107202246925</figcaption></figure><h4 id="多线程迎带来的额外成本" tabindex="-1"><a class="header-anchor" href="#多线程迎带来的额外成本" aria-hidden="true">#</a> 多线程迎带来的额外成本</h4><ul><li><strong>上下文切换成本</strong>：多线程调度需要切换线程上下文。这个操作先存储当前线程的本地数据、程序指针等，然后载入到另一个线程数据，这种内核操作成本不可忽略</li><li><strong>同步机制的开销</strong>：一些公共资源，单线程下直接访问就好了，多线程需要通过加锁等方式去进行同步，这也是不可忽视的CPU开销</li><li><strong>线程内存占用</strong>：对Redis这种内存数据库来说，内存非常珍贵，多线程本身带来的内存使用成本也需要谨慎决策</li></ul><h3 id="单线程为什么能这么快" tabindex="-1"><a class="header-anchor" href="#单线程为什么能这么快" aria-hidden="true">#</a> 单线程为什么能这么快</h3><ol><li>Redis的大部分操作都是在内存中完成，<strong>内存操作</strong>本来就很快</li><li>Redis追求极致，选择了很多<strong>高效的数据结构</strong>，并做了非常多的优化</li><li>Redis采用了<strong>I/O多路复用</strong>机制，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞吐量</li></ol><h4 id="i-o可能的潜在点" tabindex="-1"><a class="header-anchor" href="#i-o可能的潜在点" aria-hidden="true">#</a> I/O可能的潜在点</h4><p>Redis服务端在启动的时候就以及bind了端口，并用listen操作监听客户端请求，此时客户端就可以发起连接请求</p><p>此时客户端发起一次GET处理请求</p><ol><li>客户端请求到来的时候，使用accpet建立连接</li><li>调用recv从套接字中读取请求</li><li>解析客户端发送请求，拿到参数</li><li>处理请求，这里是GET，那么Redis就是通过key获取对应的数据</li><li>最后将数据通过send发送给客户端</li></ol><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231107204951784.png" alt="image-20231107204951784" tabindex="0" loading="lazy"><figcaption>image-20231107204951784</figcaption></figure><p>套接字<strong>默认阻塞模式</strong>的，这里阻塞可能会发送在两个地方</p><p>一个是<code>accept</code>，例如建立时间过长；另一个是<code>recv</code>，客户端一直没有发送数据，此时Redis的服务就会被阻塞在那里</p><blockquote><p>如果是默认模式，Redis监听到有给客户端有连接请求，但一直未能成果建立连接的话，就会在accpet()阻塞</p><p>Redis通过recv()从一个客户端读取数据时，如果数据一直没有到达，Redis也会在recv()阻塞</p></blockquote><p>Redis本身是单线程的，发生这种阻塞就会将整个服务器卡住，所以我们不能让这两个操作阻塞，这里Redis将套接字设置为非阻塞式的，这样<code>accept</code>和<code>recv</code>就可以非阻塞调用</p><p><strong>非阻塞调用下，如果没有数据，就不会被阻塞在那里，而是让你返回做其他事情，这样可以解决卡死的问题</strong></p><p>但也需要一种机制可以回头看看这些操作是否已经就绪</p><h4 id="i-o多路复用" tabindex="-1"><a class="header-anchor" href="#i-o多路复用" aria-hidden="true">#</a> I/O多路复用</h4><p>有I/O操作触发的时候，就会产生通知，收到通知再去处理通知对应的事件</p><p>针对I/O多路复用，Redis做了一层包装，叫做<code>Reactor</code>模型</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231107205906263.png" alt="image-20231107205906263" tabindex="0" loading="lazy"><figcaption>image-20231107205906263</figcaption></figure><p>本质上就是监听各种事件，当事件发生时，将事件分发给不同的处理器</p><p>这样就不会阻塞在某个操作上，充分发挥性能</p><p>I/O多路复用让Redis单线程也有了较大的并发度(非并行)，在这种模式下，Redis单核的性能可以说是被充分的利用了</p><p><strong>并发和并行的区别</strong></p><p>并行指同一时刻有多条指令在多个处理器上同时进行</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/51bf03e5773f4286abe9124dfa927243.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>并发指同一时刻只有一条指令执行，都是多个进程指令被快速的轮换执行，是的宏观上具有多个进程同时执行的效果</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/4d19b49309b44c0bb71127ff9b832035.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="redis多线程网络i-o模型" tabindex="-1"><a class="header-anchor" href="#redis多线程网络i-o模型" aria-hidden="true">#</a> Redis多线程网络I/O模型</h2><h3 id="为什么要使用多线程" tabindex="-1"><a class="header-anchor" href="#为什么要使用多线程" aria-hidden="true">#</a> 为什么要使用多线程</h3><ul><li>在 Redis 6.0 版本之后，也采用了<strong>多个 I/O 线程来处理网络请求，提高网络请求处理的并行度</strong><ul><li>这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上</li></ul></li><li><strong>单个线程处理网络读写的速度跟不上底层网络硬件的速度</strong>。可以理解为，硬件很厉害了，但是受限于单线程，没有发挥出高级硬件的优势(多核CPU)</li><li>但是对于命令执行，Redis 仍然使用单线程来处理</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/1694241650395-b96bfeb1-e308-4383-aec1-83990561240a.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231108195511801.png" alt="image-20231108195511801" tabindex="0" loading="lazy"><figcaption>image-20231108195511801</figcaption></figure><blockquote><p>全双工多路复用是一种通信技术</p><p>全双工通信允许数据在两个方向上同时传输，就像双向车道一样，允许数据同时在两个方向上流动。多路复用是一种技术，它将多个消息信号组合成一个复合信号，以便在一个公共信道上传输，同时确保这些信号在传输过程中保持分开。</p><p>在全双工多路复用中，多个通信信号可以同时在同一个通信信道上传输，而每个信号仍然可以在双向通信中独立传输数据。这提高了通信效率，允许多个通信流在同一信道上并行传输数据，而不会干扰彼此。</p></blockquote><p>在Redis6.0之前，Redis使用的是<strong>单Reactor单线程的Reactor模型</strong></p><ul><li>单线程的Reactor模型可以监听多个客户端，但是请求只能一个一个解析</li></ul><p>Redis6.0之后，Redis使用的是<strong>单Reactor多线程的Reactor模型</strong></p><ul><li>多线程的Reactor模型可以监听多个客户端，监听到的请求可以分发给子线程去解析，这样可以更好的利用CPU的多核</li><li>Redis中的多个IO子线程只是用来处理请求(解包回包)，处理完会存入一个队列中</li><li>Redis的主线程会遍历这个队列并执行所有的已解析命令，并将结果写入缓冲区(buf)</li></ul><blockquote><p>需要注意的是，除了各个IO线程们会监听客户端并解析请求之外，Redis主线程也会做这份工作</p></blockquote><h3 id="redis获取请求流程" tabindex="-1"><a class="header-anchor" href="#redis获取请求流程" aria-hidden="true">#</a> Redis获取请求流程</h3><p><strong>将主线程 IO 读写任务拆分出来给一组独立的线程处理，使得多个 socket 读写可以并行化，但是 Redis 命令还是主线程串行执行</strong></p><ol><li>主线程负责接收建立连接请求，获取 socket 放入全局等待读处理队列；</li><li>主线程通过轮询将可读 socket 分配给 IO 线程；</li><li>主线程阻塞等待 IO 线程读取 socket 完成；</li><li>主线程执行 IO 线程读取和解析出来的 Redis 请求命令；</li><li>主线程阻塞等待 IO 线程将指令执行结果回写回 socket完毕；</li><li>主线程清空全局队列，等待客户端后续的请求。</li></ol><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/1694241806405-e755841a-84c3-4338-b6aa-cb65ad7bc92f.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="redis开启多线程模式" tabindex="-1"><a class="header-anchor" href="#redis开启多线程模式" aria-hidden="true">#</a> Redis开启多线程模式</h3><p>Redis 6.0 版本支持的 I/O多线程特性，默认是 I/O 多线程只处理写操作（write client socket），并不会以多线程的方式处理读操作（read client socket）。</p><p>注意这里的默认是 I/O 多线程只处理写操作</p><ul><li>不是说默认情况下开启I/O多线程，然后这个多线程来处理写操作</li><li>而是默认情况下，IO多线程关闭，配置<code>io-threads N</code>，如果N = 1，就只有一个主线程，N&gt;1的时候，才会开启IO多线程，且这个多线程是只处理写操作的</li></ul><p>要想开启多线程处理客户端读请求，就需要把Redis.conf配置文件中的 io-threads-do-reads 配置项设为 yes。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//读请求也使用 io 多线程 io-threads-do-readsyes </span>
io<span class="token operator">-</span>threads<span class="token operator">-</span><span class="token keyword">do</span><span class="token operator">-</span>reads yes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>同时， Redis.conf配置文件中提供了IO 多线程个数的配置项。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//io-threadsN，表示启用N-1个I/O多线程（主线程也算一个I/O线程） io-threads 4 </span>
io<span class="token operator">-</span>threads <span class="token number">4</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>关于线程数的设置，官方的建议是如果为 4 核的 CPU，建议线程数设置为 2 或 3，如果为 8 核 CPU 建议线程数设置为 6，线程数一定要小于机器核数，线程数并不是越大越好。</p><h3 id="redis默认情况下有多少个线程" tabindex="-1"><a class="header-anchor" href="#redis默认情况下有多少个线程" aria-hidden="true">#</a> Redis默认情况下有多少个线程</h3><p><strong>Redis 6.0 版本之后</strong>，Redis 在启动的时候，默认情况下会有 7 个线程（有三个是没有启动的线程）：</p><ul><li>Redis-server ：Redis 的主线程，主要负责执行命令；</li><li>bio_close_file、bio_aof_fsync、bio_lazy_free：三个后台线程，分别异步处理关闭文件任务、AOF 刷盘任务、释放内存任务；</li><li>io_thd_1、io_thd_2、io_thd_3：三个 I/O 线程，io-threads 默认是 4 ，所以会启动 3（4-1）个 I/O 多线程，用来分担 Redis 网络 I/O 的压力。</li></ul><h2 id="redis内存淘汰" tabindex="-1"><a class="header-anchor" href="#redis内存淘汰" aria-hidden="true">#</a> Redis内存淘汰</h2><h3 id="redis最大存储" tabindex="-1"><a class="header-anchor" href="#redis最大存储" aria-hidden="true">#</a> Redis最大存储</h3><p>Redis使用maxmemory配置，默认是0</p><p>在32位操作系统中，maxmemory的默认值是3G</p><blockquote><p>32位的机器最多只支持4GB的内存，而系统本身也需要一定的内存只有支持运行</p></blockquote><p>在64位操作系统中，机器不会限制内存的使用</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">maxmemory</span> <span class="token expression"><span class="token operator">&lt;</span>bytes<span class="token operator">&gt;</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>maxmemory可以主动配置，支持各个单位(KB、MB、GB……)</p><ul><li>在 64 位操作系统中，maxmemory 的默认值是 0，表示没有内存大小限制，那么不管用户存放多少数据到 Redis 中，Redis 也不会对可用内存进行检查，直到 Redis 实例因内存不足而崩溃也无作为。</li><li>在 32 位操作系统中，maxmemory 的默认值是 3G，因为 32 位的机器最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 32 位操作系统限制最大 3 GB 的可用内存是非常合理的，这样可以避免因为内存不足而导致 Redis 实例崩溃。</li></ul><p><strong>当Redis存储超过这个配置值，就会触发Redis内存淘汰</strong></p><h3 id="内存淘汰策略" tabindex="-1"><a class="header-anchor" href="#内存淘汰策略" aria-hidden="true">#</a> 内存淘汰策略</h3><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231109135949095.png" alt="image-20231109135949095" tabindex="0" loading="lazy"><figcaption>image-20231109135949095</figcaption></figure><p>第一种是<strong>不开启数据淘汰</strong>，则内存到达maxmemory之后，写入操作会失败，但现有数据不会淘汰</p><p>第二种是<strong>多种淘汰策略</strong>，主要支持LRU，LFU，RANDOM，TTL这几种方式</p><ul><li>LRU：根据LRU (Least Recently Used) 回收<strong>最近最少使用的键</strong></li><li>LFU：根据LFU (Least Frequently Use) 回收<strong>最不常用的键</strong></li><li>RANDOM：回收随机的键是的新添加的键有地方放</li><li>TTL：回收在过期集合的键，优先回收存活时间(TTL)较短的键</li></ul><p>这四种策略又可以分别选择回收<code>volatile</code>(设置了过期时间的key)和<code>allkeys</code>(全部key)，所以一共有8种策略</p><p><strong>如何选择淘汰策略</strong></p><p>如果数据非常重要，不能丢失，那就选择不淘汰，这种情况会导致写入失败，但是也有一套完善的告警机制用以配合人工介入</p><p>如果是缓存场景，一般会采用LRU/LFU这种灵活的淘汰策略</p><p><strong>什么时候会进行内存淘汰</strong></p><p>Redis会先执行命令，如果该命令超出了maxmemory，那么会进行内存淘汰，淘汰到内存占用低于maxmemory为止</p><blockquote><p>读请求也会检查，Redis的内存使用情况是动态变化的，即使是读请求，在面临一些复制的查询操作的时候，也会占用一些内存</p></blockquote><h3 id="lru算法" tabindex="-1"><a class="header-anchor" href="#lru算法" aria-hidden="true">#</a> LRU算法</h3><p>(Least Recently Used) 最近最久未使用，用链表记录每个key的最近访问时间，维护一个访问时间的数据</p><h4 id="存在问题" tabindex="-1"><a class="header-anchor" href="#存在问题" aria-hidden="true">#</a> 存在问题</h4><p>如果为所有数据维护一个顺序链表，其实就是一个双向链表，但是如果Redis的数据稍微多点，这个链表就是巨大的成本，对于Redis而言，内存是最宝贵的，所以Redis选择了近似LRU算法</p><h4 id="redis近似lru算法" tabindex="-1"><a class="header-anchor" href="#redis近似lru算法" aria-hidden="true">#</a> Redis近似LRU算法</h4><p>在LRU模式中，redisObject对象中的lru字段存储的是Redis的时钟<code>server.lrulock</code>，当key被访问时，Redis会更新这个key的redisObject的lru字段</p><p>Redis为了保证核心单线程服务性能，缓存了 Unix操作系统时钟，默认100ms更新一次</p><p>近似LRU算法在现有的数据结构的基础上采用随机采样的方式i淘汰元素，当内存不足时，执行一次近似LRU算法</p><p>具体步骤是随机采样n个key，这个采样的默认个数是5，如何根据时间戳淘汰掉最久的那个key，如果淘汰后内存还是不足，就继续随机采样来淘汰</p><h4 id="采样范围" tabindex="-1"><a class="header-anchor" href="#采样范围" aria-hidden="true">#</a> 采样范围</h4><p><code>allkeys</code>：所有key中随机采样</p><p><code>volatile</code>：从有过期时间的key随机采样</p><p>分别对应<code>allkeys-lru</code>，<code>volatile-lru</code></p><h4 id="淘汰池优化" tabindex="-1"><a class="header-anchor" href="#淘汰池优化" aria-hidden="true">#</a> 淘汰池优化</h4><p>近似LRU，优点在于节约了内存</p><p>但是缺点在于它不是一个完整的LRU过程，随机采样得到的结果，并不是真正的最久未访问，尤其是数据量大的情况</p><p>Redis3.0对LRU进行了一次优化</p><p>Redis会<strong>维护一个大小为16的候选池，池中的数据根据访问时间进行排序</strong></p><h4 id="淘汰流程" tabindex="-1"><a class="header-anchor" href="#淘汰流程" aria-hidden="true">#</a> 淘汰流程</h4><ol><li>一个 while 循环，直到 <code>mem_freed &gt;= mem_tofree</code> 即内存占用要回到 <code>maxmemory</code> 之下。（while 循环会直到内存回到阈值下，在主线程中的处理，是个阻塞操作）</li><li>根据驱逐策略，选择采样字典，例如是键空间字典还是过期字典，从里面选择键进行驱逐池的填充，同时每个数据库都会参与填充 <ul><li>若池没满，则采样的key全加入</li><li>若池满，则将池中活性最大的(时间戳最大)的key与将要加入的key进行比较，活性小的留下</li></ul></li><li>本轮驱逐池填充完毕后，从有序的驱逐池里选择一个驱逐效果最好的键进行驱逐，即<code>bestkey</code></li><li>对 <code>bestkey</code> 进行删除，删除后计算和维护一些东西，然后进入下一个循环</li></ol><h3 id="lfu算法" tabindex="-1"><a class="header-anchor" href="#lfu算法" aria-hidden="true">#</a> LFU算法</h3><p>(Least Frequently Use) 最不频繁算法，淘汰活跃度低的，使用频率最低的</p><h4 id="为什么要引入lfu" tabindex="-1"><a class="header-anchor" href="#为什么要引入lfu" aria-hidden="true">#</a> 为什么要引入LFU</h4><p>LRU本身已经能解决很多问题，但是在一些特定的场景下，脱离频率只谈最近访问，得不到我们想要的结果</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231109214200706.png" alt="image-20231109214200706" tabindex="0" loading="lazy"><figcaption>image-20231109214200706</figcaption></figure><p>这种情况如果用LRU，被淘汰的是<code>niuniu</code>，如果用LFU被淘汰的就是<code>mart</code></p><h4 id="lfu字段" tabindex="-1"><a class="header-anchor" href="#lfu字段" aria-hidden="true">#</a> LFU字段</h4><p>LRU的时间戳存放在redisObject的lru字段中，这个字段的长度是LRU_BITS，这个值一致都是24位</p><p>LRU和LFU是互斥的，他们不会同时开启</p><p>所以，<strong>Redis复用了lru字段来表示LFU的信息</strong></p><p>它将24拆解为16和8，<strong>前16位存放</strong>ldt(Last Decrement Time)<strong>上一次访问时间戳</strong>，<strong>低8位存放</strong>logc(Logistic Counter)<strong>访问计数</strong></p><blockquote><p>LFU的时间精度是1分钟，由于少了8位，如果用$2^{16}$只能表示65536秒，不够用</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231109215928651.png" alt="image-20231109215928651" tabindex="0" loading="lazy"><figcaption>image-20231109215928651</figcaption></figure><ul><li><p>上一次访问时间戳是用来衰减访问计数的</p><ul><li>简单的增加访问计数的方法不完美，访问的热度是一直在变化的 <ul><li>夸张点说：一个Key一年前的访问计数是200，一年后不应该归零吗</li></ul></li></ul></li><li><p>最后起作用的只有访问计数</p></li><li><p>新数据被加入Redis的时候会初始化一个访问次数(默认为5)，防止新数据还没有累计次数就被淘汰了</p></li></ul><h4 id="lfu字段更新流程" tabindex="-1"><a class="header-anchor" href="#lfu字段更新流程" aria-hidden="true">#</a> LFU字段更新流程</h4><ol><li><strong>计数次数衰减</strong>：根据这次与上次访问的时间间隔来计算应该减少的次数</li><li><strong>一定概率增加访问计数</strong>：原来的次数越多，要增加越难 <ul><li>次数不足5次，一定会增加</li><li>大于5次小于255次，会一定概率+1</li></ul></li><li><strong>更新</strong>：当前时间更新到高16位，次数更新到低8位</li></ol><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231109235122145.png" alt="image-20231109235122145" tabindex="0" loading="lazy"><figcaption>image-20231109235122145</figcaption></figure><p>该图为测试数据，意思是lfu-log-factor参数配置多少，对应需要多少流量来使其达到最大值255</p><blockquote><p>除了原来的次数影响之外，还有一个lfu-log-factor 参数可以被设置的。</p><p>通过lfu-log-factor参数可以调节难度，这个越大，难度也越大</p><p>如果为0，那么每次必然+1，很快就能255，255[10] -&gt; 1111 1111[2]，255就是最大值</p><p>默认是10，需要1M流量才能达到最大值。</p></blockquote>`,155),d=[o];function r(t,l){return a(),i("div",null,d)}const g=e(n,[["render",r],["__file","Redis的运作.html.vue"]]);export{g as default};
