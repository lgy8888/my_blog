import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as s,c as n,f as e}from"./app-OTaO6_y0.js";const o={},p=e(`<h1 id="数据库设计" tabindex="-1"><a class="header-anchor" href="#数据库设计" aria-hidden="true">#</a> 数据库设计</h1><h2 id="规范化" tabindex="-1"><a class="header-anchor" href="#规范化" aria-hidden="true">#</a> 规范化</h2><h3 id="规范化定义" tabindex="-1"><a class="header-anchor" href="#规范化定义" aria-hidden="true">#</a> 规范化定义</h3><p>关系模式：一个表里面的所有列</p><p>数据依赖</p><ul><li>函数依赖</li><li>多值依赖</li></ul><blockquote><p>关系模式中如果出现数据依赖，会产生许多问题</p></blockquote><ul><li>数据冗余太大</li><li>更新异常</li><li>插入异常</li><li>删除异常</li></ul><p>通过分解关系模式可以消除不合适的数据依赖</p><p>三大范式就是 Mysql 数据库设计表结构所遵循的规范和指导方法</p><p>目的是为了减少冗余，建立结构合理的数据库，从而提高数据存储和使用的性能。</p><h3 id="函数依赖" tabindex="-1"><a class="header-anchor" href="#函数依赖" aria-hidden="true">#</a> 函数依赖</h3><p>函数依赖，顾名思义，存在函数关系的依赖，y = f(x)，可以理解为x决定了y，一般记为x → y</p><p>例如 stu_id → category_id，category_id → category_name，(major_id, adm_year) → humanities_stu_count</p><p>知道学号就可以查到大类ID，知道大类ID就可以查到大类名称，知道专业ID和招生年份才能知道当年该专业的录取情况（文科录取人数）</p><p>函数依赖的分类</p><ul><li>平凡 / 非平凡函数依赖</li><li>完全 / 部分函数依赖</li><li>传递函数依赖</li></ul><h4 id="平凡-非平凡函数依赖" tabindex="-1"><a class="header-anchor" href="#平凡-非平凡函数依赖" aria-hidden="true">#</a> 平凡 / 非平凡函数依赖</h4><p>如果X → Y，但是Y !→ X，那么X → Y就是<strong>非平凡</strong>的函数依赖</p><p>如果X → Y，Y → X，那么X → Y就是<strong>平凡的函数依赖</strong></p><blockquote><p>在关系 SC(Sno, Cno, Grade) 中</p><p>非平凡函数依赖：(Sno, Cno) → Grade</p><p>平凡函数依赖：(Sno，Cno) → Sno， (Sno， Cno) → Cno</p></blockquote><h4 id="完全-部分函数依赖" tabindex="-1"><a class="header-anchor" href="#完全-部分函数依赖" aria-hidden="true">#</a> 完全 / 部分函数依赖</h4><p>如果(X, Y) → Z，但是X → Z，这就是部分函数依赖，</p><p>如果(X, Y) → Z，并且X !→ Z，Y !→ Z，这就是完全函数依赖</p><blockquote><p>也就是说，小组成员必须集齐了才能找到要找的数据，这才是完全的，如果不用集齐就能找到了，那就是部分的</p></blockquote><h4 id="传递函数依赖" tabindex="-1"><a class="header-anchor" href="#传递函数依赖" aria-hidden="true">#</a> 传递函数依赖</h4><p>顾名思义，传递的函数依赖，X → Y，Y → Z，X可以找到Y，Y可以找到Z</p><h3 id="三大范式" tabindex="-1"><a class="header-anchor" href="#三大范式" aria-hidden="true">#</a> 三大范式</h3><ul><li><p>三大范式是 Mysql 数据库设计表结构所遵循的规范和指导方法</p><ul><li>目的是为了减少冗余，建立结构合理的数据库，从而提高数据存储和使用的性能。</li></ul></li><li><p>三大范式之间是具有依赖关系的，比如第二范式是在第一范式的基础上建设的、第三范式是在第二范式的基础上建设的。</p></li><li><p>虽然，遵循范式能使我们的数据库结构更合理，但是也不是一成不变的</p><ul><li>偶尔需要在范式的基础，根据实际应用场景，作出相应的变通。</li></ul></li></ul><h4 id="第一范式" tabindex="-1"><a class="header-anchor" href="#第一范式" aria-hidden="true">#</a> 第一范式</h4><p>如果一个关系模式的**<u>所有属性都是不可分的基本数据项</u>**，那么这个关系模式就属于1NF</p><p>最基础的范式，不加任何限制的数据库表都是第一范式</p><blockquote><p>能存入关系型数据库表的一定是结构化的数据，也就是不能出现合并列，只能是一列一种数据</p></blockquote><p>满足1NF的数据库表，当前只有1个表</p><blockquote><p>Sno 学号 Cno 课程号 Grade 成绩 Sedpt 系 Sloc 系主任</p></blockquote><p>(<strong>Sno</strong>, Sdept, Sloc, <strong>Cno</strong>, Grade)</p><p>(Sno, Cno) → Grade</p><p>(Sno, Cno) → Sdept</p><p>(Sno, Cno) → Sloc</p><p>1NF也是同时存在<strong>传递依赖</strong>和<strong>部份依赖</strong>的关系模式</p><h4 id="第二范式" tabindex="-1"><a class="header-anchor" href="#第二范式" aria-hidden="true">#</a> 第二范式</h4><p>第二范式就是消除了<strong>部份依赖</strong>的第一范式</p><p>满足第二范式的数据库表必须是：只有集齐主键们才能够定位一条数据</p><p>如果存在只需要一个主键就能定位到的数据，那这个数据连着主键是肯定可以再分出去的</p><p>例如：</p><blockquote><p>一个学生对应一个系和系主任，通过学号就能定位到系和系主任，不需要课程ID介入</p></blockquote><p>(<strong>Sno</strong>, Sdept, Sloc) ：Sno → Sdept，Sno → Sloc</p><p>(<strong>Sno</strong>, <strong>Cno</strong>, Grade)：(Sno, Cno) → Grade</p><p>2NF存在传递依赖</p><h4 id="第三范式" tabindex="-1"><a class="header-anchor" href="#第三范式" aria-hidden="true">#</a> 第三范式</h4><p>第三范式就是消除了<strong>传递依赖</strong>的第二范式</p><p>满足第三范式的数据库表必须是：不能存在表中的普通属性能够定位到另一个普通属性</p><p>如果可以的话，那这个可用于定位别的属性的普通属性一定可以分出去做个主键，不需要寄人篱下</p><p>例如：</p><blockquote><p>一个系对应一个系主任，系自己就能定位到系主任，它们应该独立于学号主键</p></blockquote><p>(<strong>Sno</strong>, Sdept) ：Sno → Sdept</p><p>(<strong>Sdept</strong>, Sloc)：Sdept → Sloc</p><p>(<strong>Sno</strong>, <strong>Cno</strong>, Grade)：(Sno, Cno) → Grade</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>经过三范式的洗礼，从一开始的一整个大表，逐步分解成三个符合3NF的小表，极大程度的降低了数据的冗余</p><h2 id="主键设计" tabindex="-1"><a class="header-anchor" href="#主键设计" aria-hidden="true">#</a> 主键设计</h2><p>真实的表结构设计要求</p><ul><li>每张表需要有一个主键</li><li>消除冗余数据存在的可能性</li></ul><h3 id="自增主键设计" tabindex="-1"><a class="header-anchor" href="#自增主键设计" aria-hidden="true">#</a> 自增主键设计</h3><p>使用自增的BIGINT来作为主键</p><p><strong>优点</strong></p><ul><li>数据库是顺序插入</li><li>性能较好</li></ul><p><strong>缺点</strong></p><ul><li><p>自增存在回溯问题</p><ul><li>主键删除后服务器重启，自增键的位置会回退</li><li>如果数据库主键想用自增，需要升级到8.0版本</li></ul></li><li><p>自增值在服务器端生成，存在并发性能问题</p><ul><li>自增值是在 MySQL 服务端产生的值，需要有一把自增的 AI 锁保护</li><li>若这时有大量的插入请求，就可能存在自增引起的性能瓶颈。</li></ul></li><li><p>自增值作为主键，只能保证当前实例中唯一，不能保证全局唯一</p></li><li><p>公开数据值容易引发安全问题</p><ul><li>通过url后面的参数，例如：<code>http://www.example.com/User/10/</code>，可以猜出后面还有11，12等，容易引发数巨泄露</li></ul></li><li><p>MGR（MySQL Group Replication）可能引起的性能问题</p></li><li><p>分布式架构设计问题</p></li></ul><blockquote><p>AI锁</p></blockquote><p>由于自增值是在MySQL服务端生成的值，需要一把自增的AI锁保护（Auto Increase）</p><p>在MySQL数据库中，参数innodb_autoinc_lock_mode 用于控制自增锁持有的时间。</p><p>假设有一 SQL 语句，同时插入 3 条带有自增值的记录，则参数 innodb_autoinc_lock_mode 的影响</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231210191148277.png" alt="image-20231210191148277" tabindex="0" loading="lazy"><figcaption>image-20231210191148277</figcaption></figure><h3 id="uuid主键设计" tabindex="-1"><a class="header-anchor" href="#uuid主键设计" aria-hidden="true">#</a> UUID主键设计</h3><p>UUID（Universally Unique Identifier）代表全局唯一标识 ID。显然，由于全局唯一性，你可以把它用来作为数据库的主键。</p><p>MySQL可以通过函数<code>UUID()</code>来自动生成36字节字符</p><p>MySQL中的 UUID 由以下几个部分组成：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>UUID <span class="token operator">=</span> 时间低（<span class="token number">4</span>字节）<span class="token operator">-</span> 时间中高<span class="token operator">+</span>版本（<span class="token number">4</span>字节）<span class="token operator">-</span> 时钟序列 <span class="token operator">-</span> MAC地址
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>前 8 个字节中，60 位用于存储时间，4 位用于 UUID 的版本号</p></li><li><p>其中时间是从 1582-10-15 00：00：00.00 到现在的<strong>100ns 的计数。</strong></p></li><li><p>60 位的时间存储中，其存储分为：</p><ul><li><p>时间低位（time-low），占用 12 位；</p></li><li><p>时间中位（time-mid），占用 2 字节，16 位；</p></li><li><p>时间高位（time-high），占用 4 字节，32 位；</p></li></ul></li></ul><p><strong>需要特别注意的是，在存储时间时，UUID 是根据时间位逆序存储，</strong> 也就是低时间低位存放在最前面，高时间位在最后</p><p>UUID 的前 4 个字节会随着时间的变化而不断“随机”变化，并非单调递增。而非随机值在插入时会产生**<u>离散 IO</u>**，从而产生性能瓶颈。这也是 UUID 对比自增值最大的弊端</p><blockquote><p><strong>离散IO</strong></p></blockquote><p>与顺序 IO相对，离散 IO指的是在数据存储中，数据的插入或写入不是按照连续的顺序进行的，而是分散在存储介质的不同位置。</p><p>离散 IO 可能会导致性能瓶颈，因为存储系统需要在不同的位置进行读写操作，而这些操作可能需要更多的时间和资源</p><p>在上下文中，当使用非随机值（比如自增的数字）作为数据库的主键时，数据的插入是按照递增的顺序进行的。由于自增值是连续的，<strong>写入时只需在存储介质的末尾添加新数据，因此这种情况下是连续 IO</strong>。</p><p>相比之下，使用 UUID 作为主键时，由于 UUID 的前4个字节随时间变化而&quot;随机&quot;变化，这会导致新的数据在存储介质中的位置可能与之前的数据相距较远。因此，写入新数据时需要在存储介质的不同位置进行操作，这就产生了离散 IO。离散 IO 可能会引起存储系统的寻址和读写开销，降低整体性能。</p><blockquote><p>如何解决UUID做主键导致离散IO的问题</p></blockquote><p>为了解决这个问题，MySQL 8.0 推出了函数 UUID_TO_BIN，它可以把 UUID 字符串：</p><ul><li>通过参数将时间高位放在最前，解决了 UUID 插入时乱序问题；</li><li>去掉了无用的字符串”-“，精简存储空间；</li><li>将字符串其转换为二进制值存储，空间最终从之前的 36 个字节缩短为了 16 字节。</li></ul><p>MySQL 8.0 也提供了函数 BIN_TO_UUID，支持将二进制值反转为 UUID 字符串</p><blockquote><p>解决了离散IO的问题，顺序UUID的性能甚至比自增还好</p></blockquote><h3 id="业务自定义生成主键" tabindex="-1"><a class="header-anchor" href="#业务自定义生成主键" aria-hidden="true">#</a> 业务自定义生成主键</h3><p>UUID虽好，但是分布式数据库场景下，主键还需要加入一些额外的信息，这样才能保证后续二级索引的查询效率</p><p><strong>需要牢记：分布式数据库架构，仅用 UUID 做主键依然是不够的</strong></p><p>分布式架构的核心业务表，I键的设计可以如下</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>PK <span class="token operator">=</span> 时间字段 <span class="token operator">+</span> 随机码（可选） <span class="token operator">+</span> 业务信息<span class="token number">1</span> <span class="token operator">+</span> 业务信息<span class="token number">2</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="表结构设计" tabindex="-1"><a class="header-anchor" href="#表结构设计" aria-hidden="true">#</a> 表结构设计</h2><h3 id="消除冗余" tabindex="-1"><a class="header-anchor" href="#消除冗余" aria-hidden="true">#</a> 消除冗余</h3><p>消除冗余也是范式的要求，解决部分依赖和传递依赖，本质就是尽可能减少冗余数据。</p><p>进行表结构设计时，数据只需存放在一个地方，其他表要使用，通过主键关联存储即可。</p><ul><li>比如订单表中需要存放订单对应的用户信息，则保存用户 ID 即可</li></ul><h3 id="反范式设计" tabindex="-1"><a class="header-anchor" href="#反范式设计" aria-hidden="true">#</a> 反范式设计</h3><p>通常我们会在 OLAP 数据分析场景中使用反范式设计，但随着 JSON 数据类型的普及，MySQL 在线业务也可以进行反范式的设计</p><blockquote><p>OLAP 是联机分析处理（Online Analytical Processing）的缩写。</p><p>它是一种用于处理和分析大量多维数据的计算机处理方法和工具。</p><p>OLAP 技术主要用于数据仓库和数据挖掘应用，旨在支持复杂的分析和决策支持</p></blockquote><p>使用JSON串来替代传统关系型数据库表的字段就是反范式</p><ul><li>用 JSON存储用户标签数据</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>+--------+---------------+
<span class="token operator">|</span> userId <span class="token operator">|</span> userTags      <span class="token operator">|</span>
+--------+---------------+
<span class="token operator">|</span>      <span class="token number">1</span> <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token number">2</span>, <span class="token number">6</span>, <span class="token number">8</span>, <span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">|</span>
<span class="token operator">|</span>      <span class="token number">2</span> <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token number">3</span>, <span class="token number">10</span>, <span class="token number">12</span><span class="token punctuation">]</span>   <span class="token operator">|</span>
+--------+---------------
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>用JSON串来替换user_login表里面用户的登录信息</li></ul><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
	<span class="token property">&quot;cellphone&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;18088888888&quot;</span><span class="token punctuation">,</span>
	<span class="token property">&quot;wxchat&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;LGY888888&quot;</span><span class="token punctuation">,</span>
	<span class="token property">&quot;QQ&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;3179999999&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="范式的优缺点" tabindex="-1"><a class="header-anchor" href="#范式的优缺点" aria-hidden="true">#</a> 范式的优缺点</h3><blockquote><p><strong>写密集</strong>的场景建议对数据库进行范式化设计</p></blockquote><h4 id="范式的优点" tabindex="-1"><a class="header-anchor" href="#范式的优点" aria-hidden="true">#</a> 范式的优点</h4><ul><li><p>范式化的更新操作通常比反范式化要快</p></li><li><p>当数据较好地范式化，旧很少有重复数据，所以只需要修改更少的数据</p></li><li><p>范式化的表通常更小，可以更好的放缓冲区里，所以执行操作会更快</p></li><li><p>较少的数据冗余意味着检索列表数据更少需要DISTINCT或GROUP BY子句</p><ul><li>比如把员工，部门，部门管理人记录在同一张表中，则必须要GROUP BY才可以获得所有的部门。</li><li>但如果将部门拆分为一张表，那么只需要简单查询这张表即可</li></ul></li></ul><h4 id="范式的缺点" tabindex="-1"><a class="header-anchor" href="#范式的缺点" aria-hidden="true">#</a> 范式的缺点</h4><ul><li>数据库中的表通常需要关联后才可以查到完整的数据</li><li>表关联代价昂贵，同时有可能导致一些索引策略无效 <ul><li>例如范式化可能将列存在不同的表，而这些列如果在同一个表中本就可以属于同一个索引</li></ul></li></ul><h3 id="反范式的优缺点" tabindex="-1"><a class="header-anchor" href="#反范式的优缺点" aria-hidden="true">#</a> 反范式的优缺点</h3><h4 id="反范式的优点" tabindex="-1"><a class="header-anchor" href="#反范式的优点" aria-hidden="true">#</a> 反范式的优点</h4><ul><li><p>因为所有数据都存在一张表中，可以避免关联</p></li><li><p>不需要关联表，则对大部分查询最差的情况，表没有使用索引，全表扫描。</p><ul><li>数据比内存大的时候，可能比关联要快的多，因为避免了随机I/O</li></ul></li><li><p>单独的表也能使用更有效的索引策略</p></li></ul><h4 id="单独的表有效索引举例" tabindex="-1"><a class="header-anchor" href="#单独的表有效索引举例" aria-hidden="true">#</a> 单独的表有效索引举例</h4><p><strong>使用范式化</strong></p><p>假设有一个网站，允许用户发送消息，并且一些用户是付费用户。</p><p>现在想查看付费用户最近的 10 条信息。如果是范式化的结构并且索引了发送日期字段 published，这个查询也许看起来像这样：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> messeage_text<span class="token punctuation">,</span> user_name
<span class="token keyword">FROM</span> message
	<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> <span class="token keyword">user</span> <span class="token keyword">ON</span> message<span class="token punctuation">.</span>user_id <span class="token operator">=</span> <span class="token keyword">user</span><span class="token punctuation">.</span>id
<span class="token keyword">WHERE</span> <span class="token keyword">user</span><span class="token punctuation">.</span>acount_type <span class="token operator">=</span> <span class="token string">&#39;premiumv&#39;</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> message<span class="token punctuation">.</span>published <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>MySQL可能会选择不同的执行计划：</p><p>执行计划一</p><ul><li>扫描message表的published字段的索引</li><li>对每一行找到的数据，都要到user表里检查这个用户是不是付费用户</li><li>如果只有一小部分用户是付费账户，那么这样效率是很低的</li></ul><p>执行计划二</p><ul><li>选择user表所有的付费用户</li><li>然后再排序</li><li>但这样效率也许会更低</li></ul><p>效率低的问题是关联，使得需要在一个索引中又排序又过滤</p><p><strong>使用反范式</strong></p><p>将两张表的字段合并一下，并且增加一个索引(account_type, published)，就可以不通过关联写出这个查询。</p><p>在实际生产中，也<strong>不必完全反范式化</strong>，完全反范式存在插入和删除问题</p><p>比如没有消息的时候会丢失用户的信息，可以在user和message表都存储account_type字段。这里是简单的将两张表完全合在一起了\`</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> message_text<span class="token punctuation">,</span> user_name
<span class="token keyword">FROM</span> user_messages
<span class="token keyword">WHERE</span> account_type <span class="token operator">=</span> <span class="token string">&#39;premium&#39;</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> published <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="混用范式化和反范式化" tabindex="-1"><a class="header-anchor" href="#混用范式化和反范式化" aria-hidden="true">#</a> 混用范式化和反范式化</h3><h4 id="混合使用" tabindex="-1"><a class="header-anchor" href="#混合使用" aria-hidden="true">#</a> 混合使用</h4><p>在生产场景中，很少会极端的进行完全范式化和完全反范式化</p><p>实际场景经常需要混用，可能使用部分范式化数据库、缓存表或者是其他技巧</p><h4 id="重复更新的问题" tabindex="-1"><a class="header-anchor" href="#重复更新的问题" aria-hidden="true">#</a> 重复更新的问题</h4><p>在上面反范式的优点例子中，在user表和message表中都添加了account_type字段，更新用户类型就需要更新两张表了，要考虑更新的频率以及更新的时长，并且和查询的效率进行比较</p><h4 id="缓存衍生值" tabindex="-1"><a class="header-anchor" href="#缓存衍生值" aria-hidden="true">#</a> 缓存衍生值</h4><p>缓存衍生值也是有用的，如果需要显示每个用户发了多少消息，可以每次执行一个昂贵的子查询来计算并显示它，也可以在user表中建一个num_message列，每当用户发新消息时更新这个值</p><h2 id="索引设计" tabindex="-1"><a class="header-anchor" href="#索引设计" aria-hidden="true">#</a> 索引设计</h2><h3 id="索引个数" tabindex="-1"><a class="header-anchor" href="#索引个数" aria-hidden="true">#</a> 索引个数</h3><blockquote><p>一张表的索引有没有限制？</p></blockquote><p>网上一些所谓的 MySQL“军规”中写道&quot;一张表的索引不能超过 5 个&quot;。<strong>根本没有这样的说法，完全是无稽之谈。</strong></p><p>如果业务的确需要很多不同维度进行查询，那么就该创建对应多索引</p><h4 id="实际问题" tabindex="-1"><a class="header-anchor" href="#实际问题" aria-hidden="true">#</a> 实际问题</h4><p>由于业务开发人员对数据库的不熟悉，创建 许多无用的索引索引，这些索引从创建之初到现在根本就没有使用过。</p><p>因为优化器并不会选择这些低效的索引，这些无效索引占用了空间，又影响了插入的性能。</p><h4 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h4><blockquote><p>如何知道哪些索引有没有被用过？</p></blockquote><p>在 MySQL 数据库中，可以通过查询表<code>sys.schema_unused_indexes</code>，查看有哪些索引一直未被使用过，可以被废弃</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> schema_unused_indexes
<span class="token keyword">WHERE</span> object_schema <span class="token operator">!=</span> <span class="token string">&#39;performance_schema&#39;</span><span class="token punctuation">;</span>

<span class="token operator">+</span><span class="token comment">---------------+-------------+--------------+</span>
<span class="token operator">|</span> object_schema <span class="token operator">|</span> object_name <span class="token operator">|</span> index_name   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------------+-------------+--------------+</span>
<span class="token operator">|</span> sbtest        <span class="token operator">|</span> sbtest1     <span class="token operator">|</span> k_1          <span class="token operator">|</span>
<span class="token operator">|</span> sbtest        <span class="token operator">|</span> sbtest2     <span class="token operator">|</span> k_2          <span class="token operator">|</span>
<span class="token operator">|</span> sbtest        <span class="token operator">|</span> sbtest3     <span class="token operator">|</span> k_3          <span class="token operator">|</span>
<span class="token operator">|</span> sbtest        <span class="token operator">|</span> sbtest4     <span class="token operator">|</span> k_4          <span class="token operator">|</span>
<span class="token operator">|</span> tpch          <span class="token operator">|</span> customer    <span class="token operator">|</span> CUSTOMER_FK1 <span class="token operator">|</span>
<span class="token operator">|</span> tpch          <span class="token operator">|</span> lineitem    <span class="token operator">|</span> LINEITEM_FK2 <span class="token operator">|</span>
<span class="token operator">|</span> tpch          <span class="token operator">|</span> nation      <span class="token operator">|</span> NATION_FK1   <span class="token operator">|</span>
<span class="token operator">|</span> tpch          <span class="token operator">|</span> orders      <span class="token operator">|</span> ORDERS_FK1   <span class="token operator">|</span>
<span class="token operator">|</span> tpch          <span class="token operator">|</span> partsupp    <span class="token operator">|</span> PARTSUPP_FK1 <span class="token operator">|</span>
<span class="token operator">|</span> tpch          <span class="token operator">|</span> supplier    <span class="token operator">|</span> SUPPLIER_FK1 <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------------+-------------+--------------+</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果数据库运行时间比较长，而且索引的创建时间也比较久，索引还出现在上述结果中，DBA 就可以考虑删除这些没有用的索引</p><p>MySQL 8.0 版本推出了索引不可见（Invisible）功能。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> t1 
<span class="token keyword">ALTER</span> <span class="token keyword">INDEX</span> idx_name INVISIBLE<span class="token operator">/</span>VISIBLE<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在删除废弃索引前，用户可以将索引设置为对优化器不可见，然后观察业务是否有影响。若无，DBA 可以更安心地删除这些索引</p><h3 id="创建索引的情况" tabindex="-1"><a class="header-anchor" href="#创建索引的情况" aria-hidden="true">#</a> 创建索引的情况</h3><h4 id="适合创建索引" tabindex="-1"><a class="header-anchor" href="#适合创建索引" aria-hidden="true">#</a> 适合创建索引</h4><ol><li>字段有<strong>唯一性限制</strong>的，需要创建索引 <ul><li>InnoDB会自动给有唯一约束的列建一个唯一索引</li></ul></li><li><strong>频繁</strong>作为WHERE<strong>查询</strong>条件的</li><li>经常需要<strong>GROUP BY和ORDER BY</strong>的列 <ul><li>有序的分组相当于多次范围查询</li></ul></li><li>UPDATE、DELETE的WHERE条件列，用于快速定位要操作的数据</li><li><strong>DISTINCT</strong>字段需要创建索引 <ul><li>原理跟GROUP BY差不多，有序的去重相当于范围查询</li><li>并且去重的结果还会按照递增或者递减顺序展示</li></ul></li><li>多表JOIN连接时，需要注意 <ul><li>连接的表数量尽量不要超过3张，每增加1张就相当于多一次嵌套循环</li><li>对WHERE条件创建索引</li><li>对用于<strong>连接的字段创建索引</strong>，并且该字段在多张表中的类型必须一致，避免字段隐式类型转换导致索引失效</li></ul></li><li>使用列<strong>类型小的创建索引</strong>，特别是对于主键而言 <ul><li>以整数类型为例，有TINYINT , MEDIUMINT , INT , BIGINT等，他们占用的空间依次递增</li><li>如果想要对整数列创建索引，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如能使用INT就不适用BIGINT</li><li>数据类型越小，索引占用的存储空间越少，一个数据页可以放下更多的记录，从而减少磁盘I/O</li></ul></li><li><strong>区分度（选择性）高</strong>的列适合作为索引 <ul><li>$区分度(选择性)=\\frac{DISTINCT(col)}{COUNT(*)}$</li><li><code>SELECT COUNT(DISTINCT col) / COUNT(*) FROM table</code>：越接近1越好，一般超过33%就算是比较高效的索引</li></ul></li><li>在多个字段都要创建索引的情况下，<strong>联合索引优于单列索引，将使用频繁的字段放在联合索引的左侧</strong></li><li>使用字符串前缀创建索引 <ul><li>计算不同<strong>前缀索引的选择性</strong>：<code>count(distinct left(列名, 索引长度)) / count(*)</code><ul><li><code>LEFT(str, len)</code>：MySQL的一个函数，用于将字符串<code>str</code>的左边15个字符切片</li></ul></li></ul></li><li>如果一个字段经常需要计算最大最小值（聚合函数<code>MAX(),MIN()</code>），也可以考虑创建索引</li></ol><h4 id="不适合创建索引" tabindex="-1"><a class="header-anchor" href="#不适合创建索引" aria-hidden="true">#</a> 不适合创建索引</h4><ol><li>在<strong>WHERE中用不到</strong>的索引</li><li><strong>数据量小</strong>的表最好不要创建索引 <ul><li>数据量小的表本身查询效率就高，创建索引还会占用磁盘空间，性价比不大</li><li>如果不是覆盖索引还需要回表，增加额外的磁盘I/O，不如全表扫描快</li></ul></li><li>在有<strong>大量重复数据的列</strong>上不要创建索引 <ul><li>区分度（选择性）低的列</li><li>如果该列选择性低，但是又经常被拿来查询（例如：sex），可以将其设计为联合索引的一部分，使用<code>IN()</code>可以在不使用该列的情况下绕开该列，使查询条件符合最左匹配原则 ——&gt; <code>数据库设计/索引设计案例</code>中有详细说明</li></ul></li><li>避免对<strong>经常更新的表</strong>创建过多的索引</li><li>不建议<strong>使用无序的值作为索引</strong></li><li><strong>删除</strong>不再使用或者<strong>很少使用的索引</strong></li><li><strong>不要</strong>定义<strong>冗余或重复</strong>的索引 <ul><li>尽量不要定义新的索引，在要定义新的索引前，先看一下有没有可以<strong>重用的索引</strong></li></ul></li></ol><h3 id="唯一索引vs普通索引" tabindex="-1"><a class="header-anchor" href="#唯一索引vs普通索引" aria-hidden="true">#</a> 唯一索引vs普通索引</h3><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231225004652398.png" alt="image-20231225004652398" tabindex="0" loading="lazy"><figcaption>image-20231225004652398</figcaption></figure><h4 id="查询过程" tabindex="-1"><a class="header-anchor" href="#查询过程" aria-hidden="true">#</a> 查询过程</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> t <span class="token keyword">WHERE</span> k <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。</li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li></ul><p>InnoDB 的数据是按数据页为单位来读写的。</p><p>所以说，当找到 k=5 的记录的时候，它所在的数据页就都在内存里了。</p><p>那么，对于普通索引来说，要<strong>多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算</strong>。</p><p>这个<strong>操作成本对于现在的 CPU 来说可以忽略不计</strong></p><h4 id="更新过程" tabindex="-1"><a class="header-anchor" href="#更新过程" aria-hidden="true">#</a> 更新过程</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t <span class="token punctuation">(</span>id<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>第一种情况：<strong>记录要更新的目标页在内存中</strong><ul><li>唯一索引：找到3和5之间的为止，判断是否存在冲突，没有则插入这个值</li><li>普通索引：找到3和5之间的为止，插入这个值</li><li>普通索引和唯一索引的性能差别只是一个判断，只会耗费微小的CPU时间</li></ul></li><li>第二种情况：<strong>记录要更新的目标页不在内存中</strong><ul><li>唯一索引：需要将数据页读入内存，判断是否存在冲突，没有则插入这个值</li><li>普通索引：将更新操作记录在Change Buffer中，语句执行结束</li></ul></li></ul><p>普通索引在修改不存在于内存的数据时，因为使用Change Buffer减少了磁盘IO</p><p>将数据从磁盘读入内存的操作是随机IO，因此更新性能会有明显提升。</p><blockquote><p><strong>真实案例</strong></p></blockquote><p>有人负责的某个业务的库内存命中率突然从 99% 降低到了 75%，整个系统处于阻塞状态，更新语句全部堵住。</p><p>而探究其原因后，我发现这个业务有大量插入数据的操作，而他在前一天把其中的某个普通索引改成了唯一索引。</p><p>把数据库中某个普通索引改为唯一索引后：</p><ul><li>因为数据更新时无法使用Change Buffer，需要从磁盘读数据页判断之后才可以在内存中完成操作，大量插入操作发生时，因为读取数据页会有大量的磁盘IO，因此会阻塞</li><li>因为更新操作而加载了大量数据到Buffer Pool中，把一些被经常访问的数据页挤出了内存，因此导致内存命中率下降 <ul><li>这里之所以还有75%的命中率，是因为这些数据只会被添加到LRU链表的冷数据区，对前63%的young区数据影响不大</li><li>但是因为大量将数据加到缓存中，仍然会对部分经常访问的数据造成影响</li></ul></li></ul><h4 id="索引的选择和实践" tabindex="-1"><a class="header-anchor" href="#索引的选择和实践" aria-hidden="true">#</a> 索引的选择和实践</h4><p>在数据经过业务来到数据库，可以确保唯一性的情况下，使用唯一索引和普通索引的查询效率基本一致</p><p>而唯一索引的更新会有更大的开销，因此应该使用普通索引。例如：</p><ul><li>如果有一个存储“历史记录”的表，那么应该尽量使用普通索引，然后尽量扩大Change Buffer的空间，就可以确保“历史数据”表的写入速度</li><li>因为历史数据在写入后一般不会被立即访问，Change Buffer 的使用效率会更高</li></ul><p>不过当查询的数据时能够在二级索引的B+树的叶子节点里查询到，就不用再查主键索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 因为要查的返回结果是主键，叶子结点存放的就是主键</span>
<span class="token keyword">select</span> id <span class="token keyword">from</span> product <span class="token keyword">where</span> product_no <span class="token operator">=</span> <span class="token string">&#39;0002&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这种在二级索引的B+树就能查询到结果的过程叫作覆盖索引，也就是说只要查一个B+树就能找到数据</p><h3 id="索引设计案例" tabindex="-1"><a class="header-anchor" href="#索引设计案例" aria-hidden="true">#</a> 索引设计案例</h3><h4 id="案例介绍" tabindex="-1"><a class="header-anchor" href="#案例介绍" aria-hidden="true">#</a> 案例介绍</h4><p>要设计一个在线约会网站，用户信息表有很多列，包括<strong>国家、地区、城市、性别、眼睛颜色</strong>等</p><p>网站必须支持上面这些<strong>特征的各种组合来搜索</strong>用户</p><p>还必须允许根据用户的最后在线时间、其他会员对用户的评分等<strong>对用户进行排序</strong>并对结果进行限制</p><h4 id="支持多种过滤条件" tabindex="-1"><a class="header-anchor" href="#支持多种过滤条件" aria-hidden="true">#</a> 支持多种过滤条件</h4><blockquote><p><strong>首先需要考虑哪些列拥有很多不同的取值？哪些列在WHERE子句中出现的最频繁？</strong></p></blockquote><p>一般来说在有更多不同值的列上创建索引的选则性会更好，但是也得考虑使用的频率</p><ul><li>country 列的选择性通常不高，但可能很多查询会用到</li><li>sex 列的选择性通常也不高，但是也会有很多查询用到</li></ul><p>考虑到使用的频率，创建不同组合索引的时候还是需要将 (sex, country) 列作为前缀</p><ul><li>几乎所有的查询都会用到 sex 列，甚至网站会被设计为每次都只能按某一种性别查询用户</li><li>索引中加上 sex 列也没有坏处，即使查询没有用到 sex 列，也可以通过下面的诀窍来绕过 <ul><li>如果某个查询不限制性别，那么可以通过在查询条件中新增 <code>AND SEX IN(&#39;m&#39;, &#39;f&#39;)</code> 来让MySQL选择该索引</li><li>这样写不会过滤掉任何一行，和没有这个条件的情况返回相同</li><li>但是加上 sex 列的条件MySQ才能够按索引的最左进行匹配</li><li>但是如果索引有太多的取值，<code>IN()</code>列表太长，就不是很合适了</li></ul></li></ul><blockquote><p>这个诀窍有个缺点</p></blockquote><p>当<code>IN()</code>列表中的值太多，或者需要绕过的条件太多了</p><p>排列组合之后需要索引查找的次数就太多了，相对应的磁盘I/O就会变更多</p><ul><li>把B+树想象成一个三角形，单个范围查询条件可能只需要走一次侧边，找到左边界的记录之后就可以沿着叶子节点的指针走三角形的底边遍历取数据了</li><li>绕过一个条件，假设是<code>SEX IN (&#39;m&#39;, &#39;f&#39;)</code>，那就需要将三角形分为等面积的两部分，每一部分都来一次范围查询，也就是得走两次侧边和底边，需要从根节点启动定位两次左边界记录</li><li>绕过N个条件，三角形被拆分可就不是简单的N个，而是排列组合后的总数，每一部分都来一次范围查询，得走很多很多次侧边和底边，这样的开销其实跟全表扫描就差不了多少了</li></ul><blockquote><p><strong>接下来要考虑常见WHERE条件的组合，并了解哪些组合在没有合适索引的情况下会很慢</strong></p></blockquote><p><code>(sex, country, age)</code>上的索引就是一个很明显的组合</p><p>另外可能还需要 <code>(sex, country, region, age)</code>, <code>(sex, country, region, city, age)</code>这样的组合索引。</p><p>但是如果考虑到所有条件查询的条件，那就需要建立大量的索引</p><p>想尽可能重用索引而不是建立大量的组合索引，可以用<code>IN()</code>来去除重复冗余的索引</p><p>但是这个技巧也不能在同一语句中被太多列使用，否则优化器可能也不会使用索引，<strong>具体还是得根据业务来权衡这两者之间的平衡</strong></p><blockquote><p>为什么age字段总是在最后一个？</p></blockquote><p>设计age字段的条件几乎都是范围查询，而范围查询会截断索引的使用</p><p>第一种方案就是将这种字段放在联合索引的最后面</p><p>第二种方案就是用<code>IN()</code>来替换掉范围查询</p><ul><li><code>age BETWEEN 18 AND 25</code> 改成 <code>age IN (18, 19, 20, 21, 22, 23, 24, 25)</code></li></ul><h4 id="避免多个范围条件" tabindex="-1"><a class="header-anchor" href="#避免多个范围条件" aria-hidden="true">#</a> 避免多个范围条件</h4><blockquote><p>什么是范围条件？Explain能看出来吗？</p></blockquote><p>EXPLAIN会使用同样的词<code>type:range</code>来描述两种情况</p><ol><li>范围条件查询：<code>&gt;, &lt; BETWEEN</code></li><li>多个等值条件查询：<code>IN()</code></li></ol><p>对于范围条件查询，MySQL无法再使用范围列后面的其他索引列了</p><p>对于多个等值条件查询，就没有这个限制</p><blockquote><p>如果一个查询语句有两个范围条件怎么办？</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">WHERE</span> last_online <span class="token operator">&gt;</span> DATE_SUB<span class="token punctuation">(</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">INTERVAL</span> <span class="token number">7</span> <span class="token keyword">DAY</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token operator">AND</span> age <span class="token operator">BETWEEN</span> <span class="token number">18</span> <span class="token operator">AND</span> <span class="token number">25</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>last_online &gt; DATE_SUB(NOW(), INTERVAL 7 DAY)</code>：查询最后在线时间是7天内的用户</li></ul><p>一种方法是将<code>last_online</code>列放在<code>age</code>列的后面，然后<code>age</code>范围条件查询改成多个等值条件查询（<code>IN()</code>）</p><p>另一种方法是将其中一个范围查询转换成一个简单的等值比较</p><ul><li>事先计算好一个<code>active</code>列，这个字段由定时任务来维护</li><li>用户每次登录时，将这个值设为1，过去连续7天没有登录的用户设为0</li><li>创建索引<code>(active, sex, country, age)</code>，然后就可以使用它了</li><li><code>active</code>列并不是完全精确的，但是对于这个场景下来说，对精度的要求也不是特别高</li><li>如果需要精确数据，可以将<code>last_online</code>列放到<code>WHERE</code>子句中，但不加入索引中</li><li>但其实，这个条件的过滤性不高，缺少合适的索引对该查询的影响不明显</li></ul><h4 id="优化排序" tabindex="-1"><a class="header-anchor" href="#优化排序" aria-hidden="true">#</a> 优化排序</h4><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>SELECT &lt;cols&gt; FROM profiles WHERE sex=&#39;M&#39; ORDER BY rating LIMIT 100000, 10;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>已经建立了索引<code>(sex, rating)</code></p><p>如果不做优化，首先会在二级索引里面找出十万条主键，然后进行十万次回表，最后用回表得到的数据再去LIMIT切片</p><blockquote><p>条件查询+排序+分页怎么优化？</p></blockquote><p>从业务上入手：限制用户能够翻页的数量，例如：只给翻100页</p><ul><li>可能100页之后的数据都是老旧数据或者低分数据，没有必要展示出来</li></ul><p>从SQL入手：使用延迟关联</p><ul><li>通过使用覆盖索引查询返回需要的主键，再根据这些主键去关联原表获取需要的行</li><li>这样就可以极大的减少回表次数（100000 -&gt; 10）</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">&lt;</span>cols<span class="token operator">&gt;</span> <span class="token keyword">FROM</span> profies <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> <span class="token punctuation">(</span>
	<span class="token keyword">SELECT</span> <span class="token operator">&lt;</span><span class="token keyword">primary</span> <span class="token keyword">key</span> cols<span class="token operator">&gt;</span> <span class="token keyword">FROM</span> profiles
    <span class="token keyword">WHERE</span> x<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">&#39;M&#39;</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> rating <span class="token keyword">LIMIT</span> <span class="token number">100000</span><span class="token punctuation">,</span> <span class="token number">10</span>
<span class="token punctuation">)</span><span class="token keyword">AS</span> x <span class="token keyword">USING</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token keyword">primary</span> <span class="token keyword">key</span> cols<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="sql设计" tabindex="-1"><a class="header-anchor" href="#sql设计" aria-hidden="true">#</a> SQL设计</h2><h3 id="order-by排序" tabindex="-1"><a class="header-anchor" href="#order-by排序" aria-hidden="true">#</a> ORDER BY排序</h3><blockquote><p>示例SQL</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> city<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age FORM t <span class="token keyword">WHERE</span> city<span class="token operator">=</span><span class="token string">&#39;杭州&#39;</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> name <span class="token keyword">LIMIT</span> <span class="token number">1000</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>并不是所有的 order by 语句，都需要排序操作的。</p><p>MySQL 之所以需要生成临时表，并且在临时表上做排序操作，<strong>其原因是原来的数据都是无序的。</strong></p><p>如果能够保证从 city 这个索引上取出来的行，天然就是按照 name 递增排序的话，就可以不用再排序了</p><h4 id="联合索引" tabindex="-1"><a class="header-anchor" href="#联合索引" aria-hidden="true">#</a> 联合索引</h4><p>在这个市民表上创建一个 city 和 name 的联合索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">alter</span> <span class="token keyword">table</span> t <span class="token keyword">add</span> <span class="token keyword">index</span> city_user<span class="token punctuation">(</span>city<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231205212309680.png" alt="image-20231205212309680" tabindex="0" loading="lazy"><figcaption>image-20231205212309680</figcaption></figure><p>在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足 city=‘杭州’的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要 city 的值是杭州，name 的值就一定是有序的</p><p><strong>查询的流程变为</strong></p><ol><li>从索引 (city,name) 找到第一个满足 <code>city=‘杭州’</code>条件的主键 id；</li><li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，作为结果集的一部分直接返回；</li><li>从索引 (city,name) 取下一个记录主键 id；</li><li>重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 <code>city=‘杭州’</code>条件时循环结束。</li></ol><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231205212404742.png" alt="image-20231205212404742" tabindex="0" loading="lazy"><figcaption>image-20231205212404742</figcaption></figure><blockquote><p><strong>explain</strong></p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231205212744447.png" alt="image-20231205212744447" tabindex="0" loading="lazy"><figcaption>image-20231205212744447</figcaption></figure><p>Extra 字段中没有 Using filesort 了，也就是不需要排序了。</p><p>由于 (city,name) 这个联合索引本身有序，所以这个查询也不用把 4000 行全都读一遍，只要找到满足条件的前 1000 条记录就可以退出了，也就是说只需要扫描 1000 次。</p><h4 id="覆盖索引" tabindex="-1"><a class="header-anchor" href="#覆盖索引" aria-hidden="true">#</a> 覆盖索引</h4><blockquote><p><strong>覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键索引上去取数据</strong></p></blockquote><p>创建一个 city、name 和 age 的联合索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">alter</span> <span class="token keyword">table</span> t <span class="token keyword">add</span> <span class="token keyword">index</span> city_user_age<span class="token punctuation">(</span>city<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对于 city 字段的值相同的行来说，还是按照 name 字段的值递增排序的，此时的查询语句也就不再需要排序</p><p><strong>查询的流程变为</strong></p><ol><li>从索引 (city,name,age) 找到第一个满足 city=‘杭州’条件的记录，取出其中的 city、name 和 age 这三个字段的值，作为结果集的一部分直接返回；</li><li>从索引 (city,name,age) 取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；</li><li>重复执行步骤 2，直到查到第 1000 条记录，或者是不满足 city=‘杭州’条件时循环结束。</li></ol><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231205212645444.png" alt="image-20231205212645444" tabindex="0" loading="lazy"><figcaption>image-20231205212645444</figcaption></figure><blockquote><p><strong>explain</strong></p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231205212910725.png" alt="image-20231205212910725" tabindex="0" loading="lazy"><figcaption>image-20231205212910725</figcaption></figure><h3 id="join连表" tabindex="-1"><a class="header-anchor" href="#join连表" aria-hidden="true">#</a> JOIN连表</h3><h4 id="oltp业务的join" tabindex="-1"><a class="header-anchor" href="#oltp业务的join" aria-hidden="true">#</a> OLTP业务的JOIN</h4><blockquote><p>OLTP是什么？</p></blockquote><p>OLTP是海量并发，要求相应非常及时，在毫秒级别返回结果</p><ul><li>淘宝的电商业务，支付宝的支付业务，美团的外卖业务等</li></ul><blockquote><p>OLTP业务能不能写JOIN语句？</p></blockquote><p>如果OLTP业务的JOIN带有WHERE过滤条件，并且是根据主键、索引进行过滤</p><p>那么此时驱动表可能只有一条或者几条记录，这时进行JOIN的开销是非常小的</p><blockquote><p>淘宝电商例子</p></blockquote><p>用户查看自己的订单情况</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> o_custkey<span class="token punctuation">,</span> o_orderdate<span class="token punctuation">,</span> o_totalprice<span class="token punctuation">,</span> p_name 
<span class="token keyword">FROM</span> orders<span class="token punctuation">,</span> lineitem<span class="token punctuation">,</span> part
<span class="token keyword">WHERE</span> o_orderkey <span class="token operator">=</span> l_orderkey
  <span class="token operator">AND</span> l_partkey <span class="token operator">=</span> p_partkey
  <span class="token operator">AND</span> o_custkey <span class="token operator">=</span> ?
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> o_orderdate <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">30</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>从订单、订单明细、商品信息这三个表中提取特定客户的订单信息</li><li>订单信息包括订单日期、订单总价以及商品名称</li><li>结果集按照订单日期降序排列</li><li>最后限制结果集为最新的30个订单</li></ul><p>许多人可能会将这个连表语句拆分为三个小的条件查询语句</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> orders 
<span class="token keyword">WHERE</span> o_custkey <span class="token operator">=</span> ? 
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> o_orderdate <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">30</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> lineitem
<span class="token keyword">WHERE</span> l_orderkey <span class="token operator">=</span> ?<span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> part
<span class="token keyword">WHERE</span> p_part <span class="token operator">=</span> ?
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但其实完全不用人工拆分，这个拆分的过程就是优化器的执行结果，而且优化器更可靠，速度更快</p><p>人为拆成三条 SQL 的方式，本身网络交互的时间开销就大了 3 倍。</p><blockquote><p><strong>永远可以相信MySQL的优化器</strong></p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">EXPLAIN</span>: <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token keyword">Limit</span>: <span class="token number">30</span> <span class="token keyword">row</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">27.76</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">)</span>
    <span class="token operator">-</span><span class="token operator">&gt;</span> Nested <span class="token keyword">loop</span> <span class="token keyword">inner</span> <span class="token keyword">join</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">27.76</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">44</span><span class="token punctuation">)</span>
        <span class="token operator">-</span><span class="token operator">&gt;</span> Nested <span class="token keyword">loop</span> <span class="token keyword">inner</span> <span class="token keyword">join</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">12.45</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">44</span><span class="token punctuation">)</span>
            <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token keyword">Index</span> lookup <span class="token keyword">on</span> orders <span class="token keyword">using</span> idx_custkey_orderdate <span class="token punctuation">(</span>O_CUSTKEY<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">iterate</span> backwards<span class="token punctuation">)</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">3.85</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">)</span>
            <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token keyword">Index</span> lookup <span class="token keyword">on</span> lineitem <span class="token keyword">using</span> <span class="token keyword">PRIMARY</span> <span class="token punctuation">(</span>l_orderkey<span class="token operator">=</span>orders<span class="token punctuation">.</span>o_orderkey<span class="token punctuation">)</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.42</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>
        <span class="token operator">-</span><span class="token operator">&gt;</span> Single<span class="token operator">-</span><span class="token keyword">row</span> <span class="token keyword">index</span> lookup <span class="token keyword">on</span> part <span class="token keyword">using</span> <span class="token keyword">PRIMARY</span> <span class="token punctuation">(</span>p_partkey<span class="token operator">=</span>lineitem<span class="token punctuation">.</span>L_PARTKEY<span class="token punctuation">)</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.25</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><code>Index lookup on orders using idx_custkey_orderdate (O_CUSTKEY=1; iterate backwards) (cost=3.85 rows=11)</code><ul><li>首先，通过在订单表上使用名为<code>idx_custkey_orderdate</code>的索引</li><li>以<code>O_CUSTKEY</code>等于1的条件进行反向迭代，进行订单的索引查找（ORDER BY）</li><li>该操作的成本为3.85，预计返回11行</li></ul></li><li><code>Index lookup on lineitem using PRIMARY (l_orderkey=orders.o_orderkey) (cost=0.42 rows=4)</code><ul><li>在上述操作的基础上，执行了一个内连接</li><li>连接订单表和订单明细表</li><li>在订单明细表上使用名为<code>PRIMARY</code>的主键索引进行查找</li><li>条件是订单明细表的<code>l_orderkey</code>等于订单表中的<code>o_orderkey</code></li><li>该操作的成本为0.42，预计返回4行。</li></ul></li><li><code>Single-row index lookup on part using PRIMARY (p_partkey=lineitem.L_PARTKEY) (cost=0.25 rows=1)</code>: <ul><li>进一步，在上述的内连接基础上，执行了另一个内连接</li><li>连接订单明细表和商品信息表</li><li>在商品信息表上使用名为<code>PRIMARY</code>的主键索引进行查找</li><li>条件是商品信息表的<code>p_partkey</code>等于订单明细表中的<code>L_PARTKEY</code></li><li>该操作的成本为0.25，预计返回1行。</li></ul></li><li><code>Nested loop inner join (cost=12.45 rows=44)</code>: <ul><li>在第2步和第3步的基础上，执行了一个嵌套循环内连接，将订单表、订单明细表和商品信息表连接在一起</li><li>连接的成本为12.45，总行数为44行。</li></ul></li><li><code>Nested loop inner join (cost=27.76 rows=44)</code>: <ul><li>在第1步和第4步的基础上，执行了另一个嵌套循环内连接，将前面的结果与订单表再次连接</li><li>连接的成本为27.76，总行数为44行。</li></ul></li><li><code>Limit: 30 row(s) (cost=27.76 rows=30)</code>: <ul><li>最后，在第二个嵌套循环内连接的结果上执行LIMIT操作</li><li>限制结果集的大小为最多30行</li><li>这个LIMIT操作的成本为27.76，而实际行数为30行。</li></ul></li></ol><p>由于驱动表的数据是固定 30 条，因此不论表 orders、lineitem、part 的数据量有多大，哪怕是百亿条记录，由于都是通过主键进行关联，上述 SQL 的执行速度几乎不变。</p><p><strong>所以，OLTP 业务完全可以大胆放心地写 JOIN，但是要确保 <u>JOIN 的索引都已添加</u></strong></p><p>DBA 们在业务上线之前一定要做 SQL Review，确保预期内的索引都已创建。</p><h4 id="优化join语句" tabindex="-1"><a class="header-anchor" href="#优化join语句" aria-hidden="true">#</a> 优化JOIN语句</h4><h5 id="mrr优化" tabindex="-1"><a class="header-anchor" href="#mrr优化" aria-hidden="true">#</a> MRR优化</h5><blockquote><p>Multi-Range Read 优化 (MRR)</p></blockquote><p>这个优化的主要目的是<strong>尽量使用顺序读盘</strong>。</p><p>MRR会开辟一个<code>read_rnd_buffer</code>缓冲区，用于存放在二级索引中查找到的主键ID</p><p>结束二级索引查找之后，将<code>read_rnd_buffer</code>缓冲区内的主键ID进行递增排序</p><p>拿排好序的主键ID去聚簇索引回表，可以避免大量重复的随机I/O</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a <span class="token operator">&gt;=</span> <span class="token number">1</span> <span class="token operator">and</span> a <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>MRR优化前</strong></p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231228234502771.png" alt="image-20231228234502771" tabindex="0" loading="lazy"><figcaption>image-20231228234502771</figcaption></figure><ol><li>根据索引a，定位到满足条件的记录主键</li><li>拿获取到的满足条件的ID去回表，取出完整的数据去返回</li></ol><p><strong>MRR优化后</strong></p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231228234440162.png" alt="image-20231228234440162" tabindex="0" loading="lazy"><figcaption>image-20231228234440162</figcaption></figure><ol><li>根据索引 a，定位到满足条件的记录，将 id 值放入 <code>read_rnd_buffer</code> 中 ;</li><li>将 <code>read_rnd_buffer</code> 中的 id 进行递增排序；</li><li>排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回。</li></ol><p>read_rnd_buffer 的大小是由 read_rnd_buffer_size 参数控制的。</p><p>如果步骤 1 中，read_rnd_buffer 放满了，就会先执行完步骤 2 和 3，然后清空 read_rnd_buffer。</p><p>之后继续找索引 a 的下个记录，并继续循环。</p><h5 id="batched-key-acess" tabindex="-1"><a class="header-anchor" href="#batched-key-acess" aria-hidden="true">#</a> Batched Key Acess</h5><blockquote><p>Batched Key Access(BKA) 算法</p></blockquote><p>BKA 算法，其实就是对 Index Nested-Loop Join(NLJ) 算法的优化</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231228234651414.png" alt="image-20231228234651414" tabindex="0" loading="lazy"><figcaption>image-20231228234651414</figcaption></figure><p>这是NLJ算法的流程图</p><ul><li>从驱动表 t1，一行行地取出 a 的值，再到被驱动表 t2 去做 join</li><li>对表t2来说，每次都是匹配一个值，这时MRR的优势就用不上了</li></ul><blockquote><p>那怎么才能一次性地多传些值给表 t2 呢？</p></blockquote><p>把表 t1 的数据取出来一部分，先放到一个join_buffer。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231229000553112.png" alt="image-20231229000553112" tabindex="0" loading="lazy"><figcaption>image-20231229000553112</figcaption></figure><ul><li>如果join buffer 放不下所有的数据，就会按照 join buffer的大小将数据分为多段执行BKA流程</li></ul><hr>`,317),l=[p];function t(i,r){return s(),n("div",null,l)}const u=a(o,[["render",t],["__file","数据库设计.html.vue"]]);export{u as default};
