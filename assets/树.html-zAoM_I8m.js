import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as l,c as a,f as n}from"./app-OTaO6_y0.js";const e={},r=n('<h1 id="树" tabindex="-1"><a class="header-anchor" href="#树" aria-hidden="true">#</a> 树</h1><h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h2><ul><li><p>树(Tree)是n(n≥0)个结点的有限集T，n=0的树称为空树，n&gt;0时其中：</p><p>有且仅有一个特定的结点，称为树的根(root)</p></li><li><p>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1,T2,……Tm，其中每一个集合本身又是一棵树，称为根的子树(Subtree)</p></li><li><p>特点</p><ul><li>非空书至少有一个结点（根），除了根节点之外的所有节点有且只有一个前驱结点</li><li>树中所有结点可以有零个或多个后继结点</li></ul></li></ul><h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h2><ul><li>最上边的是根节点</li><li>并列的节点互为兄弟节点</li><li>下方的节点为子节点</li><li>度是该节点拥有的子节点数 <ul><li>度不为0的节点称为分支节点</li><li>度为0的节点称为叶结点</li><li>各个节点数的最大值称为该数的度</li></ul></li><li>层数 <ul><li>树的根节点层数为1，其余节点顺着往下累加</li><li>树中叶结点的最大层次树被称为树的深度</li></ul></li><li>在树中，如果有一条路径从结点M到结点N，那么M为N的祖先，N称为M的子孙</li></ul><h2 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树" aria-hidden="true">#</a> 二叉树</h2><h3 id="定义-1" tabindex="-1"><a class="header-anchor" href="#定义-1" aria-hidden="true">#</a> 定义</h3><ul><li><p>二叉树是n(n&gt;=0)个结点的有限集，它或为空树(n=0)，或由一个根结点和两棵分别称为左子树和右子树的互不相交的二叉树构成</p></li><li><p>特点</p><ul><li><p>每个结点至多有二棵子树(即不存在度大于2的结点)</p></li><li><p>二叉树的子树有左、右之分，且其次序不能任意颠倒</p></li></ul></li></ul><h3 id="性质" tabindex="-1"><a class="header-anchor" href="#性质" aria-hidden="true">#</a> 性质</h3><ul><li>若根节点的层次为1，则二叉树第 i 层最多有$2^{i-1}(i&gt;=1)$ 个节点</li><li>在高度为h的二叉树中，最多有$2^k-1$个节点 $(h&gt;=0)$</li><li>设一棵二叉树的叶子节点数为$n_0$，2度节点数为$n_2$，则$n_0 = n_2 + 1$</li><li>一棵具有n个节点的完全二叉树，其高度$h = floor(log_2n)+1$</li><li>一棵具有n个节点的完全二叉树，对序号为$i(0&lt;=i&lt;=n)$的节点，有： <ul><li>若$i&gt;0$，则i的父母节点序号为$floor((i-1)/2)$，其左右子女的编号分别为$2<em>i+1$和$2</em>i+2$</li></ul></li></ul><h3 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h3><ul><li><strong>满二叉树</strong>：在一棵二叉树上，如果所有分支节点都存在左右字数，并且所有叶子结点都在同一层上</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230625220519181.png" alt="image-20230625220108276" tabindex="0" loading="lazy"><figcaption>image-20230625220108276</figcaption></figure><ul><li><p>满二叉树的特点</p><ul><li>叶子只能出现在最下一层</li><li>非叶子节点的度一定是2</li><li>同样深度的二叉树中，满二叉树的结点个数最多，叶子最多</li></ul></li><li><p><strong>完全二叉树</strong>：一棵深度为k，有n个结点的二叉树，对树中的结点按照从上至下，从左到右的顺序编号，若编号为i的结点与深度为k的满二叉树中编号为i的结点位置相同，则称为完全二叉树</p></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230625220108276.png" alt="image-20230625220519181" tabindex="0" loading="lazy"><figcaption>image-20230625220519181</figcaption></figure><ul><li>完全二叉树的特点 <ul><li>叶子结点只能出现在最下两层</li><li>最下层的叶子一定集中在左部连续区域</li><li>倒数第二层若有叶子结点，一定都在右部连续区域</li><li>如果结点度为1，则该节点只有左孩子</li><li>同样接单的二叉树，完全二叉树的深度最小</li></ul></li><li>满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树</li></ul><h3 id="遍历规则" tabindex="-1"><a class="header-anchor" href="#遍历规则" aria-hidden="true">#</a> 遍历规则</h3><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230625231653643.png" alt="image-20230617151123370" tabindex="0" loading="lazy"><figcaption>image-20230617151123370</figcaption></figure><h4 id="广度优先遍历" tabindex="-1"><a class="header-anchor" href="#广度优先遍历" aria-hidden="true">#</a> 广度优先遍历</h4><ul><li>尽可能先访问距离最近的节点，也称为<strong>层序遍历</strong></li><li>1,2,3,4,5,6</li></ul><h4 id="深度优先遍历" tabindex="-1"><a class="header-anchor" href="#深度优先遍历" aria-hidden="true">#</a> 深度优先遍历</h4><h5 id="前序遍历" tabindex="-1"><a class="header-anchor" href="#前序遍历" aria-hidden="true">#</a> 前序遍历</h5><ul><li>先访问该节点</li><li>然后是左子树</li><li>最后是右子树</li><li>1,2,4,3,5,6</li></ul><h5 id="中序遍历" tabindex="-1"><a class="header-anchor" href="#中序遍历" aria-hidden="true">#</a> 中序遍历</h5><ul><li>先访问左子树</li><li>然后是该节点</li><li>最后是右子树</li><li>4,2,1,5,3,6</li></ul><h5 id="后续遍历" tabindex="-1"><a class="header-anchor" href="#后续遍历" aria-hidden="true">#</a> 后续遍历</h5><ul><li>先访问左子树</li><li>然后是右子树</li><li>最后是该节点</li><li>4,2,5,6,3,1</li></ul><h2 id="树-森林转换为二叉树" tabindex="-1"><a class="header-anchor" href="#树-森林转换为二叉树" aria-hidden="true">#</a> 树/森林转换为二叉树</h2><ul><li>将各结点的兄弟结点变成其右子节点</li><li>左子节点还是左子节点</li><li>在森林中，将所有所有其他子树的根节点看成第一棵树的兄弟节点</li></ul><h2 id="树的遍历" tabindex="-1"><a class="header-anchor" href="#树的遍历" aria-hidden="true">#</a> 树的遍历</h2><ul><li>先根遍历 <ul><li>访问根节点</li><li>按照从左到右的顺序先根遍历根节点的每一棵子树</li></ul></li><li>后根遍历 <ul><li>按照从左到右的顺序后根遍历根结点的每一棵子树</li><li>访问根结点</li></ul></li><li>树的<strong>先根遍历</strong>与其对应二叉树的<strong>先根遍历</strong>结果一样</li><li>树的<strong>后根遍历</strong>与其对应二叉树的<strong>中根遍历</strong>结果一样</li></ul><h2 id="森林的遍历" tabindex="-1"><a class="header-anchor" href="#森林的遍历" aria-hidden="true">#</a> 森林的遍历</h2><ul><li><p>前序遍历</p><ul><li><p>访问森林中第一棵树的根结点；</p></li><li><p>前序遍历第一棵树的根结点的子树森林；</p></li><li><p>前序遍历去掉第一棵树后的子森林。</p></li></ul></li><li><p>中序遍历</p><ul><li><p>中序遍历第一棵树的根结点的子树森林；</p></li><li><p>访问森林中第一棵树的根结点；</p></li><li><p>中序遍历去掉第一棵树后的子森林。</p></li></ul></li><li><p>后序遍历</p><ul><li><p>后序遍历森林中第一棵树的根结点的子树森林。</p></li><li><p>后序遍历除去第一棵树之后剩余的树构成的森林。</p></li><li><p>访问第一棵树的根结点。</p></li></ul></li></ul><h2 id="哈夫曼树" tabindex="-1"><a class="header-anchor" href="#哈夫曼树" aria-hidden="true">#</a> 哈夫曼树</h2><h3 id="基本概念-1" tabindex="-1"><a class="header-anchor" href="#基本概念-1" aria-hidden="true">#</a> 基本概念</h3><ul><li><p>路径长度：在二叉树中，从一个结点可以到达的孩子或子孙结点之间的通路称为路径，通路中的分支数目称为路径长度。</p></li><li><p>权值：将二叉树中结点赋予一个有着某种意义的数值，这个数值就是结点的权值。</p></li><li><p>带权路径长度：路径×权值</p></li><li><p>二叉树的带权路径长度：设二叉树具有n个带权值的叶结点，那么从根结点到各个叶结点的路径长度与相应结点权值的乘积之和叫做二叉树的带权路径长度</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230625232009012.png" alt="image-20230625231653643" tabindex="0" loading="lazy"><figcaption>image-20230625231653643</figcaption></figure><ul><li>$W_i$为第i个叶结点的权值，$L_i$为第i个叶结点的路径长度</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230626133507638.png" alt="image-20230625232009012" tabindex="0" loading="lazy"><figcaption>image-20230625232009012</figcaption></figure><ul><li>$WPL = 2 × 2 + 4 × 2 + 5 × 2 + 3 × 2 = 28$</li></ul></li><li><p>给定一组权值，用以作为叶结点可以构造出不同形状的二叉树。</p></li></ul><h3 id="定义-2" tabindex="-1"><a class="header-anchor" href="#定义-2" aria-hidden="true">#</a> 定义</h3><ul><li><p>用n个权值${W_1，W_2，…，W_n}$，构造有n个叶子结点的二叉树，将带权路径长度<strong>WPL最小</strong>的那棵树称作<strong>哈夫曼树</strong>或<strong>最优二叉树</strong>。</p></li><li><p>构建哈夫曼树步骤：</p><ul><li>由n个权值{$W_1, W_2,···, W_n$}的，构造n棵只有一个节点的二叉树集合，其中每棵二叉树中只有一个带权为$W_i$的根结点，其左右子树为空</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230617151123370.png" alt="image-20230626133507638" tabindex="0" loading="lazy"><figcaption>image-20230626133507638</figcaption></figure><ul><li><p>在二叉树集合中选根结点权值最小的两棵树作为左右子树，合成一棵新的二叉树，这棵新的二叉树的根结点权值为左右子树权值之和</p></li><li><p>删除集合中两棵被合成的树，将新建的树放入原集合中</p></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230626133820932.png" alt="image-20230626133820932" tabindex="0" loading="lazy"><figcaption>image-20230626133820932</figcaption></figure><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230626133829682.png" alt="image-20230626133829682" tabindex="0" loading="lazy"><figcaption>image-20230626133829682</figcaption></figure><ul><li>重复2、3步，当集合中只剩下最后一棵树的时候，这棵树就是哈夫曼树</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230626135638523.png" alt="image-20230626133844339" tabindex="0" loading="lazy"><figcaption>image-20230626133844339</figcaption></figure></li><li><p>特点</p><ul><li>给定<strong>n</strong>个权值，需要经过<strong>n-1次合并</strong>才能得到一棵哈夫曼树</li><li>经过n-1次合并得到n-1个新节点，这n-1个新结点都是具有两个孩子结点的分支节点，也就是说<strong>哈夫曼树中没有度为1的结点</strong></li><li>构造的哈夫曼树共有<strong>2n-1个结点</strong></li></ul></li><li><p>哈夫曼树的存储结构设计</p></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230626133844339.png" alt="image-20230626135638523" tabindex="0" loading="lazy"><figcaption>image-20230626135638523</figcaption></figure><h3 id="编码" tabindex="-1"><a class="header-anchor" href="#编码" aria-hidden="true">#</a> 编码</h3><ul><li>在编码时考虑字符出现的频率，让出现频率高的字符采用尽可能短的编码，出现频率低的字符采用稍长的编码，构造一种不等长编码，电文的代码就可能更短</li><li>在建立不等长编码时，必须使任何一个字符的编码都不是另一个字符编码的前缀（最左子串），这样才能保证译码的唯一性。这样的编码也称前缀编码。</li><li>假设这八个字母出现的频率已知为： <ul><li>A：5，B：29，C：7，D：8，E：14，F：23，G：3，H：11</li></ul></li><li>A-H的不等长编码设置为： <ul><li>A：000 B：0 C：01 D：10 E：00 F：1 G：110 H：11</li></ul></li><li>将字母出现的概率按从高到低排序</li><li>概率大的编码短，使用01组成编码</li></ul>',41),g=[r];function t(u,h){return l(),a("div",null,g)}const s=i(e,[["render",t],["__file","树.html.vue"]]);export{s as default};
