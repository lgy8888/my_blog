import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as i,c as a,f as r}from"./app-OTaO6_y0.js";const d={},n=r('<h1 id="redis与客户端" tabindex="-1"><a class="header-anchor" href="#redis与客户端" aria-hidden="true">#</a> Redis与客户端</h1><h2 id="redis二进制协议" tabindex="-1"><a class="header-anchor" href="#redis二进制协议" aria-hidden="true">#</a> Redis二进制协议</h2><h3 id="redis交互协议" tabindex="-1"><a class="header-anchor" href="#redis交互协议" aria-hidden="true">#</a> Redis交互协议</h3><p>Redis自定义了一种客户端与服务器的交互协议，叫<strong>RESP</strong>(Redis Serialization Protocol)</p><p>官方表示RESP协议是三个目标的折中：<strong>实现简单，解析速度快，可读性强</strong></p><p>RESP能序列化不同的数据</p><p>请求从客户端以字符串数组的方式发送到Redis服务器，这些字符串数组表示要执行的命令的参数，Redis用特定于命令的数据类型回复</p><h3 id="网络层" tabindex="-1"><a class="header-anchor" href="#网络层" aria-hidden="true">#</a> 网络层</h3><p>连到Redis服务器的客户端建立了一个到特定端口的TCP连接，端口号Redis默认是6379</p><p>所以实际上，在Redis的交互上，该协议一般仅用于TCP连接。</p><h3 id="请求-响应模型" tabindex="-1"><a class="header-anchor" href="#请求-响应模型" aria-hidden="true">#</a> 请求-响应模型</h3><p>一般来说都是客户端发送消息给服务器，服务端收到命令后进行处理，处理完成后返回客户端，在消息返回客户端前客户端处于等待状态，直到收到返回，才可以结束或发下一条消息</p><p>两种例外的模式</p><ul><li><strong>pipeline模式</strong>：Redis支持管道pipelining。所以，客户端可以一次发送多条命令，然后等待应答</li><li><strong>发布订阅模式</strong>：当一个Redis客户端订阅一个频道，那么协议会改变语义并变成Push模式，也就是说，这种情况下服务器会主动发送消息给客户端</li></ul><h3 id="resp协议解释" tabindex="-1"><a class="header-anchor" href="#resp协议解释" aria-hidden="true">#</a> RESP协议解释</h3><p>RESP是一个支持多种数据类型的序列化协议：简单字符串，错误，整型，多行字符串，数组</p><p>RESP在Redis中作为一个请求-响应协议以如下方式使用</p><ul><li>客户端以大容量字符串RESP数组的方式发送命令给服务器端</li><li>服务器端根据命令的具体实现返回某一种RESP数据类型</li></ul><p>在RESP中，数据类型依赖于首节</p><ul><li><strong>整型(Integers)</strong>：响应的首字节是<code>:</code></li><li><strong>简单字段串(Simple Strings)</strong>：响应的首字节是<code>+</code>，这个类型是为了简单字段串，比如常见的<code>OK</code></li><li><strong>多行字符串(Bulk strings)</strong>：响应的首字节是<code>$</code>，这个类型就是正常的返回字符串</li><li><strong>数组(Arrays)</strong>：响应的首字节是<code>*</code></li><li><strong>错误(Errors)</strong>：响应的首字节是<code>_</code></li></ul><h2 id="pipeline" tabindex="-1"><a class="header-anchor" href="#pipeline" aria-hidden="true">#</a> pipeline</h2><h3 id="pipeline技术" tabindex="-1"><a class="header-anchor" href="#pipeline技术" aria-hidden="true">#</a> pipeline技术</h3><p>管道技术，将请求打包在一起，通过管道传递</p><p>pipeline技术是很成熟的技术，很多其他组件中也有它的身影，如：HTTP2.0，ETCD，POP3协议</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231110143054942.png" alt="image-20231110143054942" tabindex="0" loading="lazy"><figcaption>image-20231110143054942</figcaption></figure><p>pipeline的本质是将请求在客户端打包，然后一次发送给服务端，服务端处理完成后，会将结果存起来，等pipeline中的所有命令都完成了，再一起回包</p><h3 id="pipeline代价" tabindex="-1"><a class="header-anchor" href="#pipeline代价" aria-hidden="true">#</a> pipeline代价</h3><ul><li>当使用pipeline，服务端不得不为回包排队，同一时间占用更多内存，所以非特定场景，不然没必要强行用Pipeline</li><li>单个命令执行时间会变长，是应为需要等待pipeline中的其他命令完成</li></ul><h3 id="pipeline注意事项" tabindex="-1"><a class="header-anchor" href="#pipeline注意事项" aria-hidden="true">#</a> pipeline注意事项</h3><ul><li>pipeline的命令不是原子的，实际上Redis还是一条一条去执行</li></ul><blockquote><p>如果前后包个multi和exec，其实就能实现原子了</p></blockquote><ul><li>pipeline包含的命令不宜过多，Redis内存寸土寸金</li><li>Pipeline只会在一个Redis节点上执行，客户端是发送了一次请求，不会分发到多个节点上</li></ul><h3 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景" aria-hidden="true">#</a> 适用场景</h3><p>一个流程中多次操作Redis的场景，比如一个线程中要操作100个学生的分数</p><hr>',35),l=[n];function s(p,h){return i(),a("div",null,l)}const c=e(d,[["render",s],["__file","Redis与客户端.html.vue"]]);export{c as default};
