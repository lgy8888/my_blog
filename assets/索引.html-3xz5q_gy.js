import{_ as o}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as p,o as t,c as l,b as s,d as n,e as r,f as a}from"./app-OTaO6_y0.js";const i={},c=a(`<h1 id="索引" tabindex="-1"><a class="header-anchor" href="#索引" aria-hidden="true">#</a> 索引</h1><blockquote><p>只要没有特别指出是其他存储引擎，一切默认指的都是InnoDB</p></blockquote><h2 id="innodb索引基础" tabindex="-1"><a class="header-anchor" href="#innodb索引基础" aria-hidden="true">#</a> InnoDB索引基础</h2><ul><li>索引是提升查询速度的一种数据结构。</li><li>之所以能提升查询速度，在于它在插入时对数据进行了排序</li><li>缺点是影响插入或者更新的性能</li><li>MySQL 8.0 版本中，InnoDB 存储引擎支持的索引有 B+ 树索引、全文索引、R 树索引</li></ul><h3 id="没有索引的查找方式" tabindex="-1"><a class="header-anchor" href="#没有索引的查找方式" aria-hidden="true">#</a> 没有索引的查找方式</h3><blockquote><p>如果没有索引，要怎么查找数据库里面的记录？</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> 列名 <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 列名 <span class="token operator">=</span> XXX<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>在一页中查找</strong></p><blockquote><p>假设目前表中的记录比较少，所有的记录都可以被存放到一个页中</p></blockquote><p>查找记录的时候可以分为两种情况</p><ul><li>以主键为搜索条件 <ul><li>以在页目录中使用二分法快速定位到对应的槽</li><li>然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li></ul></li><li>以其他列作为搜索条件 <ul><li>因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽</li><li>这种情况下只能从最小记录开始依次遍历单链表中的每条记录</li><li>然后对比每条记录是不是符合搜索条件</li></ul></li></ul><p><strong>在很多页中查找</strong></p><blockquote><p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录</p></blockquote><ol><li>定位到记录所在的页</li><li>从所在的页中查找相应的记录</li></ol><p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据上面的查找方式去查找指定的记录。</p><p>因为要遍历所有的数据页，所以这种方式显然是超级耗时的</p><h3 id="简单的索引方案" tabindex="-1"><a class="header-anchor" href="#简单的索引方案" aria-hidden="true">#</a> 简单的索引方案</h3><blockquote><p>示例表</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> index_demo <span class="token punctuation">(</span>
	c1 <span class="token keyword">INT</span><span class="token punctuation">,</span>
    c2 <span class="token keyword">INT</span><span class="token punctuation">,</span>
    c3 <span class="token keyword">CHAR</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> c1
<span class="token punctuation">)</span> ROW_FORMAT<span class="token operator">=</span>Compact<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223203206162.png" alt="image-20231223203206162" tabindex="0" loading="lazy"><figcaption>image-20231223203206162</figcaption></figure><ul><li>record_type ：记录头信息的一项属性，表示记录的类型 <ul><li>0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 表示B+树非叶节点记录</li></ul></li><li>next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量</li><li>各个列的值：这里只记录在index_demo 表中的三个列，分别是c1 、c2 和c3</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223203331737.png" alt="image-20231223203331737" tabindex="0" loading="lazy"><figcaption>image-20231223203331737</figcaption></figure><blockquote><p>为什么根据某个条件查询记录的时候需要遍历所有的数据页？</p></blockquote><p>因为<strong>各个页中的记录并没有规律</strong>，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页</p><blockquote><p>如何快速定位到需要查找的记录所在的数据页？</p></blockquote><p>为快速定位记录所在数据页而建立一个别的目录，这个目录需要完成</p><ul><li><strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</strong></li></ul><blockquote><p>填充示例表</p></blockquote><p>设定一页最大只能存3条记录</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 插入满满一页的数据</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> index_demo <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">&#39;u&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token string">&#39;d&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&#39;y&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223205433090.png" alt="image-20231223205433090" tabindex="0" loading="lazy"><figcaption>image-20231223205433090</figcaption></figure><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 多插入一条</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> index_demo <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>由于页10满了，需要新分配一页来装这条新纪录</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223204859143.png" alt="image-20231223204859143" tabindex="0" loading="lazy"><figcaption>image-20231223204859143</figcaption></figure><ul><li>新分配的数据页编号可能并不是连续的，也就是说我们使用的这些页在存储空间里可能并不挨着。</li><li>它们只是通过维护着上一个页和下一个页的编号而建立了链表关系</li></ul><blockquote><p><strong>第二页中的记录比第一页小，不满足下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值了</strong></p></blockquote><ol><li><p>插入主键值为4 的记录的时候需要伴随着一次记录移动，也就是把主键值为5 的记录移动到页28 中</p></li><li><p>再把主键值为4 的记录插入到页10 中</p></li></ol><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223205143386.png" alt="image-20231223205143386" tabindex="0" loading="lazy"><figcaption>image-20231223205143386</figcaption></figure><ul><li>在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：<strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</strong>。这个过程我们也可以称为**<u>页分裂</u>**。</li></ul><blockquote><p>向表中插入多条记录</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223210021725.png" alt="image-20231223210021725" tabindex="0" loading="lazy"><figcaption>image-20231223210021725</figcaption></figure><blockquote><p><strong>制作目录</strong></p></blockquote><p>因为这些16KB 的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页</p><p>我们需要给它们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分：</p><ul><li><strong>页的用户记录中最小的主键值</strong>，用key来表示</li><li><strong>页号</strong>，我们用<code>page_no</code>表示</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223210226396.png" alt="image-20231223210226396" tabindex="0" loading="lazy"><figcaption>image-20231223210226396</figcaption></figure><ul><li>这个目录有个别名——<strong>索引</strong></li></ul><h3 id="innodb的索引方案" tabindex="-1"><a class="header-anchor" href="#innodb的索引方案" aria-hidden="true">#</a> InnoDB的索引方案</h3><blockquote><p><strong>简单的索引方案存在的问题</strong></p></blockquote><ul><li>InnoDB 是使用页来作为管理存储空间的基本单位，也就是最多能保证16KB 的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</li><li>我们时常会对记录进行增删，假设我们把页28 中的记录都删除了， 页28 也就没有存在的必要了，那意味着目录项2 也就没有存在的必要了，这就需要把目录项2 后的目录项都向前移动一下</li></ul><blockquote><p><strong>解决方案</strong></p></blockquote><p>这些目录项长得跟用户记录差不多，只不过<strong>目录项中的两个列是主键和页号</strong>而已</p><p>所以InnoDB复用了<strong>之前存储用户记录的数据页来存储目录项</strong></p><p>为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录</p><blockquote><p><strong>如何区分一条记录是普通记录还是目录项记录？</strong></p></blockquote><p>利用<code>record_type</code>属性</p><ul><li>0 ：普通的用户记录</li><li>1 ：目录项记录</li><li>2 ：最小记录</li><li>3 ：最大记录</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223211144729.png" alt="image-20231223211144729" tabindex="0" loading="lazy"><figcaption>image-20231223211144729</figcaption></figure><p>目录项记录和普通的用户记录的不同点：</p><ul><li><strong>目录项记录的record_type 值是1</strong>，而普通用户记录的record_type 值是0。</li><li><strong>目录项记录只有主键值和页的编号两个列</strong>，而普通的用户记录的列是用户自己定义的，另外还有InnoDB 自己添加的隐藏列。</li><li>记录头信息的min_rec_mask 的属性：只有<strong>在存储目录项记录的页中的主键值最小的目录项记录的min_rec_mask 值为1</strong> ，其他别的记录的min_rec_mask 值都是0</li></ul><blockquote><p><strong>使用了InnoDB的索引方案之后，查询过程是怎样的？</strong></p></blockquote><p>以查找主键为20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p><ol><li>先到存储目录项记录的页，也就是页30 中通过二分法快速定位到对应目录项，因为12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9 。</li><li>再到存储用户记录的页9中根据二分法快速定位到主键值为20 的用户记录。</li></ol><blockquote><p><strong>如果存储目录项的页满了怎么办？</strong></p></blockquote><p>重新分配一个目录项记录页来存放多出来的目录项</p><p>假设一个存储目录项记录的页最多只能存放4条目录项记录</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> index_demo <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">&#39;m&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223212132227.png" alt="image-20231223212132227" tabindex="0" loading="lazy"><figcaption>image-20231223212132227</figcaption></figure><p>从图中可以看出，插入了一条主键值为320 的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了页31 。</li><li>因为原先存储目录项记录的页30 的容量已满（我们前边假设只能存储4条目录项记录），所以不得不需 要一个新的页32 来存放页31 对应的目录项。</li></ul><blockquote><p><strong>目录项记录页不止一个的情况下，查询过程是怎么样的？</strong></p></blockquote><p>以查找主键值为20 的记录为例：</p><ol><li>确定目录项记录页</li></ol><ul><li>我们现在的存储目录项记录的页有两个，即页30 和页32</li><li>因为页30 表示的目录项的主键值的范围是[1, 320) ， 页32 表示的目录项的主键值不小于320 ，所以主键值为20 的记录对应的目录项记录在页30中</li></ul><ol start="2"><li>通过目录项记录页确定用户记录真实所在的页</li></ol><ul><li>在一个存储目录项记录的页中通过主键值定位一条目录项记录</li></ul><ol start="3"><li>在真实存储用户记录的页中定位到具体的记录。</li></ol><blockquote><p>这种查询方法存在一定问题</p></blockquote><p>第1步需要定位到目录项记录页，但是这些页在存储空间中也可能不挨着，我们表中的数据非常多则会产生很多目录项记录页</p><blockquote><p>解决方案</p></blockquote><p>为这些存储目录项记录的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223212928228.png" alt="image-20231223212928228" tabindex="0" loading="lazy"><figcaption>image-20231223212928228</figcaption></figure><ul><li>生成一个存储更高级目录项的页33 ，这个页中的两条记录分别代表页30 和页32</li><li>如果用户记录的主键值在[1, 320) 之间，则到页30 中查找更详细的目录项记录</li><li>如果主键值不小于320 的话，就到页32中查找更详细的目录项记录</li></ul><p>随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述</p><blockquote><p><strong>B+树</strong></p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223213042574.png" alt="image-20231223213042574" tabindex="0" loading="lazy"><figcaption>image-20231223213042574</figcaption></figure><ul><li>不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到B+ 树这个数据结构中了，</li><li>所以我们也<strong>称这些数据页为节点</strong>。</li><li><strong>实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为叶子节点或叶节点</strong></li><li>其余用来<strong>存放目录项的节点称为非叶子节点或者内节点</strong>，其中<strong>B+ 树最上边的那个节点也称为根节点</strong></li></ul><blockquote><p><strong>B+树究竟能放多少数据</strong></p></blockquote><ul><li>如果B+ 树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100 条记录。</li><li>如果B+ 树有2层，最多能存放1000×100=100000 条记录。</li><li>如果B+ 树有3层，最多能存放1000×1000×100=100000000 条记录。</li><li>如果B+ 树有4层，最多能存放1000×1000×1000×100=100000000000 条记录。</li></ul><p>一般情况下，我们用到的B+ 树都不会超过4层</p><p>那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页）</p><p>又因为在每个页面内有所谓的Page Directory （页目录），所以在页面内也可以通过二分法实现快速定位记录</p><h3 id="innodb索引方案总结" tabindex="-1"><a class="header-anchor" href="#innodb索引方案总结" aria-hidden="true">#</a> InnoDB索引方案总结</h3><p><strong>索引的构建过程</strong></p><ol><li>数据量小于16k时，所有数据存在1页中，此时叶子节点为1 <ul><li>此时该节点为根节点</li></ul></li><li>数据量大于16k时，发生页分裂，为了维持主键顺序存储引发数据在页间迁移，此时数据存在2页中，数据页数大于1页</li><li>叶子节点大于1时，生成一个非叶子节点，存储各页的目录项 <ul><li>目录项记录包含两个字段，一个是指向页面的页号，另一个是该页面中最小的主键</li><li>目录项记录的<code>record_type</code>为1</li></ul></li><li>当数据量越来越多，分出来的叶子节点越来越多，存储目录项的页存满了，发生页分裂，此时目录项存在2页中，目录项页数大于1页</li><li>非叶子节点大于1时，生成更高一层的非叶子节点，存储各目录项页的目录项</li></ol><blockquote><p><strong>根节点的位置是不会动的，如果分裂的是根节点怎么办？</strong></p></blockquote><ul><li>如果待分裂的节点是根节点，InnoDB会将根节点中的数据全量复制一份出来，放在新的页中</li><li>然后对这新的页进行页分裂，存入待插入的溢出记录</li><li>根节点自动升级为存储目录项记录的页</li></ul><p><strong>根据索引查找数据的过程</strong></p><ol><li>从根节点开始，一步步通过非叶子节点各个目录项记录存储的主键值形成的区间定位到数据所在的叶子节点</li><li>进入叶子节点数据页中，通过页目录定位到待查询的用户记录所在处</li></ol><h3 id="myisam的索引方案" tabindex="-1"><a class="header-anchor" href="#myisam的索引方案" aria-hidden="true">#</a> MyISAM的索引方案</h3><p>InnoDB 中索引即数据，也就是聚簇索引的那棵B+ 树的叶子节点中已经把所有完整的用户记录都包含了</p><p>MyISAM 的索引方案虽然也使用树形结构，但是却将索引和数据分开存储</p><blockquote><p><strong>数据是怎么存的？</strong></p></blockquote><p>将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为数据文件。</p><ul><li>这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录</li><li>可以通过行号而快速访问到一条记录。MyISAM 记录也需要记录头信息来存储一些额外数据</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223233101122.png" alt="image-20231223233101122" tabindex="0" loading="lazy"><figcaption>image-20231223233101122</figcaption></figure><ul><li>由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找</li></ul><blockquote><p><strong>索引是怎么存的？</strong></p></blockquote><p>使用MyISAM 存储引擎的表会把索引信息另外存储到一个称为索引文件的另一个文件中。</p><ul><li>MyISAM会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是主键值+行号的组合。</li><li>也就是<strong>先通过索引找到对应的行号，再通过行号去找对应的记录</strong></li><li>在InnoDB 存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM 中却需要进行一次回表操作，意味着<strong>MyISAM 中建立的索引相当于全部都是二级索引</strong></li></ul><blockquote><p>不是说MyISAM的索引查询比InnoDB快吗？</p></blockquote><p>MyISAM的回表速度是很快的，因为<strong>是使用地址偏移量直接到文件中取数据</strong></p><p>InnoDB需要获取主键值，然后再通过聚簇索引来找记录，虽然速度不慢，但<strong>比不上直接使用地址访问快</strong></p><h2 id="三种索引" tabindex="-1"><a class="header-anchor" href="#三种索引" aria-hidden="true">#</a> 三种索引</h2><h3 id="聚簇索引" tabindex="-1"><a class="header-anchor" href="#聚簇索引" aria-hidden="true">#</a> 聚簇索引</h3><p>上边介绍的B+ 树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p><ol><li>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</li></ol><ul><li>页内的记录是按照主键的大小顺序排成一个单向链表。</li><li><strong>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表</strong>。</li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是<strong>根据页中目录项记录的主键大小顺序排成一个双向链表</strong>。</li></ul><ol start="2"><li><strong>B+ 树的叶子节点存储的是完整的用户记录</strong>。</li></ol><ul><li>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</li></ul><p>把具有这两种特性的B+ 树称为聚簇索引，<strong>所有完整的用户记录都存放在这个聚簇索引的叶子节点处</strong>。</p><p>聚簇索引并不需要我们在MySQL 语句中显式的使用INDEX 语句去创建，InnoDB 存储引擎会自动的为我们创建聚簇索引。</p><p>在InnoDB 存储引擎中， <strong>聚簇索引就是数据的存储方式</strong>（所有的用户记录都存储在了叶子节点），也就是所谓的<strong>索引即数据，数据即索引</strong></p><h4 id="聚簇索引的查询过程" tabindex="-1"><a class="header-anchor" href="#聚簇索引的查询过程" aria-hidden="true">#</a> 聚簇索引的查询过程</h4><ol><li>从根节点开始，确定目标记录所在的目录项 <ul><li>例如：查询<code>id=5</code>的记录，根节点中有<code>id=1</code>和<code>id=10</code>的两个目录项，由于$1&lt;5&lt;10$，所以进入<code>id=1</code>目录项的页面</li></ul></li><li>循环第一步，直到找到目标记录所在的叶子节点</li><li>利用页目录定位到页中的行记录</li></ol><h3 id="二级索引" tabindex="-1"><a class="header-anchor" href="#二级索引" aria-hidden="true">#</a> 二级索引</h3><blockquote><p>聚簇索引只有搜索条件是主键值的时候才有用，如果我要搜索的条件是别的列呢？</p></blockquote><p>多建几棵B+树，不同的B+树采用不同的排序规则</p><blockquote><p>用c2 列的大小作为数据页、页中记录的排序规则，再建一棵B+ 树</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223220203395.png" alt="image-20231223220203395" tabindex="0" loading="lazy"><figcaption>image-20231223220203395</figcaption></figure><ul><li><strong>使用记录c2 列的大小进行记录和页的排序</strong>，这包括三个方面的含义： <ul><li>页内的记录是按照c2 列的大小顺序排成一个单向链表。</li><li>各个存放用户记录的页也是根据页中记录的c2 列大小顺序排成一个双向链表。</li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2 列大小顺序排成一个双向链表。</li></ul></li><li><strong>B+ 树的叶子节点存储的并不是完整的用户记录，而只是<u>c2列+主键</u>这两个列的值</strong>。 <ul><li>目录项记录中不再是主键+页号的搭配，而变成了c2列+页号的搭配。</li></ul></li></ul><h4 id="二级索引的查找过程" tabindex="-1"><a class="header-anchor" href="#二级索引的查找过程" aria-hidden="true">#</a> 二级索引的查找过程</h4><p>以查找c2 列的值为4 的记录为例，查找过程如下：</p><ol><li><p>确定目录项记录页</p><ul><li>根据根页面，也就是页44 ，可以快速定位到目录项记录所在的页为页42 （因为2 &lt; 4 &lt; 9 ）。</li></ul></li><li><p>通过目录项记录页确定用户记录真实所在的页。</p><ul><li>在页42 中可以快速定位到实际存储用户记录的页，但是由于<strong>c2 列并没有唯一性约束</strong>，所以<strong>c2 列值为4 的</strong><strong>记录可能分布在多个数据页中</strong>，又因为<strong>2 &lt; 4 ≤ 4</strong> ，所以<strong>确定实际存储用户记录的页在页34 和页35 中</strong>。</li></ul></li><li><p>在真实存储用户记录的页中定位到具体的记录。</p><ul><li>到<strong>页34 和页35 中定位到具体的记录</strong>。</li></ul></li><li><p>但是这个B+ 树的叶子节点中的记录只存储了c2 和c1 （也就是主键）两个列，所以我们必须再根据主键 值去聚簇索引中再查找一遍完整的用户记录。（回表）</p></li></ol><h4 id="回表" tabindex="-1"><a class="header-anchor" href="#回表" aria-hidden="true">#</a> 回表</h4><ul><li>在二级索引中找到对应记录的主键之后，必须再根据主键值去聚簇索引中再查找一遍完整的用户记录</li><li>也就是根据二级索引查询一条完整的用户记录需要使用到2棵B+ 树</li></ul><h3 id="联合索引" tabindex="-1"><a class="header-anchor" href="#联合索引" aria-hidden="true">#</a> 联合索引</h3><p>同时以多个列的大小作为排序规则，也就是同时为多个列建立索引</p><p>比方说我们想让B+ 树按照c2和c3 列的大小进行排序，这个包含两层含义：</p><ul><li><strong>先把各个记录和页按照c2 列进行排序</strong>。</li><li>在记录的<strong>c2 列相同的情况下，采用c3 列进行排序</strong></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223230511843.png" alt="image-20231223230511843" tabindex="0" loading="lazy"><figcaption>image-20231223230511843</figcaption></figure><ul><li>每条<strong>目录项记录都由c2 、c3 、页号这三个部分</strong>组成 <ul><li>各条记录<strong>先按照c2 列的值进行排序</strong></li><li><strong>如果记录的c2 列相同，则按照c3 列的值进行排序</strong>。</li></ul></li><li>B+ 树<strong>叶子节点处的用户记录由c2 、c3 和主键c1 列</strong>组成。</li></ul><h4 id="联合索引查询过程" tabindex="-1"><a class="header-anchor" href="#联合索引查询过程" aria-hidden="true">#</a> 联合索引查询过程</h4><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231227003818271.png" alt="image-20231227003818271" tabindex="0" loading="lazy"><figcaption>image-20231227003818271</figcaption></figure><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> A <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">AND</span> B <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>联合索引的查询过程，以索引（A，B）为例：</p><ul><li>在非叶子节点处，根据 <code>A = 2 AND B = 7</code> 条件，用二分法定位目标记录会在哪个非叶子节点 <ul><li>A相同就看B，B再相同就直接进第一个</li><li>如果刚好找到AB条件都符合的叶子节点最小记录，由于A和B都不是唯一的，就需要去前一页和这一页找</li></ul></li><li>在叶子节点处，使用页目录定位到 <code>A = 2 AND B = 7</code> 的记录，遍历所有符合条件的记录，直到不符合条件为止</li></ul><h4 id="最左匹配原则" tabindex="-1"><a class="header-anchor" href="#最左匹配原则" aria-hidden="true">#</a> 最左匹配原则</h4><ol><li>规则一：MySQL会从联合索引最左边的索引列开始匹配查询条件，然后一次从左到右的顺序匹配，如果查询条件没有使用到哪个列，那么该列右边所有列都无法走索引</li><li>规则二：当查询条件中使用联合索引最左边的索引进行范围查询，范围查询的字段可以用到联合索引，但是再范围查询字段后面的字段“可能”无法用到联合索引，注意，“可能”说明存在某些特殊情况在排序字段后面的查询列也可以使用联合索引的特殊情况</li></ol><blockquote><p><strong>衍生</strong></p></blockquote><ol><li>范围查询会截断索引使用，但是多条件等值查询不会 <ul><li><code>&gt;,&lt;,BETWEEN</code>属于范围查询</li><li><code>IN(val1, val2,···)</code>属于多条件等值查询</li></ul></li><li>字符串模糊匹配也遵守最左匹配原则（类似） <ul><li><code>LIKE</code>语句的使用中，如果是左模糊匹配则可能无法使用索引</li><li>例如：<code>LIKE %林</code> ——&gt; 无法使用；<code>LIKE 林%</code> ——&gt; 可以使用</li><li>覆盖索引例外</li></ul></li></ol><h2 id="b-树索引的好处" tabindex="-1"><a class="header-anchor" href="#b-树索引的好处" aria-hidden="true">#</a> B+树索引的好处</h2><blockquote><p>一步步解析为什么B+树好</p></blockquote><h3 id="优秀的索引数据结构" tabindex="-1"><a class="header-anchor" href="#优秀的索引数据结构" aria-hidden="true">#</a> 优秀的索引数据结构</h3><p>MySQL 的数据是持久化的，意味着数据（索引+记录）是保存到磁盘上的，因为这样即使设备断电了，数据也不会丢失</p><h4 id="缓慢的磁盘i-o" tabindex="-1"><a class="header-anchor" href="#缓慢的磁盘i-o" aria-hidden="true">#</a> 缓慢的磁盘I/O</h4><blockquote><p>磁盘是一个慢的离谱的存储设备，有多慢呢？</p></blockquote><p>内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的，也就是说读取同样大小的数据，磁盘中读取的速度比从内存中读取的速度要慢上万倍，甚至几十万倍。</p><p>磁盘读写的最小单位是<strong>扇区</strong>，扇区的大小只有 <code>512B</code> 大小，操作系统一次会读写多个扇区，所以<strong>操作系统的最小读写单位是块（Block）。Linux 中的块大小为 <code>4KB</code></strong>，也就是一次磁盘 I/O 操作会直接读写 8 个扇区。</p><ul><li>Linux的分页内存管理中，内存页也是4kb，这是为了跟磁盘的最小读写单位对齐</li></ul><p>由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I/O，而磁盘 I/O 次数越多，所消耗的时间也就越大。</p><h4 id="优秀索引结构特征" tabindex="-1"><a class="header-anchor" href="#优秀索引结构特征" aria-hidden="true">#</a> 优秀索引结构特征</h4><p>一个适合 MySQL 索引的数据结构，至少满足以下要求：</p><ol><li>能<strong>在尽可能少的磁盘的 I/O 操作中完成查询工作</strong>；</li><li>要能<strong>高效地查询某一个记录</strong>，也要能<strong>高效地执行范围查找</strong>；</li></ol><h3 id="查询方法" tabindex="-1"><a class="header-anchor" href="#查询方法" aria-hidden="true">#</a> 查询方法</h3><h4 id="二分查找法" tabindex="-1"><a class="header-anchor" href="#二分查找法" aria-hidden="true">#</a> 二分查找法</h4><p>索引数据最好能按顺序排列，这样可以使用「二分查找法」高效定位数据。</p><p>假设现在用数组来存储索引</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231225130659415.png" alt="image-20231225130659415" tabindex="0" loading="lazy"><figcaption>image-20231225130659415</figcaption></figure><p>二分查找法每次都把查询的范围减半，可以将时间复杂度降到 $O(logn)$</p><blockquote><p><strong>数组存储索引存在的问题</strong></p></blockquote><ul><li>数组结构插入新元素的时候性能太低 <ul><li>插入一个元素，需要将这个元素之后的所有元素后移一位</li></ul></li><li>有序的数组在使用二分查找的时候，每次查找都要不断计算中间的位置</li></ul><h3 id="存储结构" tabindex="-1"><a class="header-anchor" href="#存储结构" aria-hidden="true">#</a> 存储结构</h3><h4 id="二叉查找树" tabindex="-1"><a class="header-anchor" href="#二叉查找树" aria-hidden="true">#</a> 二叉查找树</h4><h5 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构" aria-hidden="true">#</a> 数据结构</h5><blockquote><p>有没有一种<strong>非线形且天然适合二分查找的数据结构</strong></p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/49cb4df3fb7d4accbc75f6970ff1d0ea.gif" alt="二叉查找树" tabindex="0" loading="lazy"><figcaption>二叉查找树</figcaption></figure><ul><li>找到所有二分查找中用到的所有中间节点，把他们用指针连起来，并将最中间的节点作为根节点</li><li>特点：一个节点的<strong>左子树的所有节点都小于这个节点</strong>，<strong>右子树的所有节点都大于这个节点</strong></li></ul><blockquote><p><strong>如何查询到某个节点？</strong></p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/f3089bdfe1a795a8142d4442bdb1e9a7.gif" alt="二叉查找树查询某节点" tabindex="0" loading="lazy"><figcaption>二叉查找树查询某节点</figcaption></figure><p>查找索引值为 key 的节点：</p><ol><li>如果 key 大于根节点，则在右子树中进行查找；</li><li>如果 key 小于根节点，则在左子树中进行查找；</li><li>如果 key 等于根节点，也就是找到了这个节点，返回根节点即可。</li></ol><blockquote><p><strong>如何插入新节点？</strong></p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/be13777664584209826f90d5d4128b7f.gif" alt="二叉查找树插入新节点" tabindex="0" loading="lazy"><figcaption>二叉查找树插入新节点</figcaption></figure><p>因为二叉查找树是一个跳跃结构，不必连续排列。这样在插入的时候，新节点可以放在任何位置，不会像线性结构那样插入一个元素，所有元素都需要向后排列。</p><h5 id="二叉查找树的问题" tabindex="-1"><a class="header-anchor" href="#二叉查找树的问题" aria-hidden="true">#</a> 二叉查找树的问题</h5><p>二叉查找树存在一个极端情况，当<strong>每次插入的元素都是二叉查找树中最大的元素</strong>，二叉查找树就会<strong>退化成了一条链表</strong>，<strong>查找数据的时间复杂度变成了 O(n)</strong></p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/320c5c2653e74f9e9ebfcd8ca9681905.gif" alt="二叉查找树的问题" tabindex="0" loading="lazy"><figcaption>二叉查找树的问题</figcaption></figure><p>由于树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作（假设一个节点的大小「小于」操作系统的最小读写单位块的大小）</p><p>也就是说<strong>树的高度就等于每次查询数据时磁盘 IO 操作的次数</strong>，所以树的高度越高，就会影响查询性能。</p><p>二叉查找树会随着插入的元素越多，树的高度也变高，意味着需要磁盘 IO 操作的次数就越多，这样导致查询性能严重下降，再加上不能范围查询，所以不适合作为数据库的索引结构。</p><h4 id="自平衡的二叉树" tabindex="-1"><a class="header-anchor" href="#自平衡的二叉树" aria-hidden="true">#</a> 自平衡的二叉树</h4><h5 id="平衡二叉查找树" tabindex="-1"><a class="header-anchor" href="#平衡二叉查找树" aria-hidden="true">#</a> 平衡二叉查找树</h5><p>**平衡二叉查找树（AVL树）**在二叉查找树的基础上增加了一些条件约束：<strong>每个节点的左子树和右子树的高度差不能超过 1</strong></p><p>也就是说节点的左子树和右子树仍然为平衡二叉树，这样查询操作的时间复杂度就会一直维持在 O(logn)</p><blockquote><p>平衡二叉查找树如何维持自平衡</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/8d5da86f2e41a0b641dbf45b23f7b7dd.gif" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h5 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树" aria-hidden="true">#</a> 红黑树</h5><p>红黑树插入节点的过程，左旋右旋的操作，就是为了自平衡</p><blockquote><p>平衡二叉查找树如何维持自平衡</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/b2628d1248e41207a08871f7bfac3522.gif" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h5 id="自平衡的二叉树的问题" tabindex="-1"><a class="header-anchor" href="#自平衡的二叉树的问题" aria-hidden="true">#</a> 自平衡的二叉树的问题</h5><p>不管平衡二叉查找树还是红黑树，都会随着插入的元素增多，而导致<strong>树的高度变高，这就意味着磁盘 I/O 操作次数多</strong>，会影响整体数据查询的效率</p><p>根本原因是因为它们都是二叉树，每个节点只能保存两个子节点，改成M叉树就能解决这个问题</p><p><strong>当树的节点越多的时候，并且树的分叉数 M 越大的时候，M 叉树的高度会远小于二叉树的高度</strong></p><h4 id="b树" tabindex="-1"><a class="header-anchor" href="#b树" aria-hidden="true">#</a> B树</h4><h5 id="b树的特点" tabindex="-1"><a class="header-anchor" href="#b树的特点" aria-hidden="true">#</a> B树的特点</h5><p>B 树不再限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M&gt;2)，从而降低树的高度。</p><p>B 树的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶，所以 B 树就是一个多叉树。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/9a96956de3be0614f7ec2344741b4dcc.gif" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>假设 M = 3，那么就是一棵 3 阶的 B 树，特点就是<strong>每个节点最多有 2 个（M-1个）数据和最多有 3 个（M个）子节点</strong>，超过这些要求的话，就会分裂节点</p><h5 id="b树的查询过程" tabindex="-1"><a class="header-anchor" href="#b树的查询过程" aria-hidden="true">#</a> B树的查询过程</h5><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/341cedca6863fcd0624febd835165ae2.gif" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>在上图一棵 3 阶的 B 树中要查找的索引值是 9 的记录那么步骤可以分为以下几步：</p><ol><li>与根节点的索引(4，8）进行比较，9 大于 8，那么往右边的子节点走；</li><li>然后该子节点的索引为（10，12），因为 9 小于 10，所以会往该节点的左边子节点走；</li><li>走到索引为9的节点，然后我们找到了索引值 9 的节点。</li></ol><p>一棵 3 阶的 B 树在查询叶子节点中的数据时，由于树的高度是 3 ，所以在查询过程中会发生 3 次磁盘 I/O 操作</p><p>如果同样的节点数量在平衡二叉树的场景下，树的高度就会很高，意味着磁盘 I/O 操作会更多。所以，B 树在数据查询中比平衡二叉树效率要高。</p><h5 id="b树存在的问题" tabindex="-1"><a class="header-anchor" href="#b树存在的问题" aria-hidden="true">#</a> B树存在的问题</h5><p><strong>记录跟索引存在一起</strong></p><p>B 树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I/O 操作次数来读到「有用的索引数据」</p><p><strong>查询时会访问到许多多余的数据</strong></p><p>查询位于底层的某个节点（比如 A 记录）过程中，「非 A 记录节点」里的记录数据会从磁盘加载到内存，但是这些记录数据是没用的，我们只是想读取这些节点的索引数据来做比较查询，而「非 A 记录节点」里的记录数据对我们是没用的，这样不仅增多磁盘 I/O 操作次数，也占用内存资源</p><p><strong>低效的范围查询</strong></p><p>使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I/O 问题，从而导致整体速度下降。</p><h4 id="b-树" tabindex="-1"><a class="header-anchor" href="#b-树" aria-hidden="true">#</a> B+树</h4><p>B+ 树就是对 B 树做了一个升级，MySQL 中索引的数据结构就是采用了 B+ 树</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/b6678c667053a356f46fc5691d2f5878.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h5 id="b-树和b树的差异" tabindex="-1"><a class="header-anchor" href="#b-树和b树的差异" aria-hidden="true">#</a> B+树和B树的差异</h5><ul><li>叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引；</li><li>所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表；</li><li>非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）。</li><li>非叶子节点中有多少个子节点，就有多少个索引</li></ul><h5 id="b-树插入数据" tabindex="-1"><a class="header-anchor" href="#b-树插入数据" aria-hidden="true">#</a> B+树插入数据</h5><p>加入一条数据，根据数据页会不会满，分为三种情况。</p><ol><li>叶子结点和索引结点都没满。这种情况最简单，直接插入到叶子结点中就好了。</li></ol><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/a3df58873a45d8c2cd5433a9639662531055a0.png" alt="Mysql的索引为什么使用B+树而不使用跳表？-鸿蒙开发者社区" tabindex="0" loading="lazy"><figcaption>Mysql的索引为什么使用B+树而不使用跳表？-鸿蒙开发者社区</figcaption></figure><ol start="2"><li>叶子结点满了，但索引结点没满。此时需要拆分叶子结点，同时索引结点要增加新的索引信息。</li></ol><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/e17aa2b928eb90736691059422a66330428278.png" alt="Mysql的索引为什么使用B+树而不使用跳表？-鸿蒙开发者社区" tabindex="0" loading="lazy"><figcaption>Mysql的索引为什么使用B+树而不使用跳表？-鸿蒙开发者社区</figcaption></figure><ol start="3"><li>叶子结点满了，且索引结点也满了。叶子和索引结点都要拆分，同时往上还要再加一层索引。</li></ol><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/32ac5e3692cbe45257d029d0d62efa133adf5f.png" alt="Mysql的索引为什么使用B+树而不使用跳表？-鸿蒙开发者社区" tabindex="0" loading="lazy"><figcaption>Mysql的索引为什么使用B+树而不使用跳表？-鸿蒙开发者社区</figcaption></figure><h3 id="b-树vsb树" tabindex="-1"><a class="header-anchor" href="#b-树vsb树" aria-hidden="true">#</a> B+树vsB树</h3><h4 id="单点查询" tabindex="-1"><a class="header-anchor" href="#单点查询" aria-hidden="true">#</a> 单点查询</h4><p>B 树进行单个索引查询时，最快可以在 O(1) 的时间代价内就查到，从平均时间代价来看，会比 B+ 树稍快一些</p><p>B 树的查询波动会比较大，因为每个节点即存索引又存记录，所以有时候访问到了非叶子节点就可以找到索引，而有时需要访问到叶子节点才能找到索引</p><p>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此<strong>数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引</strong></p><p>因此 B+ 树可以比 B 树更「矮胖」，<strong>查询底层节点的磁盘 I/O次数会更少</strong></p><h4 id="更新效率" tabindex="-1"><a class="header-anchor" href="#更新效率" aria-hidden="true">#</a> 更新效率</h4><blockquote><p><strong>B+树</strong></p></blockquote><p>因为B+树存在的冗余节点，所以B+树删除一个节点的时候，树形状的变化很小。</p><ul><li>冗余节点指B+树的叶子节点即是全部的索引，其中非叶子节点也会存索引，对于节点中最小的索引，其父节点也会保存一份用以定位该节点，因此这个最小的索引就有两份</li><li>而B树没有冗余节点，所有节点存储的索引就是一份完整的索引，并不存在冗余的索引值</li></ul><p><strong>B+树删除叶子节点</strong></p><ul><li>如果被删除的节点的索引值被存储在他的父节点中，同时被删除节点还有兄弟节点，那么他左右相邻的兄弟节点就会有一个的索引值覆盖掉被删除的叶子节点的索引值</li><li>如果被删除的节点的索引值没有被存储在他的父节点中，删除就只需要将其从链表中移除，不需要作其他工作</li><li>如果该节点没有其他的兄弟节点，其父节点才会也被删除，只有在特殊的情况下，树形状才会发生大的变化</li></ul><p>删除B+树的0004节点，因为0004有冗余节点，所以删除的时候树的结构变化很小</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/25508b0cd9c44ef6937fdd737020a7f1.gif" alt="请添加图片描述" tabindex="0" loading="lazy"><figcaption>请添加图片描述</figcaption></figure><p>甚至B+树在删除<strong>根节点</strong>的时候，由于存在冗余，所以不会发生复杂的树的形变</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/23730b5af987480fabff0f1d142a2b6c.gif" alt="B+树删除根节点" tabindex="0" loading="lazy"><figcaption>B+树删除根节点</figcaption></figure><blockquote><p><strong>B树</strong></p></blockquote><p>B树没有冗余节点，删除节点的时候，其父节点会受到更大的影响，因此会导致复杂的树的形变</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/2be62679487640bbaac663fa96c7f35f.gif" alt="请添加图片描述" tabindex="0" loading="lazy"><figcaption>请添加图片描述</figcaption></figure><p>插入操作同理，B+树只需要在叶子节点中添加一个节点，因为B+树存在冗余节点，如果节点存在饱和，插入可能存在节点的分裂，但是最多只涉及一个节点多了一个孩子，或者层数增加。</p><p>B树没有冗余节点，<strong>插入的时候为了维护树的有序性，以及树的平衡，就需要一些复杂的操作</strong>。</p><h4 id="范围查询" tabindex="-1"><a class="header-anchor" href="#范围查询" aria-hidden="true">#</a> 范围查询</h4><p>B 树和 B+ 树等值查询原理基本一致，先从根节点查找，然后对比目标数据的范围，最后递归的进入子节点查找。</p><blockquote><p><strong>B+树</strong></p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231225141737176.png" alt="image-20231225141737176" tabindex="0" loading="lazy"><figcaption>image-20231225141737176</figcaption></figure><ol><li>找范围左边界的叶子节点</li><li>沿着叶子节点的next_record遍历叶子节点</li><li>直到遇到范围右边界停止</li></ol><blockquote><p><strong>B树</strong></p></blockquote><p>B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。</p><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h4><blockquote><p>B+ 树用于数据库索引有3大优势。</p></blockquote><ol><li>B+ 树的高度和二叉树之类的比起来更低，树的高度代表了查询的耗时，所以<strong>查询性能更好</strong>。</li><li>B+ 树的叶子节点都被串联起来了，<strong>适合范围查询</strong>。</li><li>B+ 树的非叶子节点没有存放数据，所以<strong>适合放入内存中</strong>。</li></ol><blockquote><p>应用场景</p></blockquote><ul><li>存在大量范围检索的场景，适合使用 B+树，比如数据库</li><li>对于大量的单个索引查询的场景，可以考虑 B 树，比如 nosql 的 MongoDB</li></ul><h3 id="b-树vs跳表" tabindex="-1"><a class="header-anchor" href="#b-树vs跳表" aria-hidden="true">#</a> B+树vs跳表</h3><blockquote><p><strong>MySQL为什么使用B+树不使用跳表</strong></p></blockquote><ul><li>B+树矮胖的结构减少了I/O的次数，更加适合在磁盘中进行I/O</li><li>跳表的查询性能不稳定，且层数高，不适合磁盘I/O</li></ul><blockquote><p><strong>Redis为什么使用跳表不使用B+树</strong></p></blockquote><ul><li>B+树的结构特点在内存I/O中对性能的优化很不明显，内存I/O速度很快，不在乎几次或者几十次</li><li>跳表的实现简单，增删改都比B+树简单，也不用维护树的结构，减少了很多时空的开销</li><li>跳表空间占用灵活，可以通过调节层高生成的概率来控制空间占用的大小</li></ul><h4 id="查询性能" tabindex="-1"><a class="header-anchor" href="#查询性能" aria-hidden="true">#</a> 查询性能</h4><p><strong>B+树</strong>：适合磁盘存储，因为其内部节点只存储键值，可以降低IO次数，提高查询性能。适用于数据库索引等需要频繁范围查询的场景。</p><p>**跳表：**极端情况下会退化成链表，查询性能不稳定。相对于B+树，在磁盘上的查询性能较差。</p><h4 id="插入和删除操作" tabindex="-1"><a class="header-anchor" href="#插入和删除操作" aria-hidden="true">#</a> 插入和删除操作</h4><p>**B+树：**需要在内部节点进行拆分和合并，可能导致频繁的结构调整，对于插入和删除操作可能存在性能开销。</p><p><strong>跳表：</strong> 插入和删除相对简单，只需要调整相邻节点的指针，性能相对较好。</p><h4 id="空间占用" tabindex="-1"><a class="header-anchor" href="#空间占用" aria-hidden="true">#</a> 空间占用</h4><p>**B+树：**B+树最大的优点就在于树矮，磁盘I/O的次数少</p><p>**跳表：**需要额外的指针空间，但相对于B+树，可能在某些情况下占用较少的内存。</p><ul><li>决定跳表空间占用大小的是概率增加层高，这个概率是可以配置的，所以跳表的空间占用可以调整的</li></ul><h4 id="实现难度" tabindex="-1"><a class="header-anchor" href="#实现难度" aria-hidden="true">#</a> 实现难度</h4><p><strong>B+树：</strong> 实现相对复杂，需要处理树的拆分和合并等复杂操作。</p><p><strong>跳表：</strong> 相对简单，容易实现和理解。</p><h2 id="b-树索引的注意事项" tabindex="-1"><a class="header-anchor" href="#b-树索引的注意事项" aria-hidden="true">#</a> B+树索引的注意事项</h2><h3 id="不会移动的根节点" tabindex="-1"><a class="header-anchor" href="#不会移动的根节点" aria-hidden="true">#</a> 不会移动的根节点</h3><blockquote><p><strong>B+树的形成过程</strong></p></blockquote><ul><li>每当为某个表创建一个B+ 树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个根节点页面。 <ul><li>最开始表中没有数据的时候，每个B+ 树索引对应的根节点中既没有用户记录，也没有目录项记录。</li></ul></li><li>随后向表中插入用户记录时，先把用户记录存储到这个根节点中。</li><li>当根节点中的可用空间用完时继续插入记录，此时会<strong>将根节点中的所有记录复制到一个新分配的页</strong>，比如页a 中</li><li>然后<strong>对这个新页进行页分裂的操作，得到另一个新页</strong>，比如页b 。 <ul><li>这时新插入的溢出记录根据键值（聚簇索引中的主键值/二级索引中对应的索引列的值）的大小就会被分配到页a或者页b中</li></ul></li><li>而<strong>根节点便升级为存储目录项记录的页</strong>。</li></ul><blockquote><p><strong>根节点的位置为什么不能改变？</strong></p></blockquote><p><strong><u>一个B+树索引的根节点自诞生之日起，便不会再移动</u></strong></p><p>这样只要我们<strong>对某个表建立一个索引</strong>，那么<strong>它的根节点的页号便会被记录到某个地方</strong></p><p>然后凡是InnoDB 存储引擎需<strong>要用到这个索引</strong>的时候，都会<strong>从那个固定的地方取出根节点的页号，从而来访问这个索引</strong></p><p>这个存储某个索引的根节点在哪个页面中的信息就是<strong>数据字典中的一项信息</strong></p><h3 id="内节点中目录项记录的唯一性" tabindex="-1"><a class="header-anchor" href="#内节点中目录项记录的唯一性" aria-hidden="true">#</a> 内节点中目录项记录的唯一性</h3><p>B+ 树索引的内节点中目录项记录的内容是<strong>索引列 + 页号</strong>的搭配，但是这个搭配对于二级索引来说有点儿不严谨</p><blockquote><p><strong>有什么问题？</strong></p></blockquote><p>索引列是可以重复的，这就导致插入重复索引列值的时候无法精确定位到自己应该属于哪个数据页</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223232414297.png" alt="image-20231223232414297" tabindex="0" loading="lazy"><figcaption>image-20231223232414297</figcaption></figure><blockquote><p><strong>怎么解决？</strong></p></blockquote><p>为了让新插入记录能找到自己在那个页里，我们需要保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的</p><p>对于<strong>二级索引的内节点的目录项记录的内容</strong>实际上是由三个部分构成的：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231223232547053.png" alt="image-20231223232547053" tabindex="0" loading="lazy"><figcaption>image-20231223232547053</figcaption></figure><h3 id="一个页面最少存储两条数据" tabindex="-1"><a class="header-anchor" href="#一个页面最少存储两条数据" aria-hidden="true">#</a> 一个页面最少存储两条数据</h3><p>如果一个目录只放一条记录，那么目录的层级会很多，而且最后存放真实数据的页中只能放一条用户记录，这样查询起来是非常低效的</p><h3 id="b-树索引结论" tabindex="-1"><a class="header-anchor" href="#b-树索引结论" aria-hidden="true">#</a> B+树索引结论</h3><ul><li><strong>每个索引都对应一棵B+ 树</strong><ul><li>B+ 树分为好多层，最下边一层是叶子节点，其余的是内节点</li><li>所有用户记录都存储在B+ 树的叶子节点，所有目录项记录都存储在内节点。</li></ul></li><li>InnoDB 存储引擎会<strong>自动为主键</strong>（如果没有它会自动帮我们添加）<strong>建立聚簇索引</strong><ul><li><strong>聚簇索引的叶子节点包含完整的用户记录</strong>。</li></ul></li><li>我们可以为自己感兴趣的列建立二级索引 <ul><li><strong>二级索引的叶子节点</strong>包含的用户记录<strong>由索引列 + 主键组成</strong></li><li>如果想通过二级索引来查找完整的用户记录的话，需要通过<strong>回表</strong>操作，也就是在<strong>通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录</strong>。</li></ul></li><li><strong>B+ 树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表</strong><ul><li>File Header（文件头部）中的FIL_PAGE_PREV（上一页页号）和FIL_PAGE_NEXT（下一页页号），</li></ul></li><li><strong>每个页内的记录</strong>（不论是用户记录还是目录项记录）都是<strong>按照索引列的值从小到大的顺序而形成了一个单链表</strong>。 <ul><li>记录头信息中的next_record（下一个记录真实记录的位置偏移，也就是走几位能够到这）</li></ul></li><li>如果是<strong>联合索引</strong><ul><li>则<strong>页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序</strong>。</li></ul></li><li>通过索引查找记录是<strong>从B+ 树的根节点开始，使用二分法一层一层向下搜索</strong>。 <ul><li>由于<strong>每个页面都按照索引列的值建立了Page Directory</strong> （页目录），所以在这些<strong>页面中的查找非常快</strong>。</li></ul></li></ul><h2 id="b-树索引的代价" tabindex="-1"><a class="header-anchor" href="#b-树索引的代价" aria-hidden="true">#</a> B+树索引的代价</h2><blockquote><p>一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差</p></blockquote><h3 id="空间上的代价" tabindex="-1"><a class="header-anchor" href="#空间上的代价" aria-hidden="true">#</a> 空间上的代价</h3><ul><li><strong>每建立一个索引都要为它建立一棵B+ 树</strong></li><li>每一棵B+ 树的每一个节点都是一个数据页</li><li><strong>一个页默认会占用16KB</strong> 的存储空间</li><li>一棵很大的<strong>B+ 树由许多数据页组成</strong></li></ul><h3 id="时间上的代价" tabindex="-1"><a class="header-anchor" href="#时间上的代价" aria-hidden="true">#</a> 时间上的代价</h3><ul><li>每次对表中的数据进行增、删、改操作时，都需要去修改各个B+ 树索引。</li><li>B+ 树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。</li><li>不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。</li><li>而增、删、改操作可能会对节点和记录的排序造成破坏，所以<strong>存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收等操作来维护好节点和记录的排序</strong>。</li></ul><h3 id="优化b-树的插入性能" tabindex="-1"><a class="header-anchor" href="#优化b-树的插入性能" aria-hidden="true">#</a> 优化B+树的插入性能</h3><p>排序的开销其实是不大的，排序是由CPU操作的，一个时钟周期CPU可以处理上亿条指令</p><p><strong>真正的开销在于 B+ 树索引的维护，保证数据排序</strong></p><ul><li><strong>数据顺序（或逆序）插入：</strong> B+ 树索引的维护代价非常小，叶子节点都是从左往右进行插入 <ul><li>比较典型的是自增 ID 的插入、时间的插入</li><li>若在自增 ID 上创建索引，时间列上创建索引，则 B+ 树插入通常是比较快的</li></ul></li><li><strong>数据无序插入：</strong> B+ 树为了维护排序，需要对页进行分裂、旋转等开销较大的操作 <ul><li>即便对于固态硬盘，随机写的性能也不如顺序写，所以磁盘性能也会收到较大影响</li><li>比较典型的是用户昵称，每个用户注册时，昵称是随意取的，若在昵称上创建索引，插入是无序的，索引维护需要的开销会比较大。</li></ul></li></ul><p>前面数据库设计中讲到的主键ID设计也提到了顺序主键的好处，在表结构设计时，主键的设计一定要尽可能地使用顺序值，这样才能保证在海量并发业务场景下的性能。</p><h2 id="b-树索引使用的条件" tabindex="-1"><a class="header-anchor" href="#b-树索引使用的条件" aria-hidden="true">#</a> B+树索引使用的条件</h2><h3 id="利用索引优化查询" tabindex="-1"><a class="header-anchor" href="#利用索引优化查询" aria-hidden="true">#</a> 利用索引优化查询</h3><blockquote><p>示例表</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> person_info<span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span>
    name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    birthday <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    phone_number <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    country <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">KEY</span> idx_name_birthday_phone_number <span class="token punctuation">(</span>name<span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> phone_number<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>表中的主键是id 列，它存储一个自动递增的整数。所以InnoDB 存储引擎会自动为id 列建立聚簇索引。</li><li>额外定义了一个二级索引<code>idx_name_birthday_phone_number</code> ，它是由3个列组成的联合索引 <ul><li>在这个索引对应的B+ 树的叶子节点处存储的用户记录只保留name 、birthday 、phone_number 这三个列的值以及主键id 的值，并不会保存country 列的值。</li></ul></li></ul><blockquote><p>联合索引 <code>idx_name_birthday_phone_number</code> 示意图</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231224110130432.png" alt="image-20231224110130432" tabindex="0" loading="lazy"><figcaption>image-20231224110130432</figcaption></figure><ul><li>先按照name 列的值进行排序。</li><li>如果name 列的值相同，则按照birthday 列的值进行排序。</li><li>如果birthday 列的值也相同，则按照phone_number 的值进行排序。</li></ul><h4 id="全值匹配" tabindex="-1"><a class="header-anchor" href="#全值匹配" aria-hidden="true">#</a> 全值匹配</h4><p>如果我们的<strong>搜索条件中的列和索引列一致的话，这种情况就称为全值匹配</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> person_info 
<span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;Ashburn&#39;</span> <span class="token operator">AND</span> birthday <span class="token operator">=</span> <span class="token string">&#39;1990-09-27&#39;</span> <span class="token operator">AND</span> phone_number <span class="token operator">=</span> <span class="token string">&#39;15123983239&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>因为B+ 树的数据页和记录先是按照name 列的值进行排序的，所以先可以很快定位name 列的值是Ashburn的记录位置。</li><li>在name 列相同的记录里又是按照birthday 列的值进行排序的，所以在name 列的值是Ashburn 的记录里又可以快速定位birthday 列的值是&#39;1990-09-27&#39; 的记录。</li><li>在name 和birthday 列的值都是相同的记录里又是按照phone_number 列的值排序的，所以联合索引中的三个列都可能被用到。</li></ul><blockquote><p>WHERE子句中查询条件的顺序有没有影响，会不会我换一下顺序就用不了联合索引了</p></blockquote><p>MySQL 有一个查询优化器，会分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件，后使用哪个搜索条件</p><h4 id="匹配左边的列" tabindex="-1"><a class="header-anchor" href="#匹配左边的列" aria-hidden="true">#</a> 匹配左边的列</h4><blockquote><p>一定要将联合索引三个索引列全都查了才能用上这个联合索引吗？</p></blockquote><p>搜索语句中可以不用包含全部联合索引的列，包含最左边就可以</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> person_info 
<span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;Ashburn&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> person_info 
<span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;Ashburn&#39;</span> <span class="token operator">AND</span> birthday <span class="token operator">=</span> <span class="token string">&#39;1990-09-27&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>搜索语句中只要包含最左边列就能够用上联合索引</strong></p><blockquote><p>如果不包含最左边的列呢？</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> person_info 
<span class="token keyword">WHERE</span> birthday <span class="token operator">=</span> <span class="token string">&#39;1990-09-27&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> person_info 
<span class="token keyword">WHERE</span> phone_number <span class="token operator">=</span> <span class="token string">&#39;15123983239&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> person_info 
<span class="token keyword">WHERE</span> birthday <span class="token operator">=</span> <span class="token string">&#39;1990-09-27&#39;</span> <span class="token operator">AND</span> phone_number <span class="token operator">=</span> <span class="token string">&#39;15123983239&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>搜索语句中只要不包含最左边列就用不了联合索引</p><blockquote><p><strong>为什么只有包含了最左边列才能用上联合索引呢？</strong></p></blockquote><p>因为B+ 树的数据页和记录先是按照name 列的值排序的</p><p>在name 列的值相同的情况下才使用birthday 列进行排序，也就是说name 列的值不同的记录中birthday 的值可能是无序的。</p><p>而现在你跳过name 列直接根据birthday 的值去查找，这个索引无法做到这一点</p><p>如果就想在只使用birthday 的值去通过B+ 树索引进行查找，只能重新建一个由birthday开头的索引</p><blockquote><p><strong>如何使用联合索引中尽可能多的列</strong></p></blockquote><p>如果想使用联合索引中尽可能多的列，<strong>搜索条件中的各个列必须是联合索引中从最左边连续的列</strong></p><p>比方说联合索引idx_name_birthday_phone_number 中列的定义顺序是name 、 birthday 、phone_number</p><p>如果我们的搜索条件中只有name 和phone_number ，而没有中间的birthday</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> person_info 
<span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;Ashburn&#39;</span> <span class="token operator">AND</span> phone_number <span class="token operator">=</span> <span class="token string">&#39;15123983239&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样只能用到name 列的索引， birthday 和phone_number 的索引就用不上了</p><p>因为name 值相同的记录先按照birthday 的值进行排序， birthday 值相同的记录才按照phone_number 值进行排序。</p><h4 id="匹配列前缀" tabindex="-1"><a class="header-anchor" href="#匹配列前缀" aria-hidden="true">#</a> 匹配列前缀</h4><blockquote><p><strong>如果针对索引列的条件是字符串模糊查询呢？</strong></p></blockquote><p>字符串排序的本质就是比较哪个字符串大一点儿，哪个字符串小一点，比较字符串大小就用到了该列的字符集和比较规则</p><p>一般的比较规则都是<strong>逐个比较字符的大小</strong>，也就是说我们比较两个字符串的大小的过程其实是这样的：</p><ul><li>先比较字符串的第一个字符，第一个字符小的那个字符串就比较小。</li><li>如果两个字符串的第一个字符相同，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小。</li><li>如果两个字符串的第二个字符也相同，那就接着比较第三个字符，依此类推。</li></ul><p>所以一个排好序的字符串列其实有这样的特点：</p><ul><li>先按照字符串的第一个字符进行排序。</li><li>如果第一个字符相同再按照第二个字符进行排序。</li><li>如果第二个字符相同再按照第三个字符进行排序，依此类推。</li></ul><p>对于字符串来说，只匹配前缀是可以快速定位记录的</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> name <span class="token operator">LIKE</span> <span class="token string">&#39;As%&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是如果匹配的是后缀或者中间的子串就没办法用索引快速定位了</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> name <span class="token operator">LIKE</span> <span class="token string">&#39;%As%&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>实例</p></blockquote><p>某个表存储了一个URL列</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>+----------------+
<span class="token operator">|</span> url 			 <span class="token operator">|</span>
+----------------+
<span class="token operator">|</span> www.baidu.com  <span class="token operator">|</span>
<span class="token operator">|</span> www.google.com <span class="token operator">|</span>
<span class="token operator">|</span> www.gov.cn     <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token punctuation">..</span>. 			 <span class="token operator">|</span>
<span class="token operator">|</span> www.wto.org    <span class="token operator">|</span>
+----------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设已经对该url 列创建了索引</p><p>如果我们想查询以com 为后缀的网址的话可以这样写查询条件</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">WHERE</span> url <span class="token operator">LIKE</span> <span class="token string">&#39;%com&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是这样的话无法使用该url 列的索引</p><p>为了在查询时用到这个索引而不至于全表扫描，我们可以把后缀查询改写成前缀查询</p><p>不过我们就得把表中的数据全部逆序存储一下，也就是说我们可以这样保存url列中的数据</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>+----------------+
<span class="token operator">|</span> url 			 <span class="token operator">|</span>
+----------------+
<span class="token operator">|</span> moc.udiab.www  <span class="token operator">|</span>
<span class="token operator">|</span> moc.elgoog.www <span class="token operator">|</span>
<span class="token operator">|</span> nc.vog.www	 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token punctuation">..</span>.			 <span class="token operator">|</span>
<span class="token operator">|</span> gro.otw.www 	 <span class="token operator">|</span>
+----------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样再查找以com 为后缀的网址时搜索条件便可以这么写，这样就可以用到索引了</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">WHERE</span> url <span class="token operator">LIKE</span> <span class="token string">&#39;moc%&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>匹配范围值</p><blockquote><p><strong>如果针对索引列的条件是范围查询呢？</strong></p></blockquote><p>由于所有记录都是按照索引列的值从小到大的顺序排好序的，所以这极大的方便我们查找索引列的值在某个范围内的记录</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231225141625247.png" alt="image-20231225141625247" tabindex="0" loading="lazy"><figcaption>image-20231225141625247</figcaption></figure><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> name <span class="token operator">&gt;</span> <span class="token string">&#39;Asa&#39;</span> <span class="token operator">AND</span> name <span class="token operator">&lt;</span> <span class="token string">&#39;Barlow&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol><li>找到name 值为Asa 的记录。</li><li>沿着name值为Asa的记录遍历叶子节点链表</li><li>直到遇到范围终止值停止</li><li>找到这些记录的主键值，再到聚簇索引中回表查找完整的记录。</li></ol><blockquote><p><strong>如果有多个针对索引列的范围查询条件呢？</strong></p></blockquote><p>在使用联合进行范围查找的时候需要注意，如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到B+ 树索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> person_info 
<span class="token keyword">WHERE</span> name <span class="token operator">&gt;</span> <span class="token string">&#39;Asa&#39;</span> <span class="token operator">AND</span> name <span class="token operator">&lt;</span> <span class="token string">&#39;Barlow&#39;</span> <span class="token operator">AND</span> birthday <span class="token operator">&gt;</span> <span class="token string">&#39;1980-01-01&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><p>通过条件<code>name &gt; &#39;Asa&#39; AND name &lt; &#39;Barlow&#39;</code> 来对name 进行范围</p><ul><li>查找的结果可能有多条name 值不同的记录，</li></ul></li><li><p>对这些name 值不同的记录继续通过<code>birthday &gt; &#39;1980-01-01&#39;</code> 条件继续过滤。</p></li></ol><p>这对于联合索引<code>idx_name_birthday_phone_number</code> 来说，只能用到name 列的部分，而用不到birthday 列的部分</p><p>因为只有name 值相同的情况下才能用birthday 列的值进行排序</p><p>而这个查询中通过name 进行范围查找的记录中，name值并不是唯一的，这些筛选出来的记录并不是按照birthday 列进行排序的</p><p>所以在搜索条件中继续以birthday 列进行查找时是用不到这个B+ 树索引的。</p><p>只能回表后再对后面的条件进行筛选</p><blockquote><p><strong>InnoDB有没有对此做优化？</strong></p></blockquote><p><strong>利用索引下推可以减少无效回表的次数</strong></p><p>存储引擎利用联合索引的name列部分定位到符合条件的主键值之后，直接判断该联合索引中包含的下一列（birthday列）的条件是否成立，成立了再回表找真实记录</p><p>索引下推也只适用于查询条件中出现的列是联合索引中有的列</p><h4 id="精确匹配-范围匹配" tabindex="-1"><a class="header-anchor" href="#精确匹配-范围匹配" aria-hidden="true">#</a> 精确匹配+范围匹配</h4><p>对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> person_info 
<span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;Ashburn&#39;</span> 
  <span class="token operator">AND</span> birthday <span class="token operator">&gt;</span> <span class="token string">&#39;1980-01-01&#39;</span> 
  <span class="token operator">AND</span> birthday <span class="token operator">&lt;</span> <span class="token string">&#39;2000-12-31&#39;</span> 
  <span class="token operator">AND</span> phone_number <span class="token operator">&gt;</span> <span class="token string">&#39;15100000000&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><p><code>name = &#39;Ashburn&#39;</code></p><ul><li>对name 列进行精确查找，可以使用B+ 树索引。</li></ul></li><li><p><code>birthday &gt; &#39;1980-01-01&#39; AND birthday &lt; &#39;2000-12-31&#39;</code></p><ul><li><p>由于name 列是精确查找，所以通过<code>name = &#39;Ashburn&#39;</code> 条件查找后得到的结果的name 值都是相同的，</p></li><li><p>它们会再按照birthday 的值进行排序。所以此时对birthday 列进行范围查找是可以用到B+ 树索引的。</p></li></ul></li><li><p><code>phone_number &gt; &#39;15100000000&#39;</code></p><ul><li>通过birthday 的范围查找的记录的birthday 的值可能不同</li><li>所以这个条件无法再利用B+ 树索引了，只能遍历上一步查询得到的记录。</li></ul></li></ol><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>SELECT * 
FROM person_info 
WHERE name = &#39;Ashburn&#39; 
  AND birthday &gt; &#39;1980-01-01&#39; 
  AND phone_number &gt; &#39;15100000000&#39;;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这个查询就可以用到整个联合索引了</li></ul><h4 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1" aria-hidden="true">#</a> 总结</h4><p>一个简单的口诀用于判断会不会使用索引。</p><blockquote><p>前提：查询条件是从左到右按照索引列的顺序来的</p></blockquote><p>按照组成索引的列的顺序，从左往右：<strong>AND 用 OR 不用，正用反不用，范围则中断</strong>。</p><ul><li>AND语句可以使用索引 <ul><li>只要所有索引列都用上了，顺序无所谓</li></ul></li><li>OR语句不使用索引</li><li>等值匹配（=）可以使用索引</li><li>不等值匹配（!=）不使用索引</li><li>遇到某个索引列条件是范围查询就中断索引的使用 <ul><li>BETWEEN AND 和 LIKE 不会受影响</li><li>BETWEEN AND相当于 &gt;= 和 &lt;= ，有等值匹配条件的部分都可以用到索引，相当于分为两种查询，范围的用不了，等值的可以用</li></ul></li></ul><p>在实践中，用索引还是不用索引，就一个原则：<strong>看 EXPLAIN 命令的输出</strong>。</p><h3 id="利用索引优化排序" tabindex="-1"><a class="header-anchor" href="#利用索引优化排序" aria-hidden="true">#</a> 利用索引优化排序</h3><p>学习ORDER BY底层原理的时候讲到，可以使用联合索引来优化排序的过程</p><p>将排序的列设为索引，索引会直接按照该列的大小排好序，直接取出来就是有序的了，不用额外进行排序，就可能省去在内存或者文件中排序的步骤</p><blockquote><p><strong>使用联合索引进行排序注意事项</strong></p></blockquote><p>ORDER BY 的子句后边的列的顺序也必须按照索引列的顺序给出，如果顺序不是按照联合索引定义的顺序，也是用不了B+树索引的。</p><p>同理，排序中使用索引也需要遵守左值匹配，或者也可以将左值定为常量</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> person_info 
<span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;A&#39;</span> 
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> birthday<span class="token punctuation">,</span> phone_number 
<span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>什么情况下不可以使用索引进行排序</strong></p></blockquote><p><strong>ASC、DESC混用</strong></p><p>对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是ASC 规则排序，要么都是DESC 规则排序</p><p><strong>WHERE子句中出现非索引列的条件</strong></p><p>如果WHERE子句中出现了非排序使用到的索引列，那么排序依然是使用不到索引的</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> person_info 
<span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">&#39;China&#39;</span> 
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> name <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个查询只能先把符合搜索条件country = &#39;China&#39; 的记录提取出来后再进行排序，是使用不到索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> person_info 
<span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;A&#39;</span> 
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> birthday<span class="token punctuation">,</span> phone_number <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然这个查询也有搜索条件，但是name = &#39;A&#39; 可以使用到索引<code>idx_name_birthday_phone_number</code></p><p>过滤剩下的记录还是按照birthday 、phone_number 列排序的，所以还是可以使用索引进行排序的。</p><p><strong>排序列包含非同一个索引的列</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> person_info
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> name<span class="token punctuation">,</span> country <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>排序列使用了复杂的表达式</strong></p><p>要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是修饰过的形式</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> person_info 
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> UPPER<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>使用了UPPER 函数修饰过的列就不是单独的列了</li></ul><h3 id="利用索引优化分组" tabindex="-1"><a class="header-anchor" href="#利用索引优化分组" aria-hidden="true">#</a> 利用索引优化分组</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> name<span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> phone_number<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> 
<span class="token keyword">FROM</span> person_info 
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> name<span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> phone_number
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>先把记录按照name 值进行分组，所有name 值相同的记录划分为一组。</li><li>将每个name 值相同的分组里的记录再按照birthday 的值进行分组，将birthday 值相同的记录放到一个小分组里，所以看起来就像在一个大分组里又化分了好多小分组。</li><li>再将上一步中产生的小分组按照phone_number 的值分成更小的分组，所以整体上看起来就像是先把记录分成一个大分组，然后把大分组分成若干个小分组，然后把若干个小分组再细分成更多的小小分组。</li></ol><p>然后针对那些小小分组进行统计</p><p>比如在我们这个查询语句中就是统计每个小小分组包含的记录条数</p><p>如果没有索引的话，这个分组过程全部需要在内存里实现</p><p>如果有了索引的话，恰巧这个分组顺序又和我们的B+ 树中的索引列的顺序是一致的，而我们的B+ 树索引又是按照索引列排好序的，可以直接使用B+ 树索引进行分组。</p><h2 id="数据存储的方式" tabindex="-1"><a class="header-anchor" href="#数据存储的方式" aria-hidden="true">#</a> 数据存储的方式</h2><p>一张表在物理空间的数据存储有堆表和索引组织表两种方式：</p><ul><li>堆表中的数据是无序存放的，数据排序完全依赖索引 <ul><li>MyISAM的存储方式</li></ul></li><li>索引组织表，数据根据主键排序存放在索引中 <ul><li>InnoDB的存储方式</li></ul></li></ul><h3 id="堆表" tabindex="-1"><a class="header-anchor" href="#堆表" aria-hidden="true">#</a> 堆表</h3><h4 id="堆表的特点" tabindex="-1"><a class="header-anchor" href="#堆表的特点" aria-hidden="true">#</a> 堆表的特点</h4><ul><li>数据和索引分开存储，索引是根据数据进行排序的结果，而数据真实存储在堆表中是无序的</li><li>索引不会确定数据在堆表中应该存储在什么位置</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231222212043057.png" alt="image-20231222212043057" tabindex="0" loading="lazy"><figcaption>image-20231222212043057</figcaption></figure><h4 id="堆表的优点" tabindex="-1"><a class="header-anchor" href="#堆表的优点" aria-hidden="true">#</a> 堆表的优点</h4><ul><li>插入块：堆表存储是无序的，向一个全新的没有做过更新和删除的堆中插入一行的时候，总是会append到对文件的最后一页</li></ul><h4 id="堆表的缺点" tabindex="-1"><a class="header-anchor" href="#堆表的缺点" aria-hidden="true">#</a> 堆表的缺点</h4><blockquote><p><strong>更新</strong></p></blockquote><p>索引叶子节点存放的是数据在堆表中的地址，当堆表的数据发生改变，索引中的地址都要更新</p><p>因此数据更新是维护索引的性能消耗很高，<strong>因为每次更新，都需要维护所有已建立的索引</strong></p><ul><li>插入需要在所有二级索引中添加一个节点以记录对应的物理地址</li><li>更新时可能因为数据长度变化，因为可能无法原地更新，这就会涉及迁移，物理地址有可能更改，需要对所有索引中，记录改行地址的节点进行修改</li><li>堆表对于OLTP业务（联机事务处理Online Transaction Processing，指一种支持实时交易处理的计算机系统，如销售、订单处理）业务的影响会很大 <ul><li>因为在堆表增删改时的性能不稳定，因此可能会存在一定的延时，对海量并发的OLTP业务支持存在局限性</li></ul></li></ul><blockquote><p><strong>查询</strong></p></blockquote><ul><li>通常数据最初是按照插入表的顺序进行存储的，但是因为数据引擎有可能会移动记录以高效存储记录，因此<strong>记录顺序无法预测</strong>，如果对获取的记录有顺序要求，必须要使用ORDER BY <ul><li>如果是有序存储的话，可以按照想要的顺序进行存储，这样查询的时候就可以不需要ORDER BY子句了</li></ul></li><li>需要<strong>先从索引查到地址，再从堆表中获取真实数据</strong>，每读取一条记录都存在回表的过程，</li></ul><h4 id="堆表的适用场景" tabindex="-1"><a class="header-anchor" href="#堆表的适用场景" aria-hidden="true">#</a> 堆表的适用场景</h4><blockquote><p><strong>适合使用堆表的场景</strong></p></blockquote><p>堆表可以用于大型无序插入操作的临时表，因为在物理空间写入新的数据时，大部分情况下不需要在指定位置插入，而是直接在尾部追加</p><blockquote><p><strong>不适合使用堆表的场景</strong></p></blockquote><ul><li><strong>当数据经常需要按顺序返回</strong><ul><li>没有索引的情况下，因为数据引擎可以在堆中移动数据以有效地存储行，<strong>无法预测数据顺序</strong>，因此如果需要数据有序返回，就必须排序</li><li>有索引的情况下，根据索引顺序获取，但索引中相邻的记录在物理空间也不一定相邻，因此<strong>存在随机IO</strong>，且根据局部性原理，索引相邻数据被随机访问加载的概率低</li></ul></li><li><strong>当数据经常需要分组查询时</strong><ul><li>因为<strong>分组之前必须要先排序，才可以分组归类</strong>，排序使用聚簇索引效率会高很多</li></ul></li><li><strong>当频繁进行范围查询时</strong><ul><li>因为<strong>范围查询也需要排序</strong>，而数据顺序返回开销较大</li></ul></li><li><strong>当数据频繁更新时</strong><ul><li>如果无法原地更新，<strong>涉及数据迁移</strong>，那么就需<strong>要更新堆表上的所有二级索引中存储的物理地址</strong></li></ul></li></ul><h3 id="索引组织表" tabindex="-1"><a class="header-anchor" href="#索引组织表" aria-hidden="true">#</a> 索引组织表</h3><h4 id="索引组织表的特点" tabindex="-1"><a class="header-anchor" href="#索引组织表的特点" aria-hidden="true">#</a> 索引组织表的特点</h4><ul><li><strong>数据根据主键排序存放在索引中</strong>，<strong>索引即数据，数据即索引</strong></li><li>插入时<strong>根据索引排序</strong>结果确定该记录实际存放的位置</li></ul><h4 id="索引组织表的优点" tabindex="-1"><a class="header-anchor" href="#索引组织表的优点" aria-hidden="true">#</a> 索引组织表的优点</h4><ul><li>索引组织表在大量变更的场景下，性能会优于堆表 <ul><li>因为在大部分情况下，也就是没有操作到二级索引记录的列值时，索引组织表不需要维护二级索引</li></ul></li><li>堆表中的索引都是二级索引，因为记录的是数据地址，无法直接通过访问索引拿到数据，需要根据地址获取 <ul><li>相比于堆表，一旦数据发生更新，就需要对所有的索引执行相应的修改操作</li></ul></li></ul><h2 id="索引分类" tabindex="-1"><a class="header-anchor" href="#索引分类" aria-hidden="true">#</a> 索引分类</h2><ul><li>根据叶子节点是否存储数据来划分，可以分成<strong>聚簇索引</strong>和<strong>非聚簇索引</strong>。</li><li>如果某个索引包含某个查询的所有列，那么这个索引就是<strong>覆盖索引</strong>。</li><li>如果索引的值必须是唯一的，不能重复，那么这个索引就是<strong>唯一索引。</strong></li><li>如果索引的某个列，只包含该列值的前一部分，那么这个索引就是<strong>前缀索引</strong><ul><li>比如说在一个类型是 varchar(128) 的列上，选择前 64 个字符作为索引。</li></ul></li><li>如果某个索引由多个列组成，那么这个索引就是<strong>组合索引，<strong>也叫做</strong>联合索引</strong>。</li><li>如果某个索引由一个函数表达式构成，那么这个索引就是<strong>函数索引</strong></li><li><strong>全文索引</strong>是指用于支持文本模糊查询的索引。</li><li><strong>哈希索引</strong>是指使用哈希算法的索引 <ul><li>InnoDB 并不支持这种索引。</li></ul></li></ul><p>一个索引可以同时是覆盖索引、唯一索引、前缀索引和组合索引，你站在不同的角度去看待索引就会有不同的说法。</p><h3 id="覆盖索引" tabindex="-1"><a class="header-anchor" href="#覆盖索引" aria-hidden="true">#</a> 覆盖索引</h3><h4 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h4><p>如果你查询的列全部都在某个索引里面，那么数据库可以直接把索引存储的这些列的值给你，而不必回表。</p><p><strong>这个索引在这个查询下就是一个覆盖索引</strong>。所以覆盖索引并不是一个独立的索引，而是某个索引相对于某个查询而言的。</p><h4 id="应用" tabindex="-1"><a class="header-anchor" href="#应用" aria-hidden="true">#</a> 应用</h4><p>针对这个特性，优化 SQL 性能里面有两种常见的说法。</p><ol><li><strong>只查询需要的列</strong>。</li><li><strong>针对最频繁的查询来设计覆盖索引</strong>。</li></ol><p>这两种说法本质上都是为了避免回表。</p><h3 id="前缀索引" tabindex="-1"><a class="header-anchor" href="#前缀索引" aria-hidden="true">#</a> 前缀索引</h3><h4 id="定义-1" tabindex="-1"><a class="header-anchor" href="#定义-1" aria-hidden="true">#</a> 定义</h4><p>前缀索引也叫局部索引，比如给身份证前10位添加索引，类似这种给某列部分信息添加索引的方式叫做前缀索引</p><p>就比如词典，用首字母开头拿来当目录定位，就是前缀索引，目录中具体哪个单词在哪一页就是一般的索引。</p><ul><li>对于BLOB、TEXT或很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度</li><li>前缀索引可以建立在CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT上</li></ul><h4 id="作用" tabindex="-1"><a class="header-anchor" href="#作用" aria-hidden="true">#</a> 作用</h4><ul><li>可以有效减小索引文件的大小，让每个索引页可以存放更多的索引值，从而提高查询效率</li><li>因为索引存储的值不是完全的，所以不能用于GROUP BY 和 ORDER BY，也无法用于索引覆盖</li></ul><h4 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h4><blockquote><p>对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引</p></blockquote><p>当字符串很长，而且<strong>前几个字符就开始不同</strong>，<strong>适合</strong>使用前缀索引</p><p>如果字符串很长，但是<strong>只有后几位不同</strong>，使用<strong>前缀索引的效果就不明显了</strong>。</p><p>比如整个字段的长度为20，索引选择性为0.9，对前10个字符建立前缀索引，其选择性也只有0.5，为了更好的索引选择性，增加前缀索引的长度，但是长度增加，前缀索引的优势就不明显了</p><h4 id="存在问题" tabindex="-1"><a class="header-anchor" href="#存在问题" aria-hidden="true">#</a> 存在问题</h4><p>由于其索引节点中，未存储一个字段的完整值</p><p>所以<code>MySQL</code>也无法通过前缀索引来完成<code>ORDER BY、GROUP BY</code>等分组排序工作</p><p>同时也无法完成覆盖扫描等操作。</p><h3 id="组合索引" tabindex="-1"><a class="header-anchor" href="#组合索引" aria-hidden="true">#</a> 组合索引</h3><blockquote><p>也叫<strong>联合索引</strong></p></blockquote><p>组合索引（Compound Index）是指由多个列所组合而成的 B+树索引</p><p>组合索引既可以是主键索引，也可以是二级索引</p><p><strong>联合索引可以用来解决两种问题</strong></p><ul><li><strong>避免额外排序</strong></li><li><strong>避免回表</strong></li></ul><blockquote><p>示例表</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">\`</span>orders<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">\`</span>O_ORDERKEY<span class="token punctuation">\`</span></span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>O_CUSTKEY<span class="token punctuation">\`</span></span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>O_ORDERSTATUS<span class="token punctuation">\`</span></span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>O_TOTALPRICE<span class="token punctuation">\`</span></span> <span class="token keyword">decimal</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>O_ORDERDATE<span class="token punctuation">\`</span></span> <span class="token keyword">date</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>O_ORDERPRIORITY<span class="token punctuation">\`</span></span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>O_CLERK<span class="token punctuation">\`</span></span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>O_SHIPPRIORITY<span class="token punctuation">\`</span></span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>O_COMMENT<span class="token punctuation">\`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">79</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>O_ORDERKEY<span class="token punctuation">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">\`</span>ORDERS_FK1<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>O_CUSTKEY<span class="token punctuation">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">CONSTRAINT</span> <span class="token identifier"><span class="token punctuation">\`</span>orders_ibfk_1<span class="token punctuation">\`</span></span> <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>O_CUSTKEY<span class="token punctuation">\`</span></span><span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> <span class="token identifier"><span class="token punctuation">\`</span>customer<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>C_CUSTKEY<span class="token punctuation">\`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>字段 o_orderkey 是 INT 类型的主键；</li><li>字段 o_custkey 是一个关联字段，关联表 customer；</li><li>字段 o_orderdate、o_orderstatus、o_totalprice、o_orderpriority 用于描述订单的基本详情，分别表示下单的时间、当前订单的状态、订单的总价、订单的优先级。</li></ul><h4 id="避免额外排序" tabindex="-1"><a class="header-anchor" href="#避免额外排序" aria-hidden="true">#</a> 避免额外排序</h4><p>在真实的业务场景中，你会遇到根据某个列进行查询，然后按照时间排序的方式逆序展示</p><ul><li>在微博业务中，用户的微博展示的就是根据用户 ID 查询出用户订阅的微博，然后根据时间逆序展示</li><li>在电商业务中，用户订单详情页就是根据用户 ID 查询出用户的订单数据，然后根据购买时间进行逆序展示</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231225222720407.png" alt="image-20231225222720407" tabindex="0" loading="lazy"><figcaption>image-20231225222720407</figcaption></figure><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">EXPLAIN</span> FORMAT<span class="token operator">=</span>tree 
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> orders
<span class="token keyword">WHERE</span> o_custkey <span class="token operator">=</span> <span class="token number">147601</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> o_orderdate <span class="token keyword">DESC</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">EXPLAIN</span>: <span class="token operator">-</span><span class="token operator">&gt;</span> Sort: orders<span class="token punctuation">.</span>O_ORDERDATE <span class="token keyword">DESC</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">18.98</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">19</span><span class="token punctuation">)</span>
    <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token keyword">Index</span> lookup <span class="token keyword">on</span> orders <span class="token keyword">using</span> ORDERS_FK1 <span class="token punctuation">(</span>O_CUSTKEY<span class="token operator">=</span><span class="token number">147601</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这个查询语句确实使用到了索引，但是还是会多一次额外的排序才能得到最终的结果</li></ul><p>由于已对列 o_custky 创建索引，因此上述 SQL 语句并不会执行得特别慢</p><p>但是在海量的并发业务访问下，每次 SQL 执行都需要排序就会对业务的性能产生非常明显的影响，比如 CPU 负载变高，QPS 降低。</p><blockquote><p>如何解决？</p></blockquote><p>在表 orders 上创建新的组合索引 idx_custkey_orderdate，对字段（o_custkey，o_orderdate）进行索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> orders <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> 
idx_custkey_orderdate<span class="token punctuation">(</span>o_custkey<span class="token punctuation">,</span>o_orderdate<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这时再次执行之前的SQL</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">EXPLAIN</span>: <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token keyword">Index</span> lookup <span class="token keyword">on</span> orders <span class="token keyword">using</span> idx_custkey_orderdate <span class="token punctuation">(</span>O_CUSTKEY<span class="token operator">=</span><span class="token number">147601</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">6.65</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">19</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>可以看到，这个查询语句用了刚建的联合索引之后就直接返回了，没有进行额外的排序了</li></ul><h4 id="避免回表" tabindex="-1"><a class="header-anchor" href="#避免回表" aria-hidden="true">#</a> 避免回表</h4><blockquote><p>回表是什么？</p></blockquote><p>SQL 需要通过二级索引查询得到主键值，然后再根据主键值搜索主键索引，最后定位到完整的数据。</p><blockquote><p>如何避免回表？</p></blockquote><p>由于二级组合索引的叶子节点，包含索引键值和主键值，若查询的字段在二级索引的叶子节点中，则可直接返回结果，无需回表。</p><p>这种<strong>通过组合索引避免回表的优化技术也称为索引覆盖（Covering Index）</strong></p><h3 id="函数索引" tabindex="-1"><a class="header-anchor" href="#函数索引" aria-hidden="true">#</a> 函数索引</h3><p>MySQL8.0.13之后开始支持创建函数索引，即索引键是一个函数表达式</p><p>函数索引有两大用处：</p><ul><li>优化业务SQL性能</li><li>配合虚拟列</li></ul><h4 id="优化业务sql性能" tabindex="-1"><a class="header-anchor" href="#优化业务sql性能" aria-hidden="true">#</a> 优化业务SQL性能</h4><blockquote><p><strong>为什么数据库规范要求查询条件中函数写在等式右边而不能写在左边？</strong></p></blockquote><p>假设<code>register_date</code>创建了索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">User</span> 
<span class="token keyword">WHERE</span> DATE_FORMAT<span class="token punctuation">(</span>register_date<span class="token punctuation">,</span><span class="token string">&#39;%Y-%m&#39;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">&#39;2021-01&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这样书写的SQL语句是不会使用到该索引的</p><ul><li>索引 <code>idx_register_date</code> 只对 <code>register_date</code> 的数据排序，又没有对<code>DATE_FORMAT(register_date)</code> 排序</li></ul><blockquote><p>如果编写代码的时候没有按照规范来书写SQL，将函数表达式写在等式左边了怎么办？</p></blockquote><p>如果线上业务真的没有按正确的 SQL 编写，那么可能造成数据库存在很多慢查询 SQL，导致业务缓慢甚至发生雪崩的场景。</p><p><strong>要尽快解决这个问题，可以使用函数索引，</strong> 创建一个<code>DATE_FORMAT(register_date)</code> 的索引，这样就能利用排序数据快速定位了</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">User</span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> 
idx_func_register_date<span class="token punctuation">(</span><span class="token punctuation">(</span>DATE_FORMAT<span class="token punctuation">(</span>register_date<span class="token punctuation">,</span><span class="token string">&#39;%Y-%m&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>虽然这样可以解决燃眉之急，但是还是建议业务迭代在下个版本中能够优化SQL</li><li>否则会导致对同一份数据做了两份索引，索引需要排序，排序多了会降低性能</li></ul><h4 id="结合虚拟列使用" tabindex="-1"><a class="header-anchor" href="#结合虚拟列使用" aria-hidden="true">#</a> 结合虚拟列使用</h4><blockquote><p>JSON章节中建的示例表</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> UserLogin <span class="token punctuation">(</span>
    userId <span class="token keyword">BIGINT</span><span class="token punctuation">,</span>
    loginInfo JSON<span class="token punctuation">,</span>
    cellphone <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token punctuation">(</span>loginInfo<span class="token operator">-</span><span class="token operator">&gt;&gt;</span><span class="token string">&quot;$.cellphone&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> idx_cellphone<span class="token punctuation">(</span>cellphone<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>列 cellphone 就是一个虚拟列，它是由后面的函数表达式计算而成，本身这个列不占用任何的存储空间</li><li>索引 idx_cellphone 实质就是一个函数索引</li><li>写 SQL 时可以直接使用这个虚拟列，而不用写冗长的函数</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span>  <span class="token operator">*</span>  <span class="token keyword">FROM</span> UserLogin 
<span class="token keyword">WHERE</span> cellphone <span class="token operator">=</span> <span class="token string">&#39;13918888888&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>实际应用</p></blockquote><p>对于爬虫类的业务，我们会从网上先爬取很多数据</p><p>其中有些是我们关心的数据，有些是不关心的数据</p><p>通过虚拟列技术，可以展示我们想要的那部分数据，再通过虚拟列上创建索引，就是对爬取的数据进行快速的访问和搜索。</p><h3 id="全文索引" tabindex="-1"><a class="header-anchor" href="#全文索引" aria-hidden="true">#</a> 全文索引</h3><h4 id="定义-2" tabindex="-1"><a class="header-anchor" href="#定义-2" aria-hidden="true">#</a> 定义</h4><p>全文索引通过建立倒排索引来快速匹配文档，作用和使用SQL<code>“LIKE %” </code>的作用是一样的，但是效率会比<code>LIKE %</code>全表扫描要高。</p><blockquote><p>为什么要用全文索引？</p></blockquote><ul><li>LIKE查询或json字段查询效率低</li><li>没时间引入ElasticSearch、Slor现成的文档搜索引擎，或者不会用</li><li>使用别的索引速度仍然不高</li></ul><h4 id="mysql支持" tabindex="-1"><a class="header-anchor" href="#mysql支持" aria-hidden="true">#</a> MySQL支持</h4><p>MySQL全文索引支持三种模式：</p><ul><li>布尔模式</li><li>自然语言模式</li><li>查询拓展</li></ul><p>MySQL版本支持：</p><ul><li>MySQL5.6之前的版本，只有MyISAM支持全文索引</li><li>MySQL5.6之后，MyISAM和InnoDB支持全文索引</li></ul><p>MySQL数据类型支持：</p><ul><li>只有字段的数据类型为char、varchar、text及其系列才可以建立全文索引</li></ul><h4 id="存在问题-1" tabindex="-1"><a class="header-anchor" href="#存在问题-1" aria-hidden="true">#</a> 存在问题</h4><ul><li>由于<strong>全文索引是基于分词实现的</strong>，所以对一个字段建立全文索引后，<code>MySQL</code>会对该字段做分词处理，这些分词结果也会被存储在全文索引中，因此<strong>全文索引的文件会额外的大</strong>！</li><li>由于全文索引对每个字段值都会做分词，因此当修改字段值后，<strong>分词是需要时间</strong>的，所以<strong>修改字段数据后不会立马自动更新全文索引</strong>，此时需要咱们<strong>写存储过程，并调用它手动更新全文索引中的数据</strong>。</li><li>除开上述两点外，全文索引最大的硬伤在于<strong>对中文支持不够友好</strong>，类似于英文可以直接通过符号、空格来分词，但中文呢？一个词语来形容就是博大精深，无法精准的对一段文字做分词，因此<strong>全文索引在检索中文时，存在些许精准度问题</strong>。</li></ul><blockquote><p>如何解决？</p></blockquote><p>因此如果项目规模较大，通常再引入<code>ElasticSearch、Solr、MeiliSearch</code>等搜索引擎是一个更佳的选择</p><h3 id="哈希索引" tabindex="-1"><a class="header-anchor" href="#哈希索引" aria-hidden="true">#</a> 哈希索引</h3><h4 id="定义-3" tabindex="-1"><a class="header-anchor" href="#定义-3" aria-hidden="true">#</a> 定义</h4><blockquote><p>InnoDB不支持哈希索引</p></blockquote><p>采用哈希索引，在基于列值进行精确匹配时，只需要经过一次哈希计算即可获取数据，因此查询效率很高。</p><h4 id="存在问题-2" tabindex="-1"><a class="header-anchor" href="#存在问题-2" aria-hidden="true">#</a> 存在问题</h4><p>哈希结构的致命问题在于无序，也就是无法基于哈希索引的字段做排序、分组等工作。</p><p>如果确定表中不会使用排序功能，那么可以适当选用哈希结构作为索引的数据结构。</p><h2 id="索引失效的情况" tabindex="-1"><a class="header-anchor" href="#索引失效的情况" aria-hidden="true">#</a> 索引失效的情况</h2><h3 id="对索引使用左模糊匹配" tabindex="-1"><a class="header-anchor" href="#对索引使用左模糊匹配" aria-hidden="true">#</a> 对索引使用左模糊匹配</h3><p>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效。</p><blockquote><p><strong>为什么 like 关键字左或者左右模糊匹配无法走索引呢？</strong></p></blockquote><p>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较</p><p>在B+树索引使用条件中有详细的说明</p><blockquote><p>是不是所有的左值模糊匹配都没办法使用索引？</p></blockquote><p><strong>LIKE &quot;%X&quot; 仍然使用索引的场景</strong></p><p>关键要看SQL查询的字段、表字段、索引字段</p><p>一个表有2个字段，其中name是索引字段，id拥有自增主键索引，对该表分别执行以下语句：</p><ul><li>针对这个表，以下四个查询都会使用到二级索引</li><li>一般情况下，第一个和第二个SQL语句是会使用二级索引的</li><li>在特殊情况下，第三第四个SQL也可以使用二级索引 <ul><li>只是前两个SQL使用索引是范围扫描二级索引，而后两个SQL使用索引是扫描整个二级索引</li></ul></li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s <span class="token keyword">WHERE</span> name <span class="token operator">LIKE</span> <span class="token string">&quot;XXX&quot;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s <span class="token keyword">WHERE</span> name <span class="token operator">LIKE</span> <span class="token string">&quot;XXX%&quot;</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s <span class="token keyword">WHERE</span> name <span class="token operator">LIKE</span> <span class="token string">&quot;%XXX&quot;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s <span class="token keyword">WHERE</span> name <span class="token operator">LIKE</span> <span class="token string">&quot;%XXX%&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>为什么该查询可以使用二级索引？</p></blockquote><p>因为SLEECT * 相当于 SELECT id，name，要查询的列都包含在对name列撞见的二级索引的B+树中，因此查二级索引就可以查到全部的结果，也就是使用了索引覆盖。</p><blockquote><p>都是遍历完整的索引树，为什么不选择遍历需聚簇索引而遍历二级索引？</p></blockquote><p>因为MySQL优化器认为直接遍历二级索引树比遍历聚簇索引的成本更小：</p><ul><li>首先因为扫描二级索引就可以获取所有需要的数据</li><li>虽然二级索引和聚簇索引都包含需要的数据，但因为 <ul><li>二级索引的记录只有「索引列+主键值」，记录内容更少</li><li>聚簇索引记录内容包括主键值、事务 id、用于事务和 MVCC 的回滚指针以及所有的剩余列，因此聚簇索引在扫描的时候需要读取更多的数据</li></ul></li></ul><blockquote><p>为什么这个数据表加了非索引字段，执行同样的查询语句后，怎么就变成了全表扫描呢？</p></blockquote><ul><li>因为增加了其他字段后，二级索引就无法包含<code>select * from t_user where name like &quot;%xx&quot;;</code>需要的所有数据</li><li>这时候就需要回表才可以获取所有的操作</li><li>同时又是左模糊匹配，无法利用索引的有序性进行查找</li></ul><h3 id="对索引使用函数" tabindex="-1"><a class="header-anchor" href="#对索引使用函数" aria-hidden="true">#</a> 对索引使用函数</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># name 为二级索引</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> length<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果</p><p>如果查询条件中对索引字段使用函数，就会导致索引失效</p><blockquote><p><strong>为什么对索引使用函数，就无法走索引了呢？</strong></p></blockquote><p>因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了</p><blockquote><p><strong>怎么解决这个问题</strong></p></blockquote><p>从MySQL 8.0.13开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引</p><p>也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p><h3 id="对索引进行表达式计算" tabindex="-1"><a class="header-anchor" href="#对索引进行表达式计算" aria-hidden="true">#</a> 对索引进行表达式计算</h3><p>在查询条件中对索引进行表达式计算，也是无法走索引的。</p><blockquote><p><strong>为什么对索引进行表达式计算，就无法走索引了呢？</strong></p></blockquote><p>原因跟对索引使用函数差不多。</p><p>因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引</p><p>只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。</p><blockquote><p><strong>怎么解决这个问题</strong></p></blockquote><p>查询条件中不要对索引进行表达式计算。</p><h3 id="对索引隐式类型转换" tabindex="-1"><a class="header-anchor" href="#对索引隐式类型转换" aria-hidden="true">#</a> 对索引隐式类型转换</h3><p>如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。</p><blockquote><p>示例1</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231225235700040.png" alt="image-20231225235700040" tabindex="0" loading="lazy"><figcaption>image-20231225235700040</figcaption></figure><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token number">1300000001</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是，如果索引字段是整型类型，查询条件中的输入参数即使字符串，是不会导致索引失效，还是可以走索引扫描</p><blockquote><p>示例2</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token string">&#39;1&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231225235822102.png" alt="image-20231225235822102" tabindex="0" loading="lazy"><figcaption>image-20231225235822102</figcaption></figure><blockquote><p><strong>为什么第一个例子会导致索引失效，而第二例子不会呢？</strong></p></blockquote><p><u><strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong></u></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token number">1300000001</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>phone 字段为字符串，所以 MySQL 要会自动把字符串转为数字，所以这条语句相当于</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> CAST<span class="token punctuation">(</span>phone <span class="token keyword">AS</span> signed <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1300000001</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>CAST 函数是作用在了 phone 字段，而 phone 字段是索引，也就是对索引使用了函数</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>字符串部分是输入参数，也就需要将字符串转为数字，所以这条语句相当于</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> id <span class="token operator">=</span> CAST<span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span> <span class="token keyword">AS</span> signed <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>索引字段并没有用任何函数，CAST 函数是用在了输入参数，因此是可以走索引扫描的</li></ul><h3 id="联合索引非最左匹配" tabindex="-1"><a class="header-anchor" href="#联合索引非最左匹配" aria-hidden="true">#</a> 联合索引非最左匹配</h3><p>最左匹配原则详见：<code>索引/三种索引/联合索引/最左匹配原则</code></p><blockquote><p><strong>为什么联合索引不遵循最左匹配原则就会失效？</strong></p></blockquote><p>原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p><p>也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。</p><p>如果我们仅仅按照第二列搜索，肯定无法走索引</p><h3 id="where-子句中的-or" tabindex="-1"><a class="header-anchor" href="#where-子句中的-or" aria-hidden="true">#</a> WHERE 子句中的 OR</h3><p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p><blockquote><p><strong>为什么使用了OR就索引就会失效？</strong></p></blockquote><p>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的</p><p>只要有条件列不是索引列，就会进行全表扫描。</p><blockquote><p><strong>怎么解决这个问题？</strong></p></blockquote><p>使用索引合并，将OR条件两边的字段都设为索引</p><h3 id="不同字段值对比" tabindex="-1"><a class="header-anchor" href="#不同字段值对比" aria-hidden="true">#</a> 不同字段值对比</h3><p>从一张表中查询出一些值，然后根据这些值去其他表中筛选数据</p><p>这个业务也是实际项目中较为常见的场景</p><p>下面为了简单实现，就简单用姓名和性别模拟一下字段对比的场景</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">\`</span>zz_users<span class="token punctuation">\`</span></span> <span class="token keyword">WHERE</span> user_name <span class="token operator">=</span> user_sex<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>按理来说，因为<code>user_name</code>属于联合索引的第一个字段，所以上述这条<code>SQL</code>中规中矩，理论上会走索引的 <img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/0fbf03533f9c4e979d2207432d408c95~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="字段对比" loading="lazy"> 显然，这个场景也会导致索引无法使用</p><h3 id="反向范围操作" tabindex="-1"><a class="header-anchor" href="#反向范围操作" aria-hidden="true">#</a> 反向范围操作</h3><p>一般来说，如果<code>SQL</code>属于正向范围查询，例如<code>&gt;、&lt;、between、like、in...</code>等操作时，索引是可以正常生效的；</p><p>但如果<code>SQL</code>执行的是反向范围操作，例如<code>NOT IN、NOT LIKE、IS NOT NULL、!=、&lt;&gt;...</code>等操作时，就无法使用索引</p><h3 id="索引扫描行数超过30" tabindex="-1"><a class="header-anchor" href="#索引扫描行数超过30" aria-hidden="true">#</a> 索引扫描行数超过30%</h3><p>当走索引扫描的行数超过表行数的30%时，MySQL会默认放弃索引查询，转而使用全表扫描</p><p>因为这种情况下走索引的顺序IO不一定全表的随机IO快。</p><blockquote><p>全表扫描分两种情况：<strong>MyISAM的全表扫描就是随机I/O，InnoDB的全表扫描是顺序I/O</strong></p></blockquote><p>如果索引区分度很低，不论搜索哪个值都有可能得到一半的数据，也就是扫描索引需要扫描行数的50%：</p><ul><li>当优化器发现某个列的值出现的百分比很高（管用的百分比界限是30%），它一般会忽略索引，进行全表扫描</li></ul><h3 id="字符集不统一" tabindex="-1"><a class="header-anchor" href="#字符集不统一" aria-hidden="true">#</a> 字符集不统一</h3><p>如果数据库中多张表使用不同的字符集，不同字符集进行比较前需要进行转换，就相当于对索引使用函数，从而造成索引失效。</p><p>比如<strong>连表的时候，就会涉及到两张表的列值比较</strong>。</p><blockquote><p><strong>如何避免</strong></p></blockquote><p>因此在<strong>创建表时应该统一字符集</strong>，一般使用utfm64，同时也可以避免由于字符集转换产生的乱码。</p><h2 id="索引选择条件" tabindex="-1"><a class="header-anchor" href="#索引选择条件" aria-hidden="true">#</a> 索引选择条件</h2><p>优化器会尽量估算查询操作的成本，包括扫描数据量和回表的次数，来选择最优的执行计划</p><p>这个估算并不是准确无误的，是基于一些统计信息和默认参数进行计算的。</p><p>MySQL中的统计信息主要包括索引的基数、表的行数等：</p><ul><li>索引基数：可以使用 <code>SHOW INDEXES</code> 查看索引的基数，<code>Cardinality</code> 字段代表索引基数</li><li>这个基数并不是实时计算的，而是更具上次执行 <code>ANALYZE TABLE</code>命令时的统计信息估算得出</li></ul><h3 id="优化器选择索引的依据" tabindex="-1"><a class="header-anchor" href="#优化器选择索引的依据" aria-hidden="true">#</a> 优化器选择索引的依据</h3><p>优化器基于成本（cost）选择索引，优化器会选择成本最低的索引</p><h4 id="基本的sql执行过程" tabindex="-1"><a class="header-anchor" href="#基本的sql执行过程" aria-hidden="true">#</a> 基本的SQL执行过程</h4><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231226002705908.png" alt="image-20231226002705908" tabindex="0" loading="lazy"><figcaption>image-20231226002705908</figcaption></figure><p>SQL执行会先经过Server层再经过存储引擎层：</p><ul><li>Server层有SQL分析器、SQL优化器、SQL执行器，用于解析、分析优化、执行SQL</li><li>Engine层负责存储具体的数据，如InnoDB存储引擎，还有用于在内存中存储临时结果集的TempTable 引擎 <ul><li>临时表可以根据需要手动创建，创建的临时表使用的是TempTable引擎</li></ul></li></ul><p><strong>SQL优化器会分析所有可能的执行计划，选择成本最低的执行</strong></p><p>这种优化器称之为：<strong>CBO</strong>(Cost-based Optimizer，<strong>基于成本的优化器</strong>)</p><h4 id="sql成本计算规则" tabindex="-1"><a class="header-anchor" href="#sql成本计算规则" aria-hidden="true">#</a> SQL成本计算规则</h4><p>$$ Cost=ServerCost+EngineCost\\ =CPUCost+IOCost $$</p><ul><li><strong>CPU Cost</strong>：表示<strong>计算的开销</strong><ul><li>比如索引键值对的比较、记录值的比较、结果集的排序等等</li><li>即在Server层完成的操作，<strong>对应Server Cost</strong></li></ul></li><li><strong>IO Cost</strong>：表示<strong>引擎层的IO开销</strong><ul><li>包括内存IO和磁盘IO，<strong>对应Engine Cost</strong></li><li>MySQL8.0会区分一张表是否在内存中，分别计算内存IO开销和读取磁盘IO的开销</li></ul></li></ul><blockquote><p>如何查看Server层和Engine层的成本计算方案</p></blockquote><p>数据库mysql中的表server_cost、engine_cost记录了Server层、存储引擎层中对于各种成本的计算</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231226003330233.png" alt="image-20231226003330233" tabindex="0" loading="lazy"><figcaption>image-20231226003330233</figcaption></figure><h5 id="server层-cpu-cost" tabindex="-1"><a class="header-anchor" href="#server层-cpu-cost" aria-hidden="true">#</a> Server层：CPU Cost</h5><p>表server_cost记录了Server层优化器各种操作的成本，包括所有的CPU Cost</p><table><thead><tr><th>成本名称</th><th>具体含义</th><th>默认值</th></tr></thead><tbody><tr><td>disk_temptable_create_cost</td><td>创建磁盘临时表的成本</td><td>20</td></tr><tr><td>disk_temptable_row_cost</td><td>磁盘临时表中每条记录的成本，指向磁盘临时表中插入一条记录的开销</td><td>0.5</td></tr><tr><td>memory_temptable_create_cost</td><td>创建内存临时表的成本</td><td>1</td></tr><tr><td>memory_temptable_row_cost</td><td>内存临时表中每条记录的成本，指向内存临时表中插入一条记录的成本</td><td>0.1</td></tr><tr><td>key_compare_cost</td><td>索引键值比较的成本，成本最小</td><td>0.05</td></tr><tr><td>row_evaluate_cost</td><td>记录间比较的成本</td><td>0.1</td></tr></tbody></table><ul><li>如果一条SQL需要创建基于磁盘的临时表，那么成本最大，是基于内存临时表的20倍</li><li>而索引值的比较、记录之间的比较，开销很低，但是如果要比较的记录数非常多，成本也会非常大。</li></ul><h5 id="engine层-io-cost" tabindex="-1"><a class="header-anchor" href="#engine层-io-cost" aria-hidden="true">#</a> Engine层：IO Cost</h5><p>表engine_cost记录了存储引擎层各种操作的成本，包含了所有的IO Cost</p><table><thead><tr><th>成本名称</th><th>具体含义</th><th>默认值</th></tr></thead><tbody><tr><td>io_block_read_cost</td><td>从磁盘读取一页的成本</td><td>1</td></tr><tr><td>memory_block_read_cost</td><td>从内存读取一个页的成本</td><td>0.25</td></tr></tbody></table><ul><li>MySQL优化器认为从磁盘读取的开销是内存开销的4倍。</li><li>I/O成本可以将B+树看成一个三角形，从根节点往下找叶子节点就相当于走侧边，从叶子节点开始遍历记录就相当于走底边</li><li>I/O成本就是看侧边跟底边加起来走过的页数</li></ul><h5 id="修改操作对应的成本" tabindex="-1"><a class="header-anchor" href="#修改操作对应的成本" aria-hidden="true">#</a> 修改操作对应的成本</h5><p>Server层的CPU Cost和Engine层的IO Cost，具体操作对应的Cost是可以可以修改的。</p><p>比如如果数据库使用的是传统的HDD盘，性能差，随机读取的性能比内存读取慢50倍，就可以修改操作对应的Cost：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> engine_cost <span class="token punctuation">(</span>engine_name<span class="token punctuation">,</span> device_type<span class="token punctuation">,</span> cost_name<span class="token punctuation">,</span> cost_value<span class="token punctuation">,</span> last_update<span class="token punctuation">,</span> <span class="token keyword">comment</span><span class="token punctuation">)</span> 
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">&#39;InnoDB&#39;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&#39;io_block_read_cost&#39;</span><span class="token punctuation">,</span> <span class="token number">12.5</span><span class="token punctuation">,</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">,</span> <span class="token string">&#39;Using HDD for InnoDB&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>FLUSH OPTIMIZER_COSTS<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>用插入的方式，而不是直接修改原记录</li><li>字段值comment为记录的备注，注释</li><li>可以看到新记录的 device_type 字段值为 io_block_read_cost，和已有记录的device_type字段值一致 <ul><li>所以可能MySQL内部根据记录更新时间，选择最新添加的成本计算规则</li></ul></li><li>FLUSH OPTIMIZER_COSTS：刷新优化器的成本信息，使其生效</li></ul><h5 id="查看sql对应的成本值" tabindex="-1"><a class="header-anchor" href="#查看sql对应的成本值" aria-hidden="true">#</a> 查看SQL对应的成本值</h5><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">EXPLAIN</span> FORMAT<span class="token operator">=</span>json 
<span class="token keyword">SELECT</span> o_custkey<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>o_totalprice<span class="token punctuation">)</span> 
<span class="token keyword">FROM</span> orders <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> o_custkey

<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
 <span class="token keyword">EXPLAIN</span>: {
   <span class="token string">&quot;query_block&quot;</span>: {
     <span class="token string">&quot;select_id&quot;</span>: <span class="token number">1</span><span class="token punctuation">,</span>
     <span class="token string">&quot;cost_info&quot;</span>: {
       <span class="token string">&quot;query_cost&quot;</span>: <span class="token string">&quot;626899.50&quot;</span> <span class="token comment"># 总成本</span>
     }<span class="token punctuation">,</span>
     <span class="token string">&quot;grouping_operation&quot;</span>: {
       <span class="token string">&quot;using_filesort&quot;</span>: <span class="token boolean">false</span><span class="token punctuation">,</span>
       <span class="token string">&quot;table&quot;</span>: {
         <span class="token string">&quot;table_name&quot;</span>: <span class="token string">&quot;orders&quot;</span><span class="token punctuation">,</span>
         <span class="token string">&quot;access_type&quot;</span>: <span class="token string">&quot;index&quot;</span><span class="token punctuation">,</span>
         <span class="token string">&quot;possible_keys&quot;</span>: <span class="token punctuation">[</span>
           <span class="token string">&quot;idx_custkey_orderdate&quot;</span><span class="token punctuation">,</span>
           <span class="token string">&quot;ORDERS_FK1&quot;</span><span class="token punctuation">,</span>
           <span class="token string">&quot;idx_custkey_orderdate_totalprice&quot;</span>
         <span class="token punctuation">]</span><span class="token punctuation">,</span>
         <span class="token string">&quot;key&quot;</span>: <span class="token string">&quot;idx_custkey_orderdate_totalprice&quot;</span><span class="token punctuation">,</span>
         <span class="token string">&quot;used_key_parts&quot;</span>: <span class="token punctuation">[</span>
           <span class="token string">&quot;O_CUSTKEY&quot;</span><span class="token punctuation">,</span>
           <span class="token string">&quot;O_ORDERDATE&quot;</span><span class="token punctuation">,</span>
           <span class="token string">&quot;O_TOTALPRICE&quot;</span>
         <span class="token punctuation">]</span><span class="token punctuation">,</span>
         <span class="token string">&quot;key_length&quot;</span>: <span class="token string">&quot;14&quot;</span><span class="token punctuation">,</span>
         <span class="token string">&quot;rows_examined_per_scan&quot;</span>: <span class="token number">5778755</span><span class="token punctuation">,</span>
         <span class="token string">&quot;rows_produced_per_join&quot;</span>: <span class="token number">5778755</span><span class="token punctuation">,</span>
         <span class="token string">&quot;filtered&quot;</span>: <span class="token string">&quot;100.00&quot;</span><span class="token punctuation">,</span>
         <span class="token string">&quot;using_index&quot;</span>: <span class="token boolean">true</span><span class="token punctuation">,</span>
         <span class="token string">&quot;cost_info&quot;</span>: {
           <span class="token string">&quot;read_cost&quot;</span>: <span class="token string">&quot;49024.00&quot;</span><span class="token punctuation">,</span> <span class="token comment"># IO Cost(Engine Cost)</span>
           <span class="token string">&quot;eval_cost&quot;</span>: <span class="token string">&quot;577875.50&quot;</span><span class="token punctuation">,</span> <span class="token comment"># CPU Cost(Server Cost)</span>
           <span class="token string">&quot;prefix_cost&quot;</span>: <span class="token string">&quot;626899.50&quot;</span><span class="token punctuation">,</span> <span class="token comment"># 总成本</span>
           <span class="token string">&quot;data_read_per_join&quot;</span>: <span class="token string">&quot;2G&quot;</span> <span class="token comment"># 总的读取记录字节数</span>
         }<span class="token punctuation">,</span>
         <span class="token string">&quot;used_columns&quot;</span>: <span class="token punctuation">[</span>
           <span class="token string">&quot;O_ORDERKEY&quot;</span><span class="token punctuation">,</span>
           <span class="token string">&quot;O_CUSTKEY&quot;</span><span class="token punctuation">,</span>
           <span class="token string">&quot;O_TOTALPRICE&quot;</span>
         <span class="token punctuation">]</span>
       }
     }
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code># 这块就是成本信息
<span class="token property">&quot;cost_info&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
   <span class="token property">&quot;read_cost&quot;</span><span class="token operator">:</span> <span class="token string">&quot;49024.00&quot;</span><span class="token punctuation">,</span> # IO Cost(Engine Cost)
   <span class="token property">&quot;eval_cost&quot;</span><span class="token operator">:</span> <span class="token string">&quot;577875.50&quot;</span><span class="token punctuation">,</span> # CPU Cost(Server Cost)
   <span class="token property">&quot;prefix_cost&quot;</span><span class="token operator">:</span> <span class="token string">&quot;626899.50&quot;</span><span class="token punctuation">,</span> # 总成本
   <span class="token property">&quot;data_read_per_join&quot;</span><span class="token operator">:</span> <span class="token string">&quot;2G&quot;</span> # 总的读取记录字节数
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>read_cost</code>：表示从InnoDB存储引擎读取的开销</li><li><code>eval_cost</code>：表示Server层的CPU成本</li><li><code>prefix_cost</code>：表示这条SQL的总成本</li><li><code>data_read_per_join</code>：表示总的记录读取的字节数</li></ul><h3 id="索引出错案例分析" tabindex="-1"><a class="header-anchor" href="#索引出错案例分析" aria-hidden="true">#</a> 索引出错案例分析</h3><h4 id="案例1-未能使用创建的索引" tabindex="-1"><a class="header-anchor" href="#案例1-未能使用创建的索引" aria-hidden="true">#</a> 案例1：未能使用创建的索引</h4><p>MySQL 优化器永远是根据成本，选择出最优的执行计划。哪怕是同一条 SQL 语句，只要范围不同，优化器的选择也可能不同</p><blockquote><p>示例SQL</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> orders
<span class="token keyword">WHERE</span> o_orderdate <span class="token operator">&gt;</span> <span class="token string">&#39;1994-01-01&#39;</span> <span class="token operator">and</span> o_orderdate <span class="token operator">&lt;</span> <span class="token string">&#39;1994-12-31&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> orders 
<span class="token keyword">WHERE</span> o_orderdate <span class="token operator">&gt;</span> <span class="token string">&#39;1994-02-01&#39;</span> <span class="token operator">and</span> o_orderdate <span class="token operator">&lt;</span> <span class="token string">&#39;1994-12-31&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>第一条SQL的执行计划</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> orders 
<span class="token keyword">WHERE</span> o_orderdate <span class="token operator">&gt;</span> <span class="token string">&#39;1994-01-01&#39;</span> 
<span class="token operator">AND</span> o_orderdate <span class="token operator">&lt;</span> <span class="token string">&#39;1994-12-31&#39;</span>\\G

<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
           id: <span class="token number">1</span>
  select_type: <span class="token keyword">SIMPLE</span>
        <span class="token keyword">table</span>: orders
   partitions: <span class="token boolean">NULL</span>
         <span class="token keyword">type</span>: <span class="token keyword">ALL</span>
possible_keys: idx_orderdate
          <span class="token keyword">key</span>: <span class="token boolean">NULL</span>
      key_len: <span class="token boolean">NULL</span>
          ref: <span class="token boolean">NULL</span>
         <span class="token keyword">rows</span>: <span class="token number">5799601</span>
     filtered: <span class="token number">32.35</span>
        Extra: <span class="token keyword">Using</span> <span class="token keyword">where</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 <code>FORMAT=tree </code>来观察，对比全表扫描和强制使用二级索引的总成本</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 未使用索引</span>
<span class="token keyword">EXPLAIN</span> FORMAT<span class="token operator">=</span>tree 
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> orders 
<span class="token keyword">WHERE</span> o_orderdate <span class="token operator">&gt;</span> <span class="token string">&#39;1994-01-01&#39;</span> 
<span class="token operator">AND</span> o_orderdate <span class="token operator">&lt;</span> <span class="token string">&#39;1994-12-31&#39;</span>\\G
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
<span class="token keyword">EXPLAIN</span>: <span class="token operator">-</span><span class="token operator">&gt;</span> Filter: <span class="token punctuation">(</span><span class="token punctuation">(</span>orders<span class="token punctuation">.</span>O_ORDERDATE <span class="token operator">&gt;</span> <span class="token keyword">DATE</span><span class="token string">&#39;1994-01-01&#39;</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>orders<span class="token punctuation">.</span>O_ORDERDATE <span class="token operator">&lt;</span> <span class="token keyword">DATE</span><span class="token string">&#39;1994-12-31&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">592267.11</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">1876082</span><span class="token punctuation">)</span>
    <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token keyword">Table</span> scan <span class="token keyword">on</span> orders  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">592267.11</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">5799601</span><span class="token punctuation">)</span>

<span class="token comment">-- 强制使用索引</span>
<span class="token keyword">EXPLAIN</span> FORMAT<span class="token operator">=</span>tree 
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> orders <span class="token keyword">FORCE</span> <span class="token keyword">INDEX</span><span class="token punctuation">(</span>idx_orderdate<span class="token punctuation">)</span>
<span class="token keyword">WHERE</span> o_orderdate <span class="token operator">&gt;</span> <span class="token string">&#39;1994-01-01&#39;</span> 
<span class="token operator">AND</span> o_orderdate <span class="token operator">&lt;</span> <span class="token string">&#39;1994-12-31&#39;</span>\\G
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
<span class="token keyword">EXPLAIN</span>: <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token keyword">Index</span> range scan <span class="token keyword">on</span> orders <span class="token keyword">using</span> idx_orderdate<span class="token punctuation">,</span> <span class="token keyword">with</span> <span class="token keyword">index</span> condition: <span class="token punctuation">(</span><span class="token punctuation">(</span>orders<span class="token punctuation">.</span>O_ORDERDATE <span class="token operator">&gt;</span> <span class="token keyword">DATE</span><span class="token string">&#39;1994-01-01&#39;</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>orders<span class="token punctuation">.</span>O_ORDERDATE <span class="token operator">&lt;</span> <span class="token keyword">DATE</span><span class="token string">&#39;1994-12-31&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">844351.87</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">1876082</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>MySQL认为全表扫描的成本是 $592267.11$，而强制使用二级索引<code>idx_orderdate</code> 的成本为 $844351.87$</p></li><li><p><code>possible_keys: idx_orderdate</code>，说明优化器能够识别出索引，但 <code>type: ALL</code> ，说明使用全表扫描，并没有使用索引</p></li><li><p>根本原因在于：<strong>优化器认为通过主键进行全表扫描的成本比通过二级索引 <code>idx_orderdate</code> 的成本要低</strong></p></li></ul><blockquote><p><strong>为什么全表扫描比二级索引快？</strong></p></blockquote><ul><li>因为二级索引需要回表，当回表的记录数非常大时，成本就会比直接扫描慢</li><li>回表主要是IO的开销，也就是IO Cost的成本，我的理解需要计算读取索引键的成本+记录间比较的成本+磁盘IO成本+内存IO成本（读取索引键和IO都是包括扫描二级索引以及回表扫描聚簇索引），而全表扫描的话，需要计算的也是这四部分，但是读取索引键和IO只包括对聚簇索引的成本</li><li>使用二级索引比全表扫描记录间比较的次数更少，但是回表次数过多，导致IO次数和全表扫描差距不大的，记录间比较成本也较低，就会导致使用二级索引的成本比全表扫描的成本更高</li></ul><blockquote><p>第二条SQL的执行计划</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> orders 
<span class="token keyword">WHERE</span> o_orderdate <span class="token operator">&gt;</span> <span class="token string">&#39;1994-02-01&#39;</span> 
<span class="token operator">AND</span> o_orderdate <span class="token operator">&lt;</span> <span class="token string">&#39;1994-12-31&#39;</span>\\G
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
           id: <span class="token number">1</span>
  select_type: <span class="token keyword">SIMPLE</span>
        <span class="token keyword">table</span>: orders
   partitions: <span class="token boolean">NULL</span>
         <span class="token keyword">type</span>: range
possible_keys: idx_orderdate
          <span class="token keyword">key</span>: idx_orderdate
      key_len: <span class="token number">3</span>
          ref: <span class="token boolean">NULL</span>
         <span class="token keyword">rows</span>: <span class="token number">1633884</span>
     filtered: <span class="token number">100.00</span>
        Extra: <span class="token keyword">Using</span> <span class="token keyword">index</span> condition
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>第二条SQL是从2月份开始的，回表的次数比第一条SQL少，所以使用了二级索引</li></ul><p><strong>MySQL 会根据成本计算得到最优的执行计划，</strong> 根据不同条件选择最优执行计划，而不是同一类型一成不变的执行过程，这才是优秀的优化器该有的样子</p><h4 id="案例2-索引创建在有限状态上" tabindex="-1"><a class="header-anchor" href="#案例2-索引创建在有限状态上" aria-hidden="true">#</a> 案例2：索引创建在有限状态上</h4><p>B+ 树索引通常要建立在高选择性的字段或字段组合上，如订单 ID、日期等，因为这样每个字段值大多并不相同。</p><p>对于性别这样的字段，其值只有男女i郎中，哪怕记录数再多也只有两个值，这是低选择性的字段，因此无须在性别字段上创建索引。</p><blockquote><p><strong>所有的低选择性字段都不需要建立索引吗？</strong></p></blockquote><p>在有些低选择性的列上，是有必要创建索引的。比如电商的核心业务表 <code>orders</code>，其有字段 <code>o_orderstatus</code>，表示订单的当前状态。</p><p>字段 <code>o_orderstatus</code> 的状态是有限的，一般仅为已完成、支付中、超时已关闭这几种</p><ul><li>电商业务中需要定期扫描字段<code>o_orderstatus</code>为支付中的订单，如何强制让其关闭，从而释放内存，给其他有需求的买家购买</li></ul><p>通常订单状态绝大部分都是已完成，只有绝少部分因为系统故障原因，会在 15 分钟后还没有完成订单，<strong>因此订单状态是存在数据倾斜的</strong></p><p>这时，虽然订单状态是低选择性的，但是由于其有数据倾斜，且我们只是从索引查询少量数据，因此可以对订单状态创建索引</p><blockquote><p><strong>数据库怎么知道存的数据是存在数据倾斜的？</strong></p></blockquote><p>由于字段 <code>o_orderstatus</code> 仅有三个值，分别为 ‘O’、’P’、’F’。</p><p>但 MySQL 并不知道这三个列的分布情况，认为这三个值是平均分布的，但其实是这三个值存在严重倾斜</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> orders 
<span class="token keyword">WHERE</span> o_orderstatus <span class="token operator">=</span> <span class="token string">&#39;P&#39;</span>\\G

<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
           id: <span class="token number">1</span>
  select_type: <span class="token keyword">SIMPLE</span>
        <span class="token keyword">table</span>: orders
   partitions: <span class="token boolean">NULL</span>
         <span class="token keyword">type</span>: <span class="token keyword">ALL</span>
possible_keys: <span class="token boolean">NULL</span>
          <span class="token keyword">key</span>: <span class="token boolean">NULL</span>
      key_len: <span class="token boolean">NULL</span>
          ref: <span class="token boolean">NULL</span>
         <span class="token keyword">rows</span>: <span class="token number">5799601</span>
     filtered: <span class="token number">50.00</span>
        Extra: <span class="token keyword">Using</span> <span class="token keyword">where</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> o_orderstatus<span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> 
<span class="token keyword">FROM</span> orders <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> o_orderstatus<span class="token punctuation">;</span>

<span class="token operator">+</span><span class="token comment">---------------+----------+</span>
<span class="token operator">|</span> o_orderstatus <span class="token operator">|</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------------+----------+</span>
<span class="token operator">|</span> F             <span class="token operator">|</span>  <span class="token number">2923619</span> <span class="token operator">|</span>
<span class="token operator">|</span> O             <span class="token operator">|</span>  <span class="token number">2923597</span> <span class="token operator">|</span>
<span class="token operator">|</span> P             <span class="token operator">|</span>   <span class="token number">152784</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------------+----------+</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以利用MySQL8.0的直方图功能，创建一个直方图，让优化器知道数据的分布，从而更好的选择执行计划</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">ANALYZE</span> <span class="token keyword">TABLE</span> orders 
<span class="token keyword">UPDATE</span> HISTOGRAM <span class="token keyword">ON</span> o_orderstatus<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>创建完直方图之后，MySQL会收集到字段<code>o_orderstatus</code>的数值分布</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> v <span class="token keyword">value</span><span class="token punctuation">,</span> CONCAT<span class="token punctuation">(</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">-</span> LAG<span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&#39;%&#39;</span><span class="token punctuation">)</span> ratio
<span class="token keyword">FROM</span> information_schema<span class="token punctuation">.</span>column_statistics<span class="token punctuation">,</span> 
JSON_TABLE<span class="token punctuation">(</span>histogram<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token string">&#39;$.buckets&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;$[*]&#39;</span> <span class="token keyword">COLUMNS</span><span class="token punctuation">(</span>v <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span> PATH <span class="token string">&#39;$[0]&#39;</span><span class="token punctuation">,</span> c <span class="token keyword">double</span> PATH <span class="token string">&#39;$[1]&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> hist
<span class="token keyword">WHERE</span> column_name <span class="token operator">=</span> <span class="token string">&#39;o_orderstatus&#39;</span><span class="token punctuation">;</span>

<span class="token operator">+</span><span class="token comment">-------+-------+</span>
<span class="token operator">|</span> <span class="token keyword">value</span> <span class="token operator">|</span> ratio <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">-------+-------+</span>
<span class="token operator">|</span> F     <span class="token operator">|</span> <span class="token number">49</span><span class="token operator">%</span>   <span class="token operator">|</span>
<span class="token operator">|</span> O     <span class="token operator">|</span> <span class="token number">48.5</span><span class="token operator">%</span> <span class="token operator">|</span>
<span class="token operator">|</span> P     <span class="token operator">|</span> <span class="token number">2.5</span><span class="token operator">%</span>  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">-------+-------+</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>可以看到P的订单只占了2.5%</li><li>再去查询状态为P的订单就会使用索引了</li></ul><h2 id="索引的应用" tabindex="-1"><a class="header-anchor" href="#索引的应用" aria-hidden="true">#</a> 索引的应用</h2><h3 id="索引的优劣势" tabindex="-1"><a class="header-anchor" href="#索引的优劣势" aria-hidden="true">#</a> 索引的优劣势</h3><blockquote><p><strong>优势</strong></p></blockquote><ul><li>整个数据库中，数据表的<strong>查询速度直线提升</strong>，数据量越大时效果越明显。</li><li>通过创建<strong>唯一索引</strong>，可以<strong>确保数据表中的数据唯一性</strong>，无需额外建立唯一约束。</li><li>在使用<strong>分组和排序</strong>时，同样可以显著<strong>减少</strong><code>SQL</code>查询的<strong>分组和排序的时间</strong>。</li><li><strong>连表查询</strong>时，<strong>基于主外键字段上建立索引</strong>，可以带来十分明显的性能提升。</li><li>索引默认是<code>B+Tree</code>有序结构，基于索引字段做<strong>范围查询时，效率会明显提高</strong>。</li><li>从<code>MySQL</code>整体架构而言，<strong>减少了查询<code>SQL</code>的执行时间，提高了数据库整体吞吐量。</strong></li></ul><blockquote><p><strong>劣势</strong></p></blockquote><ul><li>建立索引会生成本地磁盘文件，需要<strong>额外的空间存储索引数据</strong>，<strong>磁盘占用率会变高</strong>。</li><li>写入数据时，需要<strong>额外维护索引结构</strong>，增、删、改数据时，都需要额外操作索引。</li><li>写入数据时维护索引需要<strong>额外的时间开销</strong>，执行<strong>写<code>SQL</code>时效率会降低，性能会下降</strong>。</li></ul><h3 id="正确创建索引" tabindex="-1"><a class="header-anchor" href="#正确创建索引" aria-hidden="true">#</a> 正确创建索引</h3><h4 id="回表问题" tabindex="-1"><a class="header-anchor" href="#回表问题" aria-hidden="true">#</a> 回表问题</h4><p>回表动作会导致额外的查询开销，因此尽量可以基于主键做查询</p><p>如果实在需要使用非主键字段查询，那么尽量要写明查询的结果字段，而并非使用<code>*</code>。</p><p>因为如果需要的字段在二级索引中有存储完整的数据，那么就可以利用索引覆盖，从而避免回表。</p><p>不过当二级索引中的字段包含*所有的字段，也可以避免回表，但是一旦增加了新的不需要获取的字段，就会有额外的回表开销。</p><h4 id="建立索引的原则" tabindex="-1"><a class="header-anchor" href="#建立索引的原则" aria-hidden="true">#</a> 建立索引的原则</h4><p>建立索引仅考虑一个字段是否被经常用于查询是不够的，往往一个合适的索引需要更为细致与长远的思考</p><blockquote><p><strong>建议建立索引的情况</strong></p></blockquote><ol><li>经常<strong>频繁用作查询条件的字段</strong>应酌情考虑为其创建索引。</li><li>表的<strong>主外键</strong>或<strong>连表字段</strong>，<strong>必须建立索引</strong>，因为能很大程度提升连表查询的性能。</li><li>建立索引的字段，一般值的<strong>区分性要足够高</strong>，这样才能提高索引的检索效率。</li><li>建立索引的字段，<strong>值不应该过长</strong><ul><li>如果<strong>较长的字段要建立索引，可以选择前缀索引</strong>。</li></ul></li><li>建立<strong>联合索引</strong>，应当<strong>遵循最左前缀原则</strong>，将<strong>多个字段之间按优先级顺序组合</strong>。</li><li><strong>经常根据范围取值、排序、分组的字段</strong>应建立索引，因为索引有序，能加快排序时间。</li><li>对于<strong>唯一索引</strong>，如果确认<strong>不会</strong>利用该字段<strong>排序</strong>，那可以将结构<strong>改为<code>Hash</code>结构。</strong></li><li>尽量<strong>使用联合索引代替单值索引</strong>，联合索引比多个单值索引查询效率要高。</li></ol><blockquote><p><strong>不建议建立索引的情况</strong></p></blockquote><ol><li><strong>值经常会增删改的字段</strong>，不合适建立索引，因为每次改变后需维护索引结构。</li><li>一个<strong>字段存在大量的重复值时</strong>，不适合建立索引，比如之前举例的性别字段。</li><li>索引不能参与计算，因此<strong>经常带函数查询的字段</strong>，并不适合建立索引。</li><li>一张表中的<strong>索引数量并不是越多越好</strong>，一般控制在<code>3</code>，最多不能超过<code>5</code>。</li><li>建立<strong>联合索引</strong>时，一定要考虑优先级，<strong>查询频率最高的字段应当放首位</strong>。</li><li>当<strong>表的数据较少</strong>，不应当建立索引，因为数据量不大时，维护索引反而开销更大。</li><li>索引的<strong>字段值无序时</strong>，不推荐建立索引，因为会造成页分裂，尤其是主键索引。</li></ol><h4 id="冗余的索引" tabindex="-1"><a class="header-anchor" href="#冗余的索引" aria-hidden="true">#</a> 冗余的索引</h4><p>大部分情况下都不需要冗余索引，应该尽量扩展已有的索引而不是创建新索引：</p><ul><li>不同类型的索引，比如全文索引、哈希索引</li><li>冗余索引是指，在修改索引的时候，直接通过添加一个新的(A, B)索引，而不是直接在原有的索引(A)上进行扩展</li></ul><p>但是当扩展已有的索引会导致索引变得过大，从而影响索引的查询效率时，就需要使用冗余索引。</p><blockquote><p><strong>怎么处理无用的冗余索引？</strong></p></blockquote><p>删除无用的索引即可</p><p>首先需要知道哪些索引是无用的，可以使用<code>Shlomi Noach</code> 的<code>common_schema</code>中的一些视图来定位。</p><p>也可以通过自己编写复杂的SQL去测试。</p><h3 id="正确使用索引" tabindex="-1"><a class="header-anchor" href="#正确使用索引" aria-hidden="true">#</a> 正确使用索引</h3><h4 id="使用索引的原则" tabindex="-1"><a class="header-anchor" href="#使用索引的原则" aria-hidden="true">#</a> 使用索引的原则</h4><ol><li>查询<code>SQL</code>中<strong>尽量不要使用<code>OR</code>关键字</strong>，可以<strong>使用多<code>SQL</code>或子查询代替</strong>。</li><li><strong>模糊查询尽量不要以<code>%</code>开头</strong>，如果<strong>实在要实现这个功能可以建立全文索引</strong>。</li><li>编写<code>SQL</code>时一定要<strong>注意字段的数据类型</strong>，否则<code>MySQL</code>的隐式转换会导致索引失效。</li><li>一定<strong>不要</strong>在编写<code>SQL</code>时<strong>让索引字段执行计算工作</strong>，尽量将计算工作放在客户端中完成。</li><li>对于索引字段尽量不要使用计算类函数，一定要使用时请记得<strong>将函数计算放在<code>=</code>后面</strong>。</li><li><strong>多条件的查询</strong><code>SQL</code>一定要<strong>使用联合索引中的第一个字段</strong>，否则会打破最左匹配原则。</li><li>对于需要<strong>对比多个字段的查询业务</strong>时，可以<strong>拆分为连表查询</strong>，使用临时表代替。</li><li>在<code>SQL</code>中<strong>不要使用反范围性的查询条件</strong>，大部分反范围性、不等性查询都会让索引失效。</li></ol><h4 id="利用索引覆盖" tabindex="-1"><a class="header-anchor" href="#利用索引覆盖" aria-hidden="true">#</a> 利用索引覆盖</h4><ul><li>写SQL的时候，尽量不要写*，指定需要的列，当<strong>正好有索引包含了需要的列时，就不需要回表查询</strong></li><li>查询的列如果被联合索引覆盖了 <ul><li>查询条件符合最左匹配原则 ——&gt; 范围扫描二级索引</li><li>查询条件不符合最左匹配原则 ——&gt; 扫描整个二级索引</li></ul></li></ul><h4 id="利用索引下推" tabindex="-1"><a class="header-anchor" href="#利用索引下推" aria-hidden="true">#</a> 利用索引下推</h4><p>索引下推就是将<code>Server</code>层筛选数据的工作，下推到引擎层处理。</p><ul><li>创建联合索引的时候，可以将经常需要范围查询的列放到索引的最后，因为根据最左匹配原则，联合索引遇到范围查询就会停止判断</li><li>如果把需要范围查询的列放在最后，就可以使用索引下推，减少回表的次数</li></ul><h4 id="利用mrr机制" tabindex="-1"><a class="header-anchor" href="#利用mrr机制" aria-hidden="true">#</a> 利用MRR机制</h4><p>(Multi-Range Read)简称为<code>MRR</code>机制，这也是和索引下推一同在<code>MySQL5.6</code>版本中引入的性能优化措施</p><p>一般来说，在实际业务中我们应当尽量通过索引覆盖的特性，减少回表操作以降低<code>IO</code>次数</p><p>但在很多时候往往又不得不做回表才能查询到数据，但回表显然会导致产生大量磁盘<code>IO</code></p><p>同时更严重的一点是：还会产生大量的离散<code>IO</code></p><ul><li>聚簇索引按照主键排序的数据跟二级索引按照索引列排序的数据顺序不一定是一样的</li><li>按照二级索引取出来的主键id去聚簇索引里面找就有可能是非顺序的，从而导致重复进入同一个页取数据</li></ul><blockquote><p><strong>怎么理解</strong></p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">\`</span>zz_student_score<span class="token punctuation">\`</span></span> <span class="token keyword">WHERE</span> <span class="token identifier"><span class="token punctuation">\`</span>score<span class="token punctuation">\`</span></span> <span class="token operator">BETWEEN</span> <span class="token number">0</span> <span class="token operator">AND</span> <span class="token number">59</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol><li>先在成绩字段的索引上找到<code>0</code>分的节点，然后拿着<code>ID</code>去回表得到成绩零分的学生信息。</li><li>再次回到成绩索引，继续找到所有<code>1</code>分的节点，继续回表得到<code>1</code>分的学生信息。</li><li>再次回到成绩索引，继续找到所有<code>2</code>分的节点......</li><li>周而复始，不断重复这个过程，直到将<code>0~59</code>分的所有学生信息全部拿到为止。</li></ol><p>如果成绩<code>0~5</code>分的表数据，位于磁盘空间的<code>page_01</code>页上，而成绩为<code>5~10</code>分的数据，位于磁盘空间的<code>page_02</code>页上，成绩为<code>10~15</code>分的数据，又位于磁盘空间的<code>page_01</code>页上。此时回表查询时就会导致在<code>page_01、page_02</code>两页空间上来回切换</p><p>但是<code>0~5、10~15</code>分的数据完全可以合并，然后读一次<code>page_01</code>就可以了，既能减少<code>IO</code>次数，同时还避免了离散<code>IO</code>。</p><blockquote><p><strong>MRR机制是怎么解决这个问题的？</strong></p></blockquote><ol><li><code>MRR</code>机制中，对于辅助索引中查询出的<code>ID</code>，会将其<strong>放到缓冲区</strong>的<code>read_rnd_buffer</code>中</li><li>然后等全部的索引检索工作完成后，或者缓冲区中的数据达到<code>read_rnd_buffer_size</code>大小时，此时<code>MySQL</code>会<strong>对缓冲区中的数据排序，从而得到一个有序的<code>ID</code>集合</strong>：<code>rest_sort</code>，</li><li>最终再根据<strong>顺序<code>IO</code>去聚簇/主键索引中回表查询数据</strong>。</li></ol><h4 id="利用index-skip-scan" tabindex="-1"><a class="header-anchor" href="#利用index-skip-scan" aria-hidden="true">#</a> 利用Index Skip Scan</h4><blockquote><p><strong>索引跳跃式扫描</strong></p></blockquote><p>联合索引中讲过，下面这个SQL用不了联合索引<code>(A,B,C)</code></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">\`</span>tb_xx<span class="token punctuation">\`</span></span> <span class="token keyword">WHERE</span> B <span class="token operator">=</span> <span class="token identifier"><span class="token punctuation">\`</span>xxx<span class="token punctuation">\`</span></span> <span class="token operator">AND</span> C <span class="token operator">=</span> <span class="token identifier"><span class="token punctuation">\`</span>xxx<span class="token punctuation">\`</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在<code>MySQL8.x</code>版本中加入了一个新的优化机制，也就是索引跳跃式扫描</p><p>这种机制使得咱们即使查询条件中，没有使用联合索引的第一个字段，也依旧可以使用联合索引</p><blockquote><p><strong>跳跃扫描究竟是怎么实现的呢？</strong></p></blockquote><p>跳跃扫描并不是真正的“跳过了”第一个字段，而是优化器为你重构了<code>SQL</code></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">\`</span>tb_xx<span class="token punctuation">\`</span></span> <span class="token keyword">WHERE</span> B <span class="token operator">=</span> <span class="token identifier"><span class="token punctuation">\`</span>xxx<span class="token punctuation">\`</span></span> <span class="token operator">AND</span> C <span class="token operator">=</span> <span class="token identifier"><span class="token punctuation">\`</span>xxx<span class="token punctuation">\`</span></span>
<span class="token keyword">UNION</span> <span class="token keyword">ALL</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">\`</span>tb_xx<span class="token punctuation">\`</span></span> <span class="token keyword">WHERE</span> B <span class="token operator">=</span> <span class="token identifier"><span class="token punctuation">\`</span>xxx<span class="token punctuation">\`</span></span> <span class="token operator">AND</span> C <span class="token operator">=</span> <span class="token identifier"><span class="token punctuation">\`</span>xxx<span class="token punctuation">\`</span></span> <span class="token operator">AND</span> A <span class="token operator">=</span> <span class="token string">&quot;yyy&quot;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">\`</span>tb_xx<span class="token punctuation">\`</span></span> <span class="token keyword">WHERE</span> B <span class="token operator">=</span> <span class="token identifier"><span class="token punctuation">\`</span>xxx<span class="token punctuation">\`</span></span> <span class="token operator">AND</span> C <span class="token operator">=</span> <span class="token identifier"><span class="token punctuation">\`</span>xxx<span class="token punctuation">\`</span></span> <span class="token operator">AND</span> A <span class="token operator">=</span> <span class="token string">&quot;zzz&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>MySQL</code>优化器会自动对联合索引中的第一个字段的值去重，然后基于去重后的值全部拼接起来查一遍</p><blockquote><p><strong>有什么限制吗？</strong></p></blockquote><ul><li>多表联查无法触发</li><li>SQL条件中有分组操作无法触发</li><li>使用DISTICNT去重无法触发</li></ul><blockquote><p><strong>什么时候会触发索引跳跃式扫描</strong></p></blockquote><ul><li>只有在联合索引中<strong>第一列的唯一性比较差</strong>的情况下，也就是重复值较多，<strong>去重之后剩余的列值较少的情况</strong>，才会使用索引跳跃式扫描</li><li>如果第一列的唯一性很强，假设<strong>第一列就是唯一的</strong>，那么<strong>使用索引跳跃就相当于走一次全表</strong></li></ul><h3 id="维护索引和表" tabindex="-1"><a class="header-anchor" href="#维护索引和表" aria-hidden="true">#</a> 维护索引和表</h3><h4 id="找到并修复损坏的表" tabindex="-1"><a class="header-anchor" href="#找到并修复损坏的表" aria-hidden="true">#</a> 找到并修复损坏的表</h4><p>对于MyISAM而言，表损坏通常是系统崩溃导致的。其他硬气也会由于硬件问题、MySQL本身的缺陷或者操作系统的问题导致索引损坏。</p><p>损坏索引会导致：</p><ul><li>查询返回错误结果</li><li>莫名其妙的主键冲突</li><li>严重会导致数据库崩溃</li><li>也就是不应该发生的错误发生了</li></ul><blockquote><p><strong>找到并修复</strong></p></blockquote><ul><li>可以使用CHECK TABLE检查是否发生表损坏（但有的存储引擎不支持该命令）</li><li>可以使用REPAIR TABLE 命令修复损坏的表（但有的存储引擎不支持该命令）</li></ul><blockquote><p><strong>损坏的原因</strong></p></blockquote><p>InnoDB的设计让他损坏的概率更小。如果InnoDB的表发生了损坏，说明：</p><ul><li>有可能是数据库的硬件问题，例如磁盘或内存</li><li>或者是数据库管理员的错误，例如在MySQL外部操作了数据文件</li></ul>`,804),d={href:"http://www.percona.com/software/mysql-innodb-data-recovery-tools/",target:"_blank",rel:"noopener noreferrer"},u=a(`<h4 id="更新索引统计信息" tabindex="-1"><a class="header-anchor" href="#更新索引统计信息" aria-hidden="true">#</a> 更新索引统计信息</h4><blockquote><p>有兴趣了解更多就看高性能mysql第三版的P190，里面包括了InnoDB是怎么进行信息统计的</p></blockquote><p>MySQL查询优化器会通过两个API了解存储引擎索引值的分布信息，以决定如何使用索引，两个API如下：</p><ul><li>record_in_range()：通过向存储引擎传入两个边界值获取这个范围大概有多少条记录，MyISAM可以返回精确值</li><li>info()：返回各种类型的数据，包括索引的基数（有多少种列值）</li></ul><blockquote><p><strong>重新生成统计信息</strong></p></blockquote><p>运行ANALIYZE TABKE来重新生成统计信息，因为每种引擎统计信息的方式不同，所以要运行该命令的频率不同，每次运行的成本也不同：</p><ul><li>Menory不存储引擎统计信息</li><li>MyISAM将索引统计信息存储在磁盘种，执行一次该命令，需要进行一次全索引扫描统计索引基数，整个过程需要锁表</li><li>InnoDB不在磁盘存储索引统计信息，而是通过随机的索引访问进行评估并将其存储在内存中</li></ul><h4 id="减少索引和数据的碎片" tabindex="-1"><a class="header-anchor" href="#减少索引和数据的碎片" aria-hidden="true">#</a> 减少索引和数据的碎片</h4><p>有三种类型的数据碎片：</p><ul><li>行碎片 <ul><li>指数据行被存储为多个地方的多个片段中，即使查询只从索引中访问一行记录，行碎片也会导致性能下降</li></ul></li><li>行间碎片 <ul><li>行间碎片指逻辑上顺序的页，或者行在磁盘上不是顺序存储的</li><li>行间碎片注入全表扫描和聚簇索引扫描之类的操作有很大的影响</li></ul></li><li>剩余空间碎片 <ul><li>指数据页中有大量的空余空间，会导致服务器读取大量不需要的数据，从而造成浪费</li></ul></li></ul><p>可以通过执行 OPTIMIZE TABLE或者再导入的方式来重新整理数据。最新版本的InnoDB新增了“在线”添加和删除索引的功能，可以先删除，再重新创建索引的方式来消除索引的碎片化。</p><h2 id="索引总结" tabindex="-1"><a class="header-anchor" href="#索引总结" aria-hidden="true">#</a> 索引总结</h2><blockquote><p><strong>面试题</strong></p></blockquote><h3 id="什么是索引" tabindex="-1"><a class="header-anchor" href="#什么是索引" aria-hidden="true">#</a> 什么是索引？</h3><p>将数据库比喻为书本，那索引就是书前面的目录，通过目录可以快速定位到书中的内容</p><p>索引的定义是帮助存储引擎快速获取数据的一种数据结构</p><h3 id="什么是存储引擎" tabindex="-1"><a class="header-anchor" href="#什么是存储引擎" aria-hidden="true">#</a> 什么是存储引擎？</h3><p>存储引擎就是如何存储数据、如何为存储的数据建立索引、如何更新、查询数据等技术的实现方法</p><p>MySQL存储引擎有MyISAM、InnoDB、Memory等，其中InnoDB是MySQL5.5之后的默认存储引擎</p><h3 id="索引的分类" tabindex="-1"><a class="header-anchor" href="#索引的分类" aria-hidden="true">#</a> 索引的分类</h3><p>从四个角度进行分类</p><ol><li>按<strong>数据结构</strong>分类：B+树索引、哈希索引、全文索引</li><li>按<strong>物理存储</strong>分类：聚簇索引、二级索引</li><li>按<strong>字段特性</strong>分类：主键索引、唯一索引、普通索引、前缀索引</li><li>按<strong>字段个数</strong>分类：单列索引、联合索引</li></ol><h3 id="三种常见存储引擎支持的索引有哪些" tabindex="-1"><a class="header-anchor" href="#三种常见存储引擎支持的索引有哪些" aria-hidden="true">#</a> 三种常见存储引擎支持的索引有哪些？</h3><p>从数据结构的角度来看，MySQL 常见索引有 B+Tree 索引、HASH 索引、Full-Text 索引。</p><p>每一种存储引擎支持的索引类型不一定相同</p><table><thead><tr><th>索引类型</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree</td><td>√</td><td>√</td><td>√</td></tr><tr><td>HASH</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Full-Text</td><td>√</td><td>√</td><td>×</td></tr></tbody></table><ul><li>InnoDB不支持哈希索引，但是在内存结构中有一个自适应的哈希索引（详情见<code>存储引擎/InnoDB简介/InnoDB数据读取</code>）</li><li>InnoDB在5.6版本之后支持Full-Text全文索引</li></ul><h3 id="innodb如何自动为我们的表创建聚簇索引" tabindex="-1"><a class="header-anchor" href="#innodb如何自动为我们的表创建聚簇索引" aria-hidden="true">#</a> InnoDB如何自动为我们的表创建聚簇索引？</h3><p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li></ul><h3 id="存储数据的b-树是什么样子的" tabindex="-1"><a class="header-anchor" href="#存储数据的b-树是什么样子的" aria-hidden="true">#</a> 存储数据的B+树是什么样子的？</h3><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231228004531229.png" alt="image-20231228004531229" tabindex="0" loading="lazy"><figcaption>image-20231228004531229</figcaption></figure><ul><li>B+Tree是一棵多叉树，叶子节点存放数据，非叶子节点存放索引</li><li>每个节点里面的数据都是按主键顺序存放的</li><li>每一层父节点的索引值都会出现在下层子节点的索引值中。因此在叶子节点里面，包括了所有索引值的信息</li><li>每个叶子节点都有两根指针，指向下一个叶子节点和上一个叶子节点，形成双向链表</li></ul><p><strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong></p><h3 id="聚簇索引的查询过程-1" tabindex="-1"><a class="header-anchor" href="#聚簇索引的查询过程-1" aria-hidden="true">#</a> 聚簇索引的查询过程</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> product <span class="token keyword">where</span> id<span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol><li>将 5 与根节点的索引数据 (1，10，20) 比较，5 在 1 和 10 之间，所以根据 B+Tree的搜索逻辑，找到第二层的索引数据 (1，4，7)；</li><li>在第二层的索引数据 (1，4，7) 中进行查找，因为 5 在 4 和 7 之间，所以找到第三层的索引数据（4，5，6）；</li><li>在叶子节点的索引数据 (4，5，6) 中进行查找，然后我们找到了索引值为 5 的行数据。</li></ol><p>数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I/O 操作。那么上面的整个查询过程一共经历了 3 个节点，也就是进行了 3 次 I/O 操作。</p><p>B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以<strong>B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次</strong></p><h3 id="二级索引的查询过程" tabindex="-1"><a class="header-anchor" href="#二级索引的查询过程" aria-hidden="true">#</a> 二级索引的查询过程</h3><blockquote><p>将<code>product_no</code>商品编码设置为二级索引</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231228005750012.png" alt="image-20231228005750012" tabindex="0" loading="lazy"><figcaption>image-20231228005750012</figcaption></figure><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> product <span class="token keyword">where</span> product_no <span class="token operator">=</span> <span class="token string">&#39;0002&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol><li>先检索二级索引的B+树，检索到对应的叶子节点，获取到符合条件的主键值</li><li>利用获取到的主键，通过主键索引的B+树，查询到对应的叶子节点，获取整行记录</li></ol><p><strong>这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据</strong></p><p><strong>当查询的数据能直接在二级索引的叶子节点中获取到时就不用回表了，这种情况称为覆盖索引</strong></p><h3 id="为什么mysql选择b-tree作为索引的数据结构" tabindex="-1"><a class="header-anchor" href="#为什么mysql选择b-tree作为索引的数据结构" aria-hidden="true">#</a> 为什么MySQL选择B+Tree作为索引的数据结构</h3><p><strong>B+Tree vs B Tree</strong></p><ol><li>B+Tree 只在叶子节点存储数据，而 BTree 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。</li><li>B+Tree 叶子节点采用双向链表连接，非常有利于MySQL中的范围查询，BTree无法做到这一带你</li></ol><p><strong>B+Tree vs 二叉树</strong></p><ol><li>二叉树每个节点只能由两个子节点，其高度会比B+Tree高出很多，这样就导致更多的磁盘I/O</li><li>二叉树的搜索复杂度是$O(logN)$，B+Tree的搜索复杂度是$O(log_dN)$，d是节点允许的最大子节点个数 <ul><li>实际应用中，d值是大于100的，这也就保证了即使数据达到千万级别，B+Tree的高度也依然能维持在3~4层左右，一次查询只需要3~4次磁盘I/O</li></ul></li></ol><p><strong>B+Tree vs Hash</strong></p><ol><li>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)，但是Hash不适合做范围查询，它更适合做等值查询</li></ol><p><strong>B+Tree vs 跳表</strong></p><ol><li>一般来说，存等量数据的情况下，B+Tree的层高会比跳表矮很多，也就是说B+Tree会用更少的磁盘I/O</li><li>跳表在极端情况下会退化成链表，查询效率也就变回$O(N)$，数据量大的情况下查询一次的磁盘I/O消耗会很多</li></ol><blockquote><p><strong>为什么Redis使用跳表而不使用B+Tree？</strong></p></blockquote><ol><li>B+Tree的优势在于层高矮，在于极少量的磁盘I/O可以完成大量数据中的查询操作，但是Redis是基于内存的数据库，内存I/O的消耗很少，对Redis来说这个优势不是很明显</li><li>插入数据时需要维护B+Tree的结构，这也是一个不小的开销，而对于Redis来说，用这个开销来换那微不足道的I/O增益显然性价比是不高的</li><li>并且跳表的实现也比B+Tree简单，维护也简单，符合Redis的原则</li></ol><h3 id="什么是覆盖索引" tabindex="-1"><a class="header-anchor" href="#什么是覆盖索引" aria-hidden="true">#</a> 什么是覆盖索引</h3><p>在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引</p><h3 id="联合索引的查询过程" tabindex="-1"><a class="header-anchor" href="#联合索引的查询过程" aria-hidden="true">#</a> 联合索引的查询过程</h3><p>联合索引查询数据时，先按最左边字段值进行比较，当它相同时，再按下一个字段值比较</p><h3 id="最左匹配原则-1" tabindex="-1"><a class="header-anchor" href="#最左匹配原则-1" aria-hidden="true">#</a> 最左匹配原则</h3><p>按照最左优先的方式进行索引的匹配，</p><ul><li>例如：有<code>(a,b,c)</code>联合索引，如果查询条件中没有出现a，则无法使用该索引</li></ul><p>在使用联合索引进行查询的时候，如果不遵循最左匹配原则，联合索引就会失效</p><blockquote><p><strong>最左匹配原则的原理</strong></p></blockquote><ul><li>联合索引是按照从左数第一个索引列值排序的，第一个索引列值相同的情况下，按第二个索引列值排序，第二个索引列值也相同的情况下，按第三个索引列值排序，以此类推。</li><li>所以如果没有左边索引列的条件，该联合索引的B+Tree中右边索引列并不是全局有序的，那也就用不了了。使用索引的前提是索引里的Key有序</li></ul><h3 id="联合索引范围查询" tabindex="-1"><a class="header-anchor" href="#联合索引范围查询" aria-hidden="true">#</a> 联合索引范围查询</h3><p>两种情况，一种是开区间的范围查询，一种是开区间的范围查询</p><p><code>BETWEEN</code>可以看成左闭右闭的范围查询</p><p>索引：<code>(a, b)</code></p><blockquote><p><strong>开区间的范围查询</strong></p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t WHERR a <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">AND</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol><li>定位到<code>a &gt; 1</code>的第一条记录</li><li>遍历<code>a &gt; 1</code>的所有记录，逐一判断b是否等于2，等于则回表，不等于则不回表（索引下推）</li><li>将取出来的所有主键ID做排序，然后统一回表（MRR）</li></ol><blockquote><p><strong>闭区间的范围查询</strong></p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t WHERR a <span class="token operator">&gt;=</span> <span class="token number">1</span> <span class="token operator">AND</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以理解为将这句SQL重构为下面这句</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t WHERR a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">AND</span> b <span class="token operator">=</span> <span class="token number">2</span>
<span class="token keyword">UNION</span> <span class="token keyword">ALL</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t WHERR a <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">AND</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>定位到<code>a = 1 AND b = 2</code>的记录，遍历取出所有符合条件的主键ID</li><li>定位到<code>a &gt; 1</code>的第一条记录</li><li>遍历<code>a &gt; 1</code>的所有记录，逐一判断b是否等于2，等于则取出，不等于则不取出（索引下推）</li><li>将取出来的所有主键ID做排序，然后统一回表（MRR）</li></ol><blockquote><p><strong>字符串模糊查询</strong></p></blockquote><p>索引：<code>(name, age)</code></p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>SELECT * FROM t WHERE name like &#39;j%&#39; and age = 22;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>因为字符串的匹配规则是按照字符逐个匹配的，所以索引可以定位到第一个字符为&#39;j&#39;的记录</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231228123734634.png" alt="image-20231228123734634" tabindex="0" loading="lazy"><figcaption>image-20231228123734634</figcaption></figure><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231228123803277.png" alt="image-20231228123803277" tabindex="0" loading="lazy"><figcaption>image-20231228123803277</figcaption></figure><ol><li>定位到符合前缀为&#39;j&#39;的第一条记录，遍历到不符合条件停止，获得name条件下的记录范围</li><li>在name条件下的记录范围中，存在重复的名字，重复名字的记录是按age排序的，所以也可以使用age字段快速定位到相应的记录</li><li>取出符合条件的所有主键id然后回表</li></ol><h3 id="索引区分度" tabindex="-1"><a class="header-anchor" href="#索引区分度" aria-hidden="true">#</a> 索引区分度</h3><p>也叫选择性，实际开发工作中<strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231228124316465.png" alt="image-20231228124316465" tabindex="0" loading="lazy"><figcaption>image-20231228124316465</figcaption></figure><p>因为如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是&quot;30%&quot;）很高的时候，它一般会忽略索引，进行全表扫描。</p><h3 id="联合索引优化排序" tabindex="-1"><a class="header-anchor" href="#联合索引优化排序" aria-hidden="true">#</a> 联合索引优化排序</h3><p>给ORDER BY的字段加个索引，并且让要排序的SQL能够使用到该索引</p><p>避免使用文件排序filesort（Extra列中出现Using filesort）</p><h3 id="索引的缺点" tabindex="-1"><a class="header-anchor" href="#索引的缺点" aria-hidden="true">#</a> 索引的缺点</h3><ul><li>需要占用物理空间，数量越大，占用空间越大；</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li><li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</li></ul><h3 id="什么时候适用索引" tabindex="-1"><a class="header-anchor" href="#什么时候适用索引" aria-hidden="true">#</a> 什么时候适用索引？</h3><ul><li>字段有唯一性限制的 <ul><li>InnoDB会自动给有唯一约束的字段建立唯一索引</li></ul></li><li>经常用于 <code>WHERE</code> 查询条件的字段 <ul><li>如果查询条件不是一个字段，可以建立联合索引。</li></ul></li><li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段</li></ul><h3 id="什么时候不适用索引" tabindex="-1"><a class="header-anchor" href="#什么时候不适用索引" aria-hidden="true">#</a> 什么时候不适用索引</h3><ul><li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段</li><li>字段中存在大量重复数据，不需要创建索引 ——&gt; 区分度低的</li><li>表数据太少的时候，不需要创建索引；</li><li>经常更新的字段不用创建索引</li></ul><h3 id="有什么优化索引的方法" tabindex="-1"><a class="header-anchor" href="#有什么优化索引的方法" aria-hidden="true">#</a> 有什么优化索引的方法</h3><ul><li>前缀索引优化</li><li>覆盖索引优化</li><li>自增主键索引</li><li>索引列NOT NULL</li><li>防止索引失效</li></ul><h3 id="前缀索引优化" tabindex="-1"><a class="header-anchor" href="#前缀索引优化" aria-hidden="true">#</a> 前缀索引优化</h3><p>使用某个字段中字符串的前几个字符建立索引</p><p>前缀索引可以减小索引字段大小，增加一个索引页中存储的索引值，有效提高索引的查询速度</p><blockquote><p>缺点</p></blockquote><ul><li>order by 就无法使用前缀索引；</li><li>无法把前缀索引用作覆盖索引</li></ul><h3 id="覆盖索引优化" tabindex="-1"><a class="header-anchor" href="#覆盖索引优化" aria-hidden="true">#</a> 覆盖索引优化</h3><p>覆盖索引是查询的字段在二级索引里面就能取到，不用进行回表</p><p>使用覆盖索引的好处就是，不用回表，也就减少了大量的 I/O 操作</p><h3 id="自增主键索引" tabindex="-1"><a class="header-anchor" href="#自增主键索引" aria-hidden="true">#</a> 自增主键索引</h3><p>InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。</p><p>也就是说，同一个叶子节点内的各个数据是按主键顺序存放的</p><p>因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中</p><ul><li><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是<u>追加操作</u>，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</li><li><strong>如果我们使用非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为**<u>页分裂</u>**。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</li></ul><h3 id="索引列not-nul" tabindex="-1"><a class="header-anchor" href="#索引列not-nul" aria-hidden="true">#</a> 索引列NOT NUL</h3><ol><li>索引列存在 NULL 就会导致<strong>优化器在做索引选择的时候更加复杂，更加难以优化</strong>，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。</li><li>NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式 中<strong>至少会用 1 字节空间存储 NULL 值列表</strong></li></ol><h3 id="防止索引失效" tabindex="-1"><a class="header-anchor" href="#防止索引失效" aria-hidden="true">#</a> 防止索引失效</h3><ul><li>当我们使用<strong>左或者左右模糊匹配</strong>的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中<strong>对索引列做了计算、函数、类型转换操作</strong>，这些情况下都会造成索引失效；</li><li>联合索引要能正确使用需要遵循<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 <strong>OR 前的条件列是索引列，而在 OR 后的条件列不是索引列</strong>，那么索引会失效。</li></ul><hr>`,119);function k(g,h){const e=p("ExternalLinkIcon");return t(),l("div",null,[c,s("p",null,[n("还可以使用开源的InnoDB数据恢复工具箱直接从InnoDB数据文件恢复出数据，下载地址:"),s("a",d,[n("InnoDB数据恢复工具箱"),r(e)])]),u])}const v=o(i,[["render",k],["__file","索引.html.vue"]]);export{v as default};
