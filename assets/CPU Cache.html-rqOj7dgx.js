import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as n,c as s,f as e}from"./app-OTaO6_y0.js";const o={},p=e(`<h1 id="cpu-cache" tabindex="-1"><a class="header-anchor" href="#cpu-cache" aria-hidden="true">#</a> CPU Cache</h1><blockquote><p>CPU高速缓存</p></blockquote><h2 id="cpu-cache的速度" tabindex="-1"><a class="header-anchor" href="#cpu-cache的速度" aria-hidden="true">#</a> CPU Cache的速度</h2><p>根据摩尔定律，CPU的访问速度每18个月就会翻番，相当于每年增长60%左右，内存速度平均每年只会增长7%左右</p><p>到现在，一次内存访问所需时间是 <code>200~300</code> 多个时钟周期，这意味着 CPU 和内存的访问速度已经相差 <code>200~300</code> 多倍了。</p><p>为了弥补 CPU 与内存两者之间的性能差异，就在 CPU 内部引入了 CPU Cache，也称高速缓存</p><blockquote><p><strong>摩尔定律：</strong></p><p>摩尔定律是由英特尔创始人戈登·摩尔（Gordon Moore）于1965年提出的观察和预测，他指出集成电路上可容纳的晶体管数量每隔大约18个月就会翻一番，而成本保持不变。简单来说，摩尔定律表达了集成电路的复杂度和性能随时间呈指数增长的趋势。</p></blockquote><p>CPU Cache分为三个不同的等级</p><ul><li><p>L1 Cache</p></li><li><p>L2 Cache</p></li><li><p>L3 Cache</p></li></ul><p>CPU Cache使用的材料比内存昂贵，所以<strong>CPU Cache一般也会比较小，通常以KB或者MB来计算</strong></p><blockquote><p>由于 CPU Cache 所使用的材料是 SRAM，价格比内存使用的 DRAM 高出很多，在当今每生产 1 MB 大小的 CPU Cache 需要 7 美金的成本，而内存只需要 0.015 美金的成本，成本方面相差了 466 倍，所以 CPU Cache 不像内存那样动辄以 GB 计算，它的大小是以 KB 或 MB 来计算的。</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231222110548621.png" alt="image-20231222110548621" tabindex="0" loading="lazy"><figcaption>image-20231222110548621</figcaption></figure><ul><li><p>L1 Cache通常会分为<strong>数据缓存</strong>和<strong>指令缓存</strong></p><ul><li>这意味着<strong>数据和指令在L1 Cache这里是分开缓存的</strong></li><li>它俩的大小通常是一样的</li></ul></li><li><p>L3 Cache 比 L1 Cache 和 L2 Cache 都要大得多</p><ul><li>因为<strong>L1 Cache 和 L2 Cache 都是每个CPU核心独有的</strong></li><li><strong>L3 Cache 是多个CPU核心共享的</strong></li></ul></li><li><p>程序执行的时候，会<strong>先将内存中的数据加载到共享的 L3 Cache 中</strong>，<strong>再加载到每个核心独有的 L2 Cache 中</strong>，<strong>最后进入到最快的 L1 Cache</strong> ，<strong>之后才会被CPU读取</strong></p></li><li><p><strong>越靠近CPU核心的缓存访问速度越快</strong></p></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231222110931164.png" alt="image-20231222110931164" tabindex="0" loading="lazy"><figcaption>image-20231222110931164</figcaption></figure><p>因此，CPU 从 L1 Cache 中读取数据的速度，相比于从内存读取的速度，会快100多倍</p><h2 id="cpu-cache-的数据结构和读取过程" tabindex="-1"><a class="header-anchor" href="#cpu-cache-的数据结构和读取过程" aria-hidden="true">#</a> CPU Cache 的数据结构和读取过程</h2><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231222111141763.png" alt="image-20231222111141763" tabindex="0" loading="lazy"><figcaption>image-20231222111141763</figcaption></figure><ul><li>CPU Cache 由多个 Cache Line 组成的</li><li>Cache Line 是 CPU 从内存读取数据的基本单位</li><li>Cache Line 是由各种标志（Tag）+ 数据块（Data Block）组成</li></ul><p>CPU Cache 的数据是从内存中读取过来的，它是以一小块一小块读取数据的，而不是按照单个数组元素来读取数据的，在 CPU Cache 中的，这样一小块一小块的数据，称为 <strong>Cache Line（缓存块）</strong>。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231222112826903.png" alt="image-20231222112826903" tabindex="0" loading="lazy"><figcaption>image-20231222112826903</figcaption></figure><ul><li>事实上，CPU 读取数据的时候，无论数据是否存放到 Cache 中，CPU 都是先访问 Cache</li><li>只有当 Cache 中找不到数据时，才会去访问内存，并把内存中的数据读入到 Cache 中，CPU 再从 CPU Cache 读取数据。</li><li>这样的访问机制，跟我们使用「内存作为硬盘的缓存」的逻辑是一样的 <ul><li>如果内存有缓存的数据，则直接返回，否则要访问龟速一般的硬盘。</li><li>CPU Cache作为内存的缓存</li></ul></li></ul><blockquote><p><strong>读取示例</strong></p></blockquote><p>假设服务器的L1 Cache缓存一次载入数据的大小是64字节</p><p>比如，有一个 <code>int array[100]</code> 的数组，当载入 <code>array[0]</code> 时，由于这个数组元素的大小在内存只占 4 字节，不足 64 字节</p><p>CPU 就会<strong>顺序加载</strong>数组元素到 <code>array[15]</code>，意味着 <code>array[0]~array[15]</code> 数组元素都会被缓存在 CPU Cache 中了</p><p>因此当下次访问这些数组元素时，会直接从 CPU Cache 读取，而不用再从内存中读取，大大提高了 CPU 读取数据的性能。</p><blockquote><p><strong>CPU 怎么知道要访问的内存数据，是否在 Cache 里？</strong></p><p><strong>如果在的话，如何找到 Cache 对应的数据呢？</strong></p></blockquote><p>CPU 访问内存数据时，是一小块一小块数据读取的，具体这一小块数据的大小，取决于 <code>coherency_line_size</code> 的值，一般 64 字节。</p><p>在内存中，这一块的数据我们称为<strong>内存块（Block）</strong>，读取的时候我们要拿到数据所在内存块的地址。</p><p>对于<strong>直接映射 Cache 采用的策略</strong>，就是把<strong>内存块的地址始终「映射」在一个 CPU Cache Line（缓存块） 的地址</strong></p><p>至于映射关系实现方式，则是使用「取模运算」，取模运算的结果就是内存块地址对应的 CPU Cache Line（缓存块） 的地址。</p><ul><li>类似Hash桶的取模存储规则，只不过Hash桶的规则是基于哈希码的，哈希码是由哈希函数算出来的</li><li>直接映射Cache是基于内存块的编号</li></ul><blockquote><p><strong>直接映射示例</strong></p></blockquote><p>举个例子，内存共被划分为 32 个内存块，CPU Cache 共有 8 个 CPU Cache Line</p><p>假设 CPU 想要访问第 15 号内存块，如果 15 号内存块中的数据已经缓存在 CPU Cache Line 中的话，则是一定映射在 7 号 CPU Cache Line 中，因为 <code>15 % 8</code> 的值是 7。</p><p>使用取模方式映射的话，就会出现多个内存块对应同一个 CPU Cache Line</p><p>比如上面的例子，除了 15 号内存块，还有 7 号、23 号、31 号内存块都是映射到 7 号 CPU Cache Line 中</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231222130134721.png" alt="image-20231222130134721" tabindex="0" loading="lazy"><figcaption>image-20231222130134721</figcaption></figure><blockquote><p><strong>CPU Cache 和内存地址的构成</strong></p></blockquote><p>因此，为了区别不同的内存块，在对应的 CPU Cache Line 中我们还会存储一个<strong>组标记（Tag）</strong>。</p><p>这个组标记会记录当前 CPU Cache Line 中存储的数据对应的内存块，我们可以用这个组标记来区分不同的内存块。</p><p>除了组标记信息外，CPU Cache Line 还有两个信息：</p><ul><li>一个是，从内存加载过来的实际存放<strong>数据（Data）</strong>。</li><li>另一个是，<strong>有效位（Valid bit）</strong>，它是用来标记对应的 CPU Cache Line 中的数据是否是有效的 <ul><li>如果有效位是 0，无论 CPU Cache Line 中是否有数据，CPU 都会直接访问内存，重新加载数据。</li></ul></li></ul><p>CPU 在从 CPU Cache 读取数据的时候，并不是读取 CPU Cache Line 中的整个数据块，而是读取 CPU 所需要的一个数据片段，这样的数据统称为一个<strong>字（Word）</strong>。需要一个**偏移量（Offset）**在对应的 CPU Cache Line 中数据块中找到所需的字</p><p>一个内存的访问地址，包括<strong>组标记、CPU Cache Line 索引、偏移量</strong>这三种信息</p><ul><li>CPU 就能通过这些信息，在 CPU Cache 中找到缓存的数据。</li></ul><p>对于 CPU Cache 里的数据结构，则是由<strong>索引 + 有效位 + 组标记 + 数据块</strong>组成。</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231222130435862.png" alt="image-20231222130435862" tabindex="0" loading="lazy"><figcaption>image-20231222130435862</figcaption></figure><blockquote><p><strong>CPU如何通过内存地址访问到CPU Cache中的数据</strong></p></blockquote><p>如果内存中的数据已经在 CPU Cache 中了，那 CPU 访问一个内存地址的时候，会经历这 4 个步骤</p><ol><li>根据<strong>内存地址中索引信息</strong>，计算在 CPU Cache 中的索引，也就是<strong>找出对应的 CPU Cache Line 的地址</strong>；</li><li>找到对应 CPU Cache Line 后，<strong>判断 CPU Cache Line 中的有效位</strong>，<strong>确认 CPU Cache Line 中数据是否是有效的</strong><ul><li>如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行；</li></ul></li><li><strong>对比内存地址中组标记和 CPU Cache Line 中的组标记</strong>，<strong>确认 CPU Cache Line 中的数据是我们要访问的内存数据</strong>、 <ul><li>如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行；</li></ul></li><li><strong>根据内存地址中偏移量信息</strong>，从 CPU Cache Line 的数据块中，<strong>读取对应的字</strong>。</li></ol><blockquote><p><strong>其他的映射策略</strong></p></blockquote><p>除了直接映射 Cache 之外，还有其他通过内存地址找到 CPU Cache 中的数据的策略，比如全相连 Cache （<em>Fully Associative Cache</em>）、组相连 Cache （<em>Set Associative Cache</em>）等，这几种策策略的数据结构都比较相似</p><h2 id="提升cpu-cache命中率" tabindex="-1"><a class="header-anchor" href="#提升cpu-cache命中率" aria-hidden="true">#</a> 提升CPU Cache命中率</h2><h3 id="提升数据缓存命中率" tabindex="-1"><a class="header-anchor" href="#提升数据缓存命中率" aria-hidden="true">#</a> 提升数据缓存命中率</h3><blockquote><p>遍历二维数组效率</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 形式1</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> j <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 形式2</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> j <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>形式1执行时间比形式2块好几倍</li></ul><p>之所以有这么大的差距，是因为二维数组 <code>array</code> 所占用的内存是连续的，比如长度 <code>N</code> 的值是 <code>2</code> 的话</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>形式1访问的顺序跟元素存放的顺序相同 <ul><li>当CPU访问<code>array[0][0]</code>时，由于该数据不在缓存中，它会顺序的将跟随其后的元素从内存中加载到CPU Cache中</li></ul></li><li>形式2访问的顺序是跳跃的 <ul><li>如果N的数值很大，那么操作<code>array[j][i]</code>的时候是没办法将<code>array[j+1][i]</code>也读入CPU Cache中的</li></ul></li></ul><p><strong>总结</strong></p><p>我们在遍历数据的时候，应该按照内存布局的顺序操作</p><p>这是因为 CPU Cache 是根据 CPU Cache Line 批量操作数据的，所以顺序地操作连续内存数据时，性能能得到有效的提升</p><h3 id="提升指令缓存命中率" tabindex="-1"><a class="header-anchor" href="#提升指令缓存命中率" aria-hidden="true">#</a> 提升指令缓存命中率</h3><p>有规律的条件分支语句能够让 CPU 的分支预测器发挥作用，进一步提高执行的效率</p>`,66),t=[p];function c(i,l){return n(),s("div",null,t)}const g=a(o,[["render",c],["__file","CPU Cache.html.vue"]]);export{g as default};
