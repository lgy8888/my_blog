import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as p,c as r,f as o}from"./app-OTaO6_y0.js";const e={},n=o(`<h1 id="性能调优" tabindex="-1"><a class="header-anchor" href="#性能调优" aria-hidden="true">#</a> 性能调优</h1><h2 id="基准测试" tabindex="-1"><a class="header-anchor" href="#基准测试" aria-hidden="true">#</a> 基准测试</h2><blockquote><p>benchmark</p></blockquote><h3 id="基准测试概念" tabindex="-1"><a class="header-anchor" href="#基准测试概念" aria-hidden="true">#</a> 基准测试概念</h3><h4 id="基准测试的定义" tabindex="-1"><a class="header-anchor" href="#基准测试的定义" aria-hidden="true">#</a> 基准测试的定义</h4><blockquote><p><strong>基准测试是什么？</strong></p></blockquote><p><strong>基准测试（benchmark）是针对系统设计的一种压力测试</strong></p><p>通常的目标是为了<strong>掌握系统的行为</strong>，也可以用于<strong>重现某个系统状态</strong>，或者做<strong>新硬件的可靠性测试</strong></p><h4 id="基准测试的作用" tabindex="-1"><a class="header-anchor" href="#基准测试的作用" aria-hidden="true">#</a> 基准测试的作用</h4><blockquote><p><strong>为什么要做基准测试？</strong></p></blockquote><p>基准测试是唯一方便有效的可以学习<strong>系统在给定的工作负载下会发生什么</strong>的方法</p><p>基准测试可以<strong>观察系统在不同压力下的行为</strong>，<strong>评估系统的容量</strong>，<strong>掌握哪些是重要的变化</strong>，或者<strong>观察系统如何处理不同的数据</strong>。</p><p><strong>基准测试可以在系统实际负载之外创造一些虚构场景进行测试</strong>。</p><p>基准测试可以完成以下工作，或者更多:</p><ul><li>验证基于系统的一些假设，确认这些假设是否符合实际情况。</li><li>重现系统中的某些异常行为，以解决这些异常。</li><li>测试系统当前的运行情况。 <ul><li>如果不清楚系统当前的性能，就无法确认某些优化的效果如何。</li><li>也可以利用历史的基准测试结果来分析诊断一些无法预测的问题</li></ul></li><li>模拟比当前系统更高的负载，以找出系统随着压力增加而可能遇到的扩展性瓶颈。</li><li>规划未来的业务增长。 <ul><li>基准测试可以评估在项目未来的负载下，需要什么样的硬件，需要多大容量的网络，以及其他相关资源。</li><li>这有助于降低系统升级和重大变更的风险。</li></ul></li><li>测试应用适应可变环境的能力。 <ul><li>例如，通过基准测试，可以发现系统在随机的并发峰值下的性能表现，或者是不同配置的服务器之间的性能表现。</li><li>基准测试也可以测试系统对不同数据分布的处理能力。</li></ul></li><li>测试不同的硬件、软件和操作系统配置。 <ul><li>比如RAID5还是RAID10更适合当前的系统？如果系统从 ATA 硬盘升级到 SAN 存储，对于随机写性能有什么帮助？Linux2.4系列的内核会比2.6系列的可扩展性更好吗？升级MySOL的版本能改善性能吗?为当前的数据采用不同的存储引擎会有什么效果？</li><li>所有这类问题都可以通过专门的基准测试来获得答案。</li></ul></li><li>证明新采购的设备是否配置正确。 <ul><li>通过基准测试来对新系统进行压测，发现了错误的配置，以及硬件组件的失效等问题。</li><li>在新系统正式上线到生产环境之前进行基准测试是一个好习惯</li><li>永远不要相信主机提供商或者硬件供应商的所谓系统已经安装好，并且能运行多快的说法。</li><li>如果可能，执行实际的基准测试永远是一个好主意。</li></ul></li></ul><h4 id="基准测试的问题" tabindex="-1"><a class="header-anchor" href="#基准测试的问题" aria-hidden="true">#</a> 基准测试的问题</h4><p><strong>基准测试的一个主要问题在于其不是真实压力的测试。</strong></p><p>基准测试施加给系统的压力相对真实压力来说，通常比较简单。</p><p>真实压力是不可预期而且变化多端的，有时候情况会过于复杂而难以解释。</p><p>所以使用真实压力测试，可能难以从结果中分析出确切的结论。</p><blockquote><p>基准测试的压力和真实压力在哪些方面不同?</p></blockquote><p>有很多因素会影响基准测试，比如数据量数据和查询的分布</p><p>最重要的一点还是<strong>基准测试通常要求尽可能快地执行完成，所以经常给系统造成过大的压力</strong>。</p><p>许多情况下，基准测试都会调整给测试工具的最大压力，以在系统可以容忍的压力阈值内尽可能快地执行测试，这对于确定系统的最大容量非常有帮助。然而大部分压力测试工具不支持对压力进行复杂的控制。<strong>测试工具自身的局限也会影响到结果的有效性</strong></p><p>使用基准测试进行容量规划也要掌握技巧，不能只根据测试结果做简单的推断。</p><blockquote><p>例子</p></blockquote><p>假设想知道使用新数据库服务器后，系统能够支撑多大的业务增长。</p><p>首先对原系统进行基准测试，然后对新系统做测试</p><p>结果发现新系统可以支持原系统40倍的TPS(每秒事务数)，这时候就不能简单地推断说新系统一定可以支持40倍的业务增长。</p><ul><li>在业务增长的同时，系统的流量、用户、数据以及不同数据之间的交互都在增长，它们不可能都有 40倍的支撑能力，尤其是相互之间的关系。</li><li>而且当业务增长到40倍时，应用本身的设计也可能已经随之改变，可能有更多的新特性会上线，其中某些特性可能对数据库造成的压力远大于原有功能。</li><li>而这些压力、数据、关系和特性的变化都很难模拟，所以它们对系统的影响也很难评估。</li></ul><blockquote><p>结论</p></blockquote><p><strong>基准测试只能进行大概的测试，来确定系统大致的余量有多少</strong>。</p><p>当然也可以做一些真实压力测试(和基准测试有区别)，但在构造数据集和压力的时候要特别小心，而且这样就不再是基准测试了。</p><p><strong>基准测试要尽量简单直接，结果之间容易相互比较，成本低且易于执行</strong>。</p><p>尽管有诸多限制，基准测试还是非常有用的(只要搞清楚测试的原理并且了解如何分析结果所代表的意义)。</p><h3 id="基准测试的策略" tabindex="-1"><a class="header-anchor" href="#基准测试的策略" aria-hidden="true">#</a> 基准测试的策略</h3><p>基准测试有两种主要的策略：一是针对整个系统的整体测试，另外是单独测试MySQL。</p><p>这两种策略也被称为集成式(<code>full-stack</code>)以及单组件式(<code>single-component</code>)基准测试。</p><h4 id="集成式基准测试" tabindex="-1"><a class="header-anchor" href="#集成式基准测试" aria-hidden="true">#</a> 集成式基准测试</h4><blockquote><p>为什么要做集成式基准测试？</p></blockquote><p>针对整个系统做集成式测试，而不是单独测试 MySQL 的原因主要有以下几点</p><ul><li>测试整个应用系统，包括 Web服务器、应用代码、网络和数据库是非常有用的 <ul><li>因为用户关注的并不仅仅是 MySQL本身的性能，而是应用整体的性能。</li></ul></li><li>MySQL并非总是应用的瓶颈，通过整体的测试可以揭示这一点。</li><li>只有对应用做整体测试，才能发现各部分之间的缓存带来的影响。</li><li>整体应用的集成式测试更能揭示应用的真实表现，而单独组件的测试很难做到这点。</li></ul><blockquote><p>集成式基准测试有什么问题？</p></blockquote><p>应用的整体基准测试很难建立，甚至很难正确设置。</p><p>如果基准测试的设计有问题，那么结果就无法反映真实的情况，从而基于此做的决策也就可能是错误的</p><h4 id="单组件式基准测试" tabindex="-1"><a class="header-anchor" href="#单组件式基准测试" aria-hidden="true">#</a> 单组件式基准测试</h4><blockquote><p>为什么要做单组件式基准测试？</p></blockquote><p>不过，有时候不需要了解整个应用的情况，而只需要关注 MySQL的性能，至少在项目初期可以这样做。</p><p>基于以下情况，可以选择只测试 MySQL:</p><ul><li>需要比较不同的 schema 或查询的性能。</li><li>针对应用中某个具体问题的测试。</li><li>为了避免漫长的基准测试，可以通过一个短期的基准测试，做快速的“周期循环”来检测出某些调整后的效果。</li></ul><blockquote><p>只测试MySQL有什么问题？</p></blockquote><p>另外，如果能够在真实的数据集上执行重复的查询，那么针对MySQL的基准测试也是有用的，但是数据本身和数据集的大小都应该是真实的。如果可能，可以采用生产环境的数据快照。</p><p>不幸的是，设置一个基于真实数据的基准测试复杂而且耗时。如果能得到一份生产数据集的拷贝，当然很幸运，但这通常不太可能。</p><p>比如要测试的是一个刚开发的新应用，它只有很少的用户和数据。如果想测试该应用在规模扩张到很大以后的性能表现，就只能通过模拟大量的数据和压力来进行。</p><h4 id="基准测试的指标" tabindex="-1"><a class="header-anchor" href="#基准测试的指标" aria-hidden="true">#</a> 基准测试的指标</h4><p>在开始执行甚至是在设计基准测试之前，需要先明确测试的目标。</p><p>测试目标决定了选择什么样的测试工具和技术，以获得精确而有意义的测试结果。</p><p>可以将测试目标细化为一系列的问题，比如：&quot;这种CPU是否比另外一种要快?&quot;，或 &quot;新索引是否比当前索引性能更好?&quot;</p><p>有时候需要用不同的方法测试不同的指标。比如，针对延迟(latency)和吞吐量(throughput)就需要采用不同的试方法。</p><blockquote><p><strong>吞吐量</strong></p></blockquote><p><strong>吞吐量指的是单位时间内的事务处理数。这一直是经典的数据库应用试指标。</strong></p><p>一些标准的基准测试被广泛地引用，如TPC-C(参考<code>http://www.Ipc.org</code>)，而且很多数据库厂商都努力争取在这些测试中取得好成绩。</p><p>这类基准测试主要针对在线事务处理(OLTP)的吞吐量，非常适用于多用户的交互式应用。</p><p><strong>常用的测试单位是每秒事务数(TPS)，有些也采用每分钟事务数(TPM)</strong>。</p><blockquote><p><strong>响应时间或者延迟</strong></p></blockquote><p><strong>这个指标用于测试任务所需的整体时间。</strong></p><p>根据具体的应用，测试的时间单位可能是微秒、毫秒、秒或者分钟。</p><p>根据不同的时间单位可以计算出平均响应时间、最小响应时间、最大响应时间和所占百分比。</p><p><strong>最大响应时间通常意义不大，因为测试时间越长，最大响应时间也可能越大。</strong></p><p>而且其结果通常不可重复，每次测试都可能得到不同的最大响应时间。</p><p>因此通常可以使用<strong>百分比响应时间</strong>(percentile response time)来<strong>替代最大响应时间</strong>。</p><p>例如，如果<strong>95%的响应时间都是5毫秒</strong>，则表示任务在 95% 的时间段内都可以在5毫秒之内完成。</p><p><strong>使用图表有助于理解测试结果</strong>。</p><p>可以将测试结果绘制成折线图(比如平均值折线或者95%百分比折线)或者散点图，直观地表现数据结果集的分布情况。</p><p>通过这些图可以发现长时间测试的趋势。</p><blockquote><p><strong>并发性</strong></p></blockquote><p>并发性是一个非常重要又经常被误解和误用的指标。</p><p>例如，它经常被表示成<strong>多少用户在同一时间浏览一个 Web站点</strong>，<strong>经常使用的指标是有多少个会话</strong>。</p><p>然而HTTP协议是无状态的，大多数用户只是简单地读取浏览器上显示的信息，这并不等同于Web服务器的并发性。</p><p>而且，<strong>Web服务器的并发性也不等同于数据库的并发性，而仅仅只表示会话存储机制可以处理多少数据的能力</strong>。</p><p>Web服务器的并发性更准确的度量指标，应该是在任意时间有多少同时发生的并发请求。</p><p>在应用的不同环节都可以测量相应的并发性。</p><p><strong>Web服务器的高并发，一般也会导致数据库的高并发</strong>，但服务器采用的语言和工具集对此都会有影响。</p><p>注意不要将创建数据库连接和并发性搞混淆。</p><p><strong>一个设计良好的应用，同时可以打开成百上千个MySQL数据库服务器连接，但可能同时只有少数连接在执行查询</strong>。</p><p>一个Web站点同时有50000个用户访问，却可能只有10~15个并发请求到MySQL 数据库。</p><p>换句话说，<strong>并发性基准测试需要关注的是正在工作中的并发操作，或者是同时工作中的线程数或者连接数</strong>。</p><p>当<strong>并发性增加时</strong>，需要<strong>测量吞吐量是否下降</strong>，<strong>响应时间是否变长</strong>，如果是这样，应用可能就无法<strong>处理峰值压力</strong>。</p><p><strong>并发性的测量</strong>完全不同于响应时间和吞吐量，它不像是一个结果，而更像是<strong>设置基准测试的一种属性</strong>。</p><p><strong>并发性测试通</strong>常不是为了测试应用能达到的并发度，而是<strong>为了测试应用在不同并发下的性能</strong>。</p><p>当然，数据库的并发性还是需要测量的。</p><p>可以通过sysbench指定32、64或者128个线程的测试，然后在测试期间记录 MySQL数据库的 Threads_running 状态值。</p><blockquote><p><strong>可扩展性</strong></p></blockquote><p>在系统的业务压力可能发生变化的情况下，测试可扩展性就非常必要了。</p><p>简单地说，可扩展性指的是，<strong>给系统增加一倍的工作，在理想情况下就能获得两倍的结果(即吞吐量增加一倍)</strong>。</p><p>或者说，<strong>给系统增加一倍的资源(比如两倍的CPU数)，就可以获得两倍的吞吐量</strong>。</p><p>当然，同时性能(响应时间)也必须在可以接受的范围内。</p><p><strong>大多数系统是无法做到如此理想的线性扩展的，随着压力的变化，吞吐量和性能都可能越来越差</strong>。</p><p><strong>可扩展性指标对于容量规范非常有用</strong>，它可以提供其他测试无法提供的信息，来<strong>帮助发现应用的瓶颈</strong>。</p><p>比如，如果系统是基于单个用户的响应时间测试(这是一个很糟糕的测试策略)设计的</p><p>虽然测试的结果很好，但当并发度增加时，系统的性能有可能变得非常糟糕。</p><p>而一个基于不断增加用户连接的情况下的响应时间测试则可以发现这个问题。</p><p>一些任务，比如从细粒度数据创建汇总表的批量工作，需要的是周期性的快速响应时间。</p><p>当然也可以测试这些任务纯粹的响应时间，但要注意考虑这些任务之间的相互影响。</p><p>批量工作可能导致相互之间有影响的查询性能变差，反之亦然</p><blockquote><p><strong>如何选择基准测试的指标？</strong></p></blockquote><p>归根结底，应该测试那些对用户来说最重要的指标。</p><p>因此应该尽可能地去收集一些需求比如，什么样的响应时间是可以接受的，期待多少的并发性，等等。</p><p>然后基于这些需求来设计基准测试，避免目光短浅地只关注部分指标，而忽略其他指标。</p><h2 id="explain" tabindex="-1"><a class="header-anchor" href="#explain" aria-hidden="true">#</a> Explain</h2><h3 id="explain的作用" tabindex="-1"><a class="header-anchor" href="#explain的作用" aria-hidden="true">#</a> Explain的作用</h3><p>一条查询语句在经过MySQL 查询优化器的各种基于成本和规则的优化会后生成一个所谓的执行计划</p><p>这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。</p><p>EXPLAIN 语句可以帮助我们查看某个查询语句的具体执行计划</p><blockquote><p>查看某个查询的执行计划</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="执行计划" tabindex="-1"><a class="header-anchor" href="#执行计划" aria-hidden="true">#</a> 执行计划</h3><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在一个大的查询语句中每个SELECT 关键字都对应一个唯一的id</td></tr><tr><td>select_type</td><td>SELECT 关键字对应的查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际使用的索引</td></tr><tr><td>key_len</td><td>实际使用的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra</td><td>一些额外的信息</td></tr></tbody></table>`,118),s=[n];function l(a,i){return p(),r("div",null,s)}const c=t(e,[["render",l],["__file","性能调优.html.vue"]]);export{c as default};
