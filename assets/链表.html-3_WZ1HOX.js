import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as l,f as e}from"./app-OTaO6_y0.js";const g={},n=e('<h1 id="链表" tabindex="-1"><a class="header-anchor" href="#链表" aria-hidden="true">#</a> 链表</h1><h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h2><ul><li>在计算机科学中，链表是数据元素的线性集合，其每个元素都指向下一个元素，元素存储上并不连续</li><li>用若干地址分散的存储单元存储线性表的数据元素，逻辑上相邻的数据元素物理上不一定相邻</li><li>利用指针实现了用不相邻的存储单元存放逻辑上相邻的元素</li><li>存储一个数据元素的存储单元称为结点 <ul><li>数据域：元素本身信息</li><li>指针域：指示直接后继或前驱的存储位置</li></ul></li></ul><h2 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h2><ul><li><strong>单向链表</strong>：每个元素只知道下一个元素位置 <ul><li>单链表是顺序存储结构</li></ul></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230515222039040.png" alt="image-20230515222005997" tabindex="0" loading="lazy"><figcaption>image-20230515222005997</figcaption></figure><ul><li><strong>双向链表</strong>：每个元素知道上一个元素和下一个元素位置</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230625111751510.png" alt="image-20230515222019201" tabindex="0" loading="lazy"><figcaption>image-20230515222019201</figcaption></figure><ul><li><strong>循环链表</strong>：通常链表的尾节点<code>tail</code>指向都是<code>null</code>，而循环链表的<code>tail</code>指向的是头结点<code>head</code></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230515222005997.png" alt="image-20230515222039040" tabindex="0" loading="lazy"><figcaption>image-20230515222039040</figcaption></figure><ul><li>链表中有一种特殊的节点称为哨兵（Sentinel）节点，也叫作哑元（Dummy）节点，它不存储数据，通常作为头尾，用来简化边界判断</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230625111810692.png" alt="image-20230515222433771" tabindex="0" loading="lazy"><figcaption>image-20230515222433771</figcaption></figure><h2 id="性能" tabindex="-1"><a class="header-anchor" href="#性能" aria-hidden="true">#</a> 性能</h2><h3 id="随机访问" tabindex="-1"><a class="header-anchor" href="#随机访问" aria-hidden="true">#</a> 随机访问</h3><p>根据<code>index</code>查找，时间复杂度$O(n)$</p><h3 id="插入或删除" tabindex="-1"><a class="header-anchor" href="#插入或删除" aria-hidden="true">#</a> 插入或删除</h3><ul><li>起始位置：$O(1)$</li><li>结束位置：若已知tail尾节点是$O(1)$，未知tail尾结点是$O(n)$</li><li>中间位置：根据index查找时间+$O(n)$</li></ul><h2 id="一元多项式的表示及相加" tabindex="-1"><a class="header-anchor" href="#一元多项式的表示及相加" aria-hidden="true">#</a> 一元多项式的表示及相加</h2><ul><li>数学表示: $P_n(x) = p_0 + p_1x + p_2x_2 + …+ p_nx_n$</li><li>计算机表示: $P = ( p_0，p_1，p_2，…，p_n )$</li><li>多项式相加： <ul><li>$P = ( p_0，p_1，p_2，…，p_n )$</li><li>$Q = ( q_0，q_1，q_2，…，q_m )$</li><li>$R = (p_0+q_0, p_1+q_1, ···, p_m+q_m, p_{m+1}, ···, p_n)$</li></ul></li></ul><p>​ <img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230625111826305.png" alt="image-20230625111751510" loading="lazy"><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230625112206242.png" alt="image-20230625111810692" loading="lazy"><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230515004107281.png" alt="image-20230625111826305" loading="lazy"></p><ul><li>采用链式存储结构</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230515222019201.png" alt="image-20230625112206242" tabindex="0" loading="lazy"><figcaption>image-20230625112206242</figcaption></figure><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230625112223149.png" alt="image-20230625112223149" tabindex="0" loading="lazy"><figcaption>image-20230625112223149</figcaption></figure>',23),o=[n];function t(c,r){return a(),l("div",null,o)}const u=i(g,[["render",t],["__file","链表.html.vue"]]);export{u as default};
