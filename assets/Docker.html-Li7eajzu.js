import{_ as l}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as t,o,c,b as n,d as a,e as i,f as s}from"./app-OTaO6_y0.js";const p={},r=s('<h1 id="docker" tabindex="-1"><a class="header-anchor" href="#docker" aria-hidden="true">#</a> Docker</h1><h2 id="作用" tabindex="-1"><a class="header-anchor" href="#作用" aria-hidden="true">#</a> 作用</h2><ul><li><p>Docker解决大型项目依赖关系复杂，不同组件依赖的兼容性问题</p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li></ul></li><li><p>Docker解决开发、测试、生产环境有差异的问题</p><ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul></li><li><p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p><ul><li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li><li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li><li>启动、移除都可以通过一行命令完成，方便快捷</li></ul></li></ul><h2 id="docker架构" tabindex="-1"><a class="header-anchor" href="#docker架构" aria-hidden="true">#</a> Docker架构</h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3>',5),d=s("<li><p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p></li><li><p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p></li><li><p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p><ul><li><strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</li><li><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</li></ul></li>",3),u=n("p",null,[n("strong",null,"DockerRegistry"),a("：开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。")],-1),m=n("li",null,[n("p",null,"DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。")],-1),k={href:"https://c.163yun.com/hub",target:"_blank",rel:"noopener noreferrer"},g={href:"https://cr.console.aliyun.com/",target:"_blank",rel:"noopener noreferrer"},v=s(`<h3 id="架构" tabindex="-1"><a class="header-anchor" href="#架构" aria-hidden="true">#</a> 架构</h3><p>Docker是一个CS架构的程序，由两部分组成：</p><ul><li><p>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</p></li><li><p>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</p></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20210731155844368.png" alt="image-20210731154257653" tabindex="0" loading="lazy"><figcaption>image-20210731154257653</figcaption></figure><h2 id="docker的基本操作" tabindex="-1"><a class="header-anchor" href="#docker的基本操作" aria-hidden="true">#</a> Docker的基本操作</h2><p>通过命令启动docker：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>systemctl start <span class="token function">docker</span>  <span class="token comment"># 启动docker服务</span>

systemctl stop <span class="token function">docker</span>  <span class="token comment"># 停止docker服务</span>

systemctl restart <span class="token function">docker</span>  <span class="token comment"># 重启docker服务</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="镜像操作" tabindex="-1"><a class="header-anchor" href="#镜像操作" aria-hidden="true">#</a> 镜像操作</h3><ul><li><p><strong>镜像名称</strong>：<code>[repository]:[tag]</code></p><ul><li>例如：mysql5.7镜像 -&gt; <code>mysql:5.7</code></li></ul></li><li><p><strong>镜像命令</strong></p><ul><li>常见的镜像操作命令如图：</li></ul></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20210731161104732.png" alt="image-20210731155649535" tabindex="0" loading="lazy"><figcaption>image-20210731155649535</figcaption></figure>`,10),b=n("p",null,[n("strong",null,"拉取镜像")],-1),h={href:"https://hub.docker.com/",target:"_blank",rel:"noopener noreferrer"},f=s('<figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20210731155903037.png" alt="image-20210731155844368" tabindex="0" loading="lazy"><figcaption>image-20210731155844368</figcaption></figure><ul><li>根据查看到的镜像名称，拉取自己需要的镜像，通过命令：<code>docker pull xxx:xxx</code>，若不加版本号则默认为<code>latest</code></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20210731161354344.png" alt="image-20210731155856199" tabindex="0" loading="lazy"><figcaption>image-20210731155856199</figcaption></figure><ul><li><p>通过命令<code>docker image</code>查看拉取到的镜像</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20210731155856199.png" alt="image-20210731155903037" tabindex="0" loading="lazy"><figcaption>image-20210731155903037</figcaption></figure></li></ul>',4),y=s('<li><p><strong>保存、导入镜像(docker帮助文档的使用)</strong></p><ul><li>利用<code>docker xxx --help</code>命令查看<code>docker save</code>和<code>docker load</code>的语法</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20210731155649535.png" alt="image-20210731161104732" tabindex="0" loading="lazy"><figcaption>image-20210731161104732</figcaption></figure><ul><li>根据帮助文档中的命令使用方法使用命令 <code>docker save -o [保存的目标文件名称] [镜像名称]</code></li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20210731173746910.png" alt="image-20210731161354344" tabindex="0" loading="lazy"><figcaption>image-20210731161354344</figcaption></figure><ul><li>同样查看docker命令帮助文档之后运行加载文件命令</li></ul></li>',1),x=s(`<h3 id="容器操作" tabindex="-1"><a class="header-anchor" href="#容器操作" aria-hidden="true">#</a> 容器操作</h3><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20210731161950495.png" alt="image-20210731161950495" tabindex="0" loading="lazy"><figcaption>image-20210731161950495</figcaption></figure><ul><li><p>容器保护三个状态：</p><ul><li><p>运行：进程正常运行</p></li><li><p>暂停：进程暂停，CPU不再运行，并不释放内存</p></li><li><p>停止：进程终止，回收进程占用的内存、CPU等资源</p></li></ul></li><li><p>命令：</p><ul><li><p>docker run：创建并运行一个容器，处于运行状态</p></li><li><p>docker pause：让一个运行的容器暂停</p></li><li><p>docker unpause：让一个容器从暂停状态恢复运行</p></li><li><p>docker stop：停止一个运行的容器</p></li><li><p>docker start：让一个停止的容器再次运行</p></li><li><p>docker rm：删除一个容器</p></li></ul></li></ul><p><strong>创建并运行一个容器</strong></p><ul><li>去dockerhub中找官方启动命令</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">--name</span> containerName <span class="token parameter variable">-p</span> 宿主机端口:容器端口 <span class="token parameter variable">-d</span> nginx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>docker run ：创建并运行一个容器</li><li>--name ：给容器起个名字</li><li>-p ：将主机端口和容器端口映射，左侧为宿主机端口，右侧为容器端口 （宿主机是docker所在的主机 --linux）</li><li>-d ：后台运行容器</li><li>nginx ：镜像名称</li></ul><p><strong>查看容器日志</strong></p><ul><li><code>docker logs</code></li><li>添加 <code>-f</code> 参数可以持续查看日志</li></ul><p><strong>查看容器状态</strong></p><ul><li><code>docker ps</code></li><li>添加 <code>-a</code> 参数可以查看所有容器，包括已停止的</li></ul><p><strong>删除所有前缀镜像</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> rmi <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> images <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">&quot;前缀&quot;</span><span class="token variable">)</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>强制删除所有容器</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-aq</span><span class="token variable">)</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="数据卷" tabindex="-1"><a class="header-anchor" href="#数据卷" aria-hidden="true">#</a> 数据卷</h3><h4 id="概念及基本语法" tabindex="-1"><a class="header-anchor" href="#概念及基本语法" aria-hidden="true">#</a> 概念及基本语法</h4><ul><li>**数据卷（volume）**是一个虚拟目录，指向宿主机文件系统中的某个目录。</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20210731173809877.png" alt="image-20210731173541846" tabindex="0" loading="lazy"><figcaption>image-20210731173541846</figcaption></figure><ul><li>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录</li><li>操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录</li></ul><p><strong>数据卷操作的基本语法</strong>：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><ul><li>create 创建一个volume</li><li>inspect 显示一个或多个volume的信息</li><li>ls 列出所有的volume</li><li>prune 删除未使用的volume</li><li>rm 删除一个或多个指定的volume</li></ul><p><strong>创建并查看数据卷</strong></p><ul><li>创建数据卷</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume create <span class="token punctuation">[</span>数据卷名称<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>查看所有数据</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> volumn <span class="token function">ls</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20210731173541846.png" alt="image-20210731173746910" tabindex="0" loading="lazy"><figcaption>image-20210731173746910</figcaption></figure><ul><li>查看数据卷详细信息（MoutPoint：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume inspect <span class="token punctuation">[</span>数据卷名称<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230915091912552.png" alt="image-20210731173809877" tabindex="0" loading="lazy"><figcaption>image-20210731173809877</figcaption></figure><p><strong>小结</strong></p><p>数据卷的作用：</p><ul><li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li></ul><p>数据卷操作：</p><ul><li>docker volume create：创建数据卷</li><li>docker volume ls：查看所有数据卷</li><li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li><li>docker volume rm：删除指定数据卷</li><li>docker volume prune：删除所有未使用的数据卷</li></ul><h4 id="挂载数据卷" tabindex="-1"><a class="header-anchor" href="#挂载数据卷" aria-hidden="true">#</a> 挂载数据卷</h4><p>我们在<strong>创建容器时</strong>，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token punctuation">\\</span>
  <span class="token parameter variable">--name</span> mn <span class="token punctuation">\\</span>
  <span class="token parameter variable">-v</span> html:/root/html <span class="token punctuation">\\</span>
  <span class="token parameter variable">-p</span> <span class="token number">8080</span>:80
  nginx <span class="token punctuation">\\</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的-v就是挂载数据卷的命令：</p><ul><li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的/root/html这个目录中</li></ul><p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p><ul><li><code>-v [volume名称]:[容器内目录]</code></li><li><code>-v [宿主机文件]:[容器内文件]</code></li><li><code>-v [宿主机目录]:[容器内目录]</code></li></ul><p>数据卷挂载与目录直接挂载的</p><ul><li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li><li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li></ul><h2 id="dockerfile自定义镜像" tabindex="-1"><a class="header-anchor" href="#dockerfile自定义镜像" aria-hidden="true">#</a> Dockerfile自定义镜像</h2><h3 id="镜像结构" tabindex="-1"><a class="header-anchor" href="#镜像结构" aria-hidden="true">#</a> 镜像结构</h3><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20230915091854268.png" alt="image-20210731175806273" tabindex="0" loading="lazy"><figcaption>image-20210731175806273</figcaption></figure><ul><li><p>镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p></li><li><p>构建镜像，其实就是实现上述打包的过程。</p></li></ul><h3 id="dockerfile语法" tabindex="-1"><a class="header-anchor" href="#dockerfile语法" aria-hidden="true">#</a> dockerfile语法</h3><ul><li><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的<strong>指令(Instruction)</strong>，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</li></ul><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20210717162752376.png" alt="image-20210731180321133" tabindex="0" loading="lazy"><figcaption>image-20210731180321133</figcaption></figure><ul><li>更新详细语法说明，请参考官网文档： https://docs.docker.com/engine/reference/builder</li></ul><h3 id="基于ubantu构建项目" tabindex="-1"><a class="header-anchor" href="#基于ubantu构建项目" aria-hidden="true">#</a> 基于ubantu构建项目</h3><ul><li>在项目文件夹下导入jar包，环境文件，dockerfile文件</li><li>dockerfile的基本内容如下</li></ul><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token comment"># 指定基础镜像</span>
<span class="token instruction"><span class="token keyword">FROM</span> ubuntu:16.04</span>
<span class="token comment"># 配置环境变量，JDK的安装目录</span>
<span class="token instruction"><span class="token keyword">ENV</span> JAVA_DIR=/usr/local</span>

<span class="token comment"># 拷贝jdk和java项目的包</span>
<span class="token instruction"><span class="token keyword">COPY</span> ./jdk8.tar.gz <span class="token variable">$JAVA_DIR</span>/</span>
<span class="token instruction"><span class="token keyword">COPY</span> ./docker-demo.jar /tmp/app.jar</span>

<span class="token comment"># 安装JDK</span>
<span class="token instruction"><span class="token keyword">RUN</span> cd <span class="token variable">$JAVA_DIR</span> <span class="token operator">\\</span>
 &amp;&amp; tar -xf ./jdk8.tar.gz <span class="token operator">\\</span>
 &amp;&amp; mv ./jdk1.8.0_144 ./java8</span>

<span class="token comment"># 配置环境变量</span>
<span class="token instruction"><span class="token keyword">ENV</span> JAVA_HOME=<span class="token variable">$JAVA_DIR</span>/java8</span>
<span class="token instruction"><span class="token keyword">ENV</span> PATH=<span class="token variable">$PATH</span>:<span class="token variable">$JAVA_HOME</span>/bin</span>

<span class="token comment"># 暴露端口</span>
<span class="token instruction"><span class="token keyword">EXPOSE</span> 8090</span>
<span class="token comment"># 入口，java项目的启动命令</span>
<span class="token instruction"><span class="token keyword">ENTRYPOINT</span> java -jar /tmp/app.jar</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>进入项目文件夹，运行命令（版本号后面是空格+点）</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> build <span class="token parameter variable">-t</span> <span class="token punctuation">[</span>项目名称<span class="token punctuation">]</span>:<span class="token punctuation">[</span>版本号<span class="token punctuation">]</span> <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="基于java8构建项目" tabindex="-1"><a class="header-anchor" href="#基于java8构建项目" aria-hidden="true">#</a> 基于Java8构建项目</h3><ul><li><p>构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建</p></li><li><p>编写Dockerfile文件：</p><ul><li><p>基于java:8-alpine作为基础镜像</p></li><li><p>将app.jar拷贝到镜像中</p></li><li><p>暴露端口</p></li><li><p>编写入口ENTRYPOINT</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">FROM</span> java:8-alpine</span>
<span class="token instruction"><span class="token keyword">COPY</span> ./app.jar /tmp/app.jar</span>
<span class="token instruction"><span class="token keyword">EXPOSE</span> 8090</span>
<span class="token instruction"><span class="token keyword">ENTRYPOINT</span> java -jar /tmp/app.jar</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h3><ul><li><p>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</p></li><li><p>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</p></li></ul><h2 id="docker-compose" tabindex="-1"><a class="header-anchor" href="#docker-compose" aria-hidden="true">#</a> Docker-compose</h2><h3 id="概念及格式" tabindex="-1"><a class="header-anchor" href="#概念及格式" aria-hidden="true">#</a> 概念及格式</h3><ul><li><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行</p></li><li><p>格式为yml文件</p></li></ul><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>version<span class="token operator">:</span> <span class="token string">&quot;3.8&quot;</span>
 services<span class="token operator">:</span>
  mysql<span class="token operator">:</span>
    image<span class="token operator">:</span> mysql<span class="token operator">:</span><span class="token number">5.7</span>.<span class="token number">25</span>
    environment<span class="token operator">:</span>
     MYSQL_ROOT_PASSWORD<span class="token operator">:</span> <span class="token number">123</span> 
    volumes<span class="token operator">:</span>
     - <span class="token string">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span>
     - <span class="token string">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span>
  web<span class="token operator">:</span>
    build<span class="token operator">:</span> .
    ports<span class="token operator">:</span>
     - <span class="token string">&quot;8090:8090&quot;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的Compose文件就描述一个项目，其中包含两个容器：</p><ul><li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li><li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li></ul><p>DockerCompose的详细语法参考官网：https://docs.docker.com/compose/compose-file/</p><ul><li>DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。</li></ul><h3 id="部署微服务集群" tabindex="-1"><a class="header-anchor" href="#部署微服务集群" aria-hidden="true">#</a> 部署微服务集群</h3><ul><li><strong>项目文件夹中包括</strong><ul><li>docker-compose.yml</li><li>各个微服务文件夹 <ul><li>Dockerfile</li><li>app.jar</li></ul></li><li>项目启动需要的服务文件夹 <ul><li>服务内部需要被挂载的文件夹/文件</li></ul></li></ul></li><li>docker-compose.yml一般格式</li></ul><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">&quot;3.2&quot;</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nacos/nacos<span class="token punctuation">-</span>server
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">MODE</span><span class="token punctuation">:</span> standalone
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">&quot;8848:8848&quot;</span>
  <span class="token key atrule">mysql</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span>5.7.25
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">MYSQL_ROOT_PASSWORD</span><span class="token punctuation">:</span> <span class="token number">123</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">&quot;$PWD/mysql/data:/var/lib/mysql&quot;</span>
      <span class="token punctuation">-</span> <span class="token string">&quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;</span>
  <span class="token key atrule">userservice</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> ./user<span class="token punctuation">-</span>service
  <span class="token key atrule">orderservice</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> ./order<span class="token punctuation">-</span>service
  <span class="token key atrule">gateway</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> ./gateway
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">&quot;10010:10010&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>dockerfile一般格式</li></ul><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">FROM</span> java:8-alpine</span>
<span class="token instruction"><span class="token keyword">COPY</span> ./app.jar /tmp/app.jar</span>
<span class="token instruction"><span class="token keyword">ENTRYPOINT</span> java -jar /tmp/app.jar</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><strong>修改微服务application.yml配置文件</strong></p><ul><li><p>容器之间互联不是通过IP地址，而是通过容器名</p></li><li><p>配置文件中需要将各个服务的IP地址（localhost）改为服务名称</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>
    <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//mysql<span class="token punctuation">:</span>3306/cloud_order<span class="token punctuation">?</span>useSSL=false
    <span class="token key atrule">username</span><span class="token punctuation">:</span> root
    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123</span>
    <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.jdbc.Driver
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> orderservice
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> nacos<span class="token punctuation">:</span><span class="token number">8848</span> <span class="token comment"># nacos服务地址</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong>打包</strong></p><ul><li>打包成的名称需要与各个微服务dockerfile里面的jar包名称相同</li></ul><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!-- 服务打包的最终名称 --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>finalName</span><span class="token punctuation">&gt;</span></span>app<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>finalName</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>将打完包的jar包放入各个微服务包内，与dockerfile同级</li></ul></li><li><p>部署</p><ul><li>进入到项目目录中</li><li>运行部署命令</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul><h2 id="docker镜像仓库" tabindex="-1"><a class="header-anchor" href="#docker镜像仓库" aria-hidden="true">#</a> Docker镜像仓库</h2><h3 id="推送、拉取镜像" tabindex="-1"><a class="header-anchor" href="#推送、拉取镜像" aria-hidden="true">#</a> 推送、拉取镜像</h3><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p><p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> tag nginx:latest <span class="token number">192.168</span>.150.101:8080/nginx:1.0 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>② 推送镜像</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> push <span class="token number">192.168</span>.150.101:8080/nginx:1.0 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>③ 拉取镜像</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> pull <span class="token number">192.168</span>.150.101:8080/nginx:1.0 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,87);function _(D,j){const e=t("ExternalLinkIcon");return o(),c("div",null,[r,n("ul",null,[d,n("li",null,[u,n("ul",null,[m,n("li",null,[n("p",null,[a("国内也有类似于DockerHub 的公开服务，比如 "),n("a",k,[a("网易云镜像服务"),i(e)]),a("、"),n("a",g,[a("阿里云镜像库"),i(e)]),a("等。")])])])])]),v,n("ul",null,[n("li",null,[b,n("ul",null,[n("li",null,[a("去镜像仓库搜索要拉取的镜像("),n("a",h,[a("DockerHub"),i(e)]),a(")")])]),f]),y]),x])}const z=l(p,[["render",_],["__file","Docker.html.vue"]]);export{z as default};
