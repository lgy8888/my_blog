import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as s,c as a,f as e}from"./app-OTaO6_y0.js";const o={},t=e(`<h1 id="sql原理" tabindex="-1"><a class="header-anchor" href="#sql原理" aria-hidden="true">#</a> SQL原理</h1><h2 id="order底层原理" tabindex="-1"><a class="header-anchor" href="#order底层原理" aria-hidden="true">#</a> ORDER底层原理</h2><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> city<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age FORM t <span class="token keyword">WHERE</span> city<span class="token operator">=</span><span class="token string">&#39;杭州&#39;</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> name <span class="token keyword">LIMIT</span> <span class="token number">1000</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>为了避免全表扫描，在city字段上加上索引</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231205204012080.png" alt="image-20231205204012080" tabindex="0" loading="lazy"><figcaption>image-20231205204012080</figcaption></figure><ul><li>满足 <code>city=‘杭州’</code>条件的行，是从 IDX 到 ID(X+N) 的这些记录。</li></ul><blockquote><p>explain命令查看SQL执行情况</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231205213247654.png" alt="image-20231205213247654" tabindex="0" loading="lazy"><figcaption>image-20231205213247654</figcaption></figure><ul><li>Extra 这个字段中的“Using filesort”表示的就是需要排序</li><li>MySQL 会给每个线程分配一块内存用于排序，称为 <code>sort_buffer</code></li></ul><h3 id="全字段排序" tabindex="-1"><a class="header-anchor" href="#全字段排序" aria-hidden="true">#</a> 全字段排序</h3><p><strong>语句执行流程如下</strong></p><ol><li>初始化 <code>sort_buffer</code>，确定放入 name、city、age 这三个字段；</li><li><strong>从索引 city 找</strong>到第一个满足 <code>city=‘杭州’</code>条件的<strong>主键 id</strong>，也就是图中的 ID_X；</li><li><strong>到主键 id 索引取出整行</strong>，取 name、city、age 三个<strong>字段的值</strong>，<strong>存入 sort_buffer</strong> 中；</li><li>从索引 city 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_Y；</li><li><strong>对 <code>sort_buffer</code> 中的数据按照字段 name 做快速排序</strong>； <ul><li>“按 name 排序”这个动作，可能在内存中完成，也可能需要使用<strong>外部排序</strong></li></ul></li><li><strong>按照排序结果取前 1000 行返回给客户端</strong>。</li></ol><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231205204127220.png" alt="image-20231205204127220" tabindex="0" loading="lazy"><figcaption>image-20231205204127220</figcaption></figure><p><strong>外部排序</strong></p><blockquote><p>通过查看OPTIMIZER_TRACE 的结果来确认的，可以从 number_of_tmp_files 中看到是否使用了临时文件</p><ul><li>OPTIMIZER_TRACE是一个用于调试和分析查询优化器执行过程的工具，以了解查询优化器是如何评估和选择执行计划的</li></ul></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231205204813472.png" alt="image-20231205204813472" tabindex="0" loading="lazy"><figcaption>image-20231205204813472</figcaption></figure><ul><li><p><code>number_of_tmp_files</code> 表示的是，排序过程中使用的临时文件数。</p><ul><li><p>内存放不下时，就需要使用外部排序，外部排序一般使用<strong>归并排序算法</strong>。</p></li><li><p><strong>MySQL 将需要排序的数据分成 12 份，每一份单独排序后存在这些临时文件中</strong></p></li><li><p><strong>将这 12 个有序文件再合并成一个有序的大文件。</strong></p></li></ul></li><li><p><code>sort_buffer_size</code>表示的是MySQL <strong>为排序开辟的内存（sort_buffer）的大小</strong>。</p><ul><li><p>如果要排序的数据量<strong>小于 sort_buffer_size，排序就在内存中完成</strong>。</p></li><li><p>如果排序<strong>数据量太大，内存放不下</strong>，则不得不<strong>利用磁盘临时文件辅助排序</strong>。</p></li></ul><ul><li><p>如果 <code>sort_buffer_size</code> 超过了需要排序的数据量的大小，<code>number_of_tmp_files</code> 就是 0，表示排序可以直接在内存中完成。否则就需要放在临时文件中排序。</p></li><li><p><code>sort_buffer_size</code> 越小，需要分成的份数越多，<code>number_of_tmp_files</code> 的值就越大。</p></li></ul></li><li><p><code>sort_mode</code> 里面的 <code>packed_additional_fields</code> 的意思是，排序过程对字符串做了“紧凑”处理</p><ul><li>即使 <code>name</code> 字段的定义是 <code>varchar(16)</code>，在排序过程中还是要<strong>按照实际长度来分配空间</strong>的。</li></ul></li></ul><h3 id="rowid算法" tabindex="-1"><a class="header-anchor" href="#rowid算法" aria-hidden="true">#</a> rowid算法</h3><blockquote><p><strong>全字段排序的缺点</strong></p></blockquote><p>如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，</p><p>这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p><p>所以如果单行很大，这个方法效率不够好。</p><blockquote><p><strong>如果 MySQL 认为排序的单行长度太大会怎么做呢？</strong></p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">SET</span> max_length_for_sort_data <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>max_length_for_sort_data</code>：是 MySQL 中专门控制用于排序的行数据的长度的一个参数。</p><ul><li>如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法</li></ul><p>rowid算法不需要将所有的返回字段都加入到<code>sort_buffer</code>里面，只需要加入排序字段和主键</p><p><strong>语句执行流程如下</strong></p><ol><li>初始化 <code>sort_buffer</code>，确定放入两个字段，即 name 和 id；</li><li>从<strong>索引 city 找</strong>到第一个满足 <code>city=‘杭州’</code>条件的<strong>主键 id</strong>，也就是图中的 ID_X；</li><li><strong>到主键 id 索引取出整行</strong>，<strong>取 name、id 这两个字段，存入 <code>sort_buffer</code> 中</strong>；</li><li>从索引 city 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到不满足 <code>city=‘杭州’</code>条件为止，也就是图中的 ID_Y；</li><li>对 <code>sort_buffer</code> 中的数据<strong>按照字段 name 进行排序</strong>；</li><li>遍历排序结果，取前 1000 行，并<strong>按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端</strong>。</li></ol><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231205210004991.png" alt="image-20231205210004991" tabindex="0" loading="lazy"><figcaption>image-20231205210004991</figcaption></figure><blockquote><p>跟全字段排序有什么不同</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231205210328747.png" alt="image-20231205210328747" tabindex="0" loading="lazy"><figcaption>image-20231205210328747</figcaption></figure><ul><li>执行行数多了1000，就是最后根据主键去原表取值</li><li>number_of_tmp_files 变成 10 了，参与排序的行数虽然仍然是 4000 行，但是每一行都变小了，因此需要排序的总数据量就变小了，需要的临时文件也相应地变少了</li></ul><h3 id="如何选择" tabindex="-1"><a class="header-anchor" href="#如何选择" aria-hidden="true">#</a> 如何选择</h3><ul><li>排序内存太小，影响排序效率 ——&gt; 采用rowid算法 <ul><li>排序过程中可以一次排序更多的行</li><li>但是需要重新在原表拿数据</li></ul></li><li>排序内存足够 ——&gt; 优先选择全字段排序 <ul><li>将需要的字段全放进<code>sort_buffer</code>里面</li><li>排序后就可以直接返回，不用再去原表取数据</li></ul></li></ul><blockquote><p>体现了 MySQL 的一个设计思想：<strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></p></blockquote><p>对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。</p><h2 id="单表访问方法" tabindex="-1"><a class="header-anchor" href="#单表访问方法" aria-hidden="true">#</a> 单表访问方法</h2><blockquote><p>条条大路通罗马</p></blockquote><p>MySQL Server 有一个称为查询优化器的模块，一条查询语句进行语法解析之后就会被交给查询优化器来进行优化，优化的结果就是生成一个执行计划</p><p>这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户</p><blockquote><p>示例表</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> single_table <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
    key1 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    key2 <span class="token keyword">INT</span><span class="token punctuation">,</span>
    key3 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    key_part1 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    key_part2 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    key_part3 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    common_field <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">KEY</span> idx_key1 <span class="token punctuation">(</span>key1<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> idx_key2 <span class="token punctuation">(</span>key2<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">KEY</span> idx_key3 <span class="token punctuation">(</span>key3<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">KEY</span> idx_key_part<span class="token punctuation">(</span>key_part1<span class="token punctuation">,</span> key_part2<span class="token punctuation">,</span> key_part3<span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">Engine</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>为<code>id</code> 列建立的聚簇索引。</li><li>为<code>key1</code> 列建立的<code>idx_key1</code> 二级索引。</li><li>为<code>key2</code> 列建立的<code>idx_key2</code> 二级索引，而且该索引是唯一二级索引。</li><li>为<code>key3</code> 列建立的<code>idx_key3</code> 二级索引。</li><li>为<code>key_part1</code> 、<code>key_part2</code> 、<code>key_part3</code> 列建立的<code>idx_key_part</code> 二级索引，这也是一个联合索引</li></ul><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3><blockquote><p>什么是访问方法</p></blockquote><p>SQL只是告诉MySQL，我们需要什么样的数据，也就是告诉MySQL我们的目的是什么，但是没有给它我们要怎么获得，也就是没有给方式</p><p>怎么达到目的，怎么获取到SQL里面提出来的数据，是MySQL自己干的</p><p>MySQL的执行方式大概可以分为两种</p><ul><li><strong>全表扫描</strong><ul><li>把表的每一行记录都扫描一遍，把符合条件的记录加入结果集</li></ul></li><li><strong>索引查询</strong><ul><li>针对主键或者唯一索引的等值查询</li><li>针对普通索引的等值查询</li><li>针对索引列的范围查询</li><li>扫描整个索引（覆盖索引）</li></ul></li></ul><p>MySQL执行语句的方式称为**<u>访问方法</u><strong>或</strong><u>访问类型</u>**</p><h3 id="const" tabindex="-1"><a class="header-anchor" href="#const" aria-hidden="true">#</a> const</h3><p><code>const</code>：<strong>主键</strong>或者<strong>唯一二级索引</strong>与<strong>常数等值比较</strong></p><p>意思是常数级别的，代价可以忽略不计的</p><p>const访问方法只能在主键列或者唯一二级索引和一个常数进行等值比较时才有效</p><blockquote><p>通过主键列定位一条记录</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> single_table <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1438</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231228142439703.png" alt="image-20231228142439703" tabindex="0" loading="lazy"><figcaption>image-20231228142439703</figcaption></figure><blockquote><p>通过唯一二级索引来定位一条记录</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> single_table <span class="token keyword">WHERE</span> key2 <span class="token operator">=</span> <span class="token number">3841</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231228142859670.png" alt="image-20231228142859670" tabindex="0" loading="lazy"><figcaption>image-20231228142859670</figcaption></figure><blockquote><p>如果查询的唯一二级索引值为NULL怎么办？</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> single_table <span class="token keyword">WHERE</span> key2 <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>唯一二级索引列并不限制 NULL 值的数量，所以上述语句可能访问到多条记录，也就是说 上边这个语句不可以使用const 访问方法来执行</p><h3 id="ref" tabindex="-1"><a class="header-anchor" href="#ref" aria-hidden="true">#</a> ref</h3><p><code>ref</code>：<strong>普通二级索引</strong>跟<strong>常数等值比较</strong></p><p>由于普通二级索引并不限制索引列值的唯一性，所以可能找到多条对应的记录</p><p>也就是说使用二级索引来执行查询的代价取决于等值匹配到的二级索引记录条数。</p><p>匹配的记录可以根据索引的区分度（选择性）来判断 $$ 区分度=\\frac{COUNT(DISTINCT(col))}{COUNT(*)} $$ 如果匹配的记录较少（区分度高），则回表的代价还是比较低的，所以MySQL 可能选择使用索引而不是全表扫描的方式来执行查询</p><p>如果匹配的记录较多（区分度低），回表的代价就比较高了，MySQL可能就会选择全表扫描来执行查询</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> single_table <span class="token keyword">WHERE</span> key1 <span class="token operator">=</span> <span class="token string">&#39;abc&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231228143327471.png" alt="image-20231228143327471" tabindex="0" loading="lazy"><figcaption>image-20231228143327471</figcaption></figure><blockquote><p>两种特殊情况</p></blockquote><ul><li><p>二级索引列值为NULL的情况</p><ul><li>不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含NULL 值的数量并不限制，所以用<code>key IS NULL</code> 这种形式的搜索条件最多只能使用ref 的访问方法，而不是const 的访问方法。</li></ul></li><li><p>对于某个包含多个索引列的二级索引来说，只要是最左边的连续索引列是与常数的等值比较就可能采用<code>ref</code>的访问方法</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> single_table <span class="token keyword">WHERE</span> key_part1 <span class="token operator">=</span> <span class="token string">&#39;god like&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> single_table <span class="token keyword">WHERE</span> key_part1 <span class="token operator">=</span> <span class="token string">&#39;god like&#39;</span> <span class="token operator">AND</span> key_part2 <span class="token operator">=</span> <span class="token string">&#39;legendary&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> single_table <span class="token keyword">WHERE</span> key_part1 <span class="token operator">=</span> <span class="token string">&#39;god like&#39;</span> <span class="token operator">AND</span> key_part2 <span class="token operator">=</span> <span class="token string">&#39;legendary&#39;</span><span class="token operator">AND</span> key_part3 <span class="token operator">=</span> <span class="token string">&#39;penta kill&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>如果最左边的连续索引列并不全部是等值比较的话，它的访问方法就不能称为ref 了</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> single_table <span class="token keyword">WHERE</span> key_part1 <span class="token operator">=</span> <span class="token string">&#39;god like&#39;</span> <span class="token operator">AND</span> key_part2 <span class="token operator">&gt;</span> <span class="token string">&#39;legendary&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul><h3 id="eq-ref" tabindex="-1"><a class="header-anchor" href="#eq-ref" aria-hidden="true">#</a> eq_ref</h3><p><code>eq_ref</code>：连接查询中对被驱动表使用主键值或者唯一二级索引列的值进行等值查找的查询执行方式</p><h3 id="ref-or-null" tabindex="-1"><a class="header-anchor" href="#ref-or-null" aria-hidden="true">#</a> ref_or_null</h3><p><code>ref_or_null</code>：使用二级索引跟某个常数做等值比较并同时查询出该列的NULL值</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> single_demo <span class="token keyword">WHERE</span> key1 <span class="token operator">=</span> <span class="token string">&#39;abc&#39;</span> <span class="token operator">OR</span> key1 <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231228144234286.png" alt="image-20231228144234286" tabindex="0" loading="lazy"><figcaption>image-20231228144234286</figcaption></figure><ol><li>先分别从<code>idx_key1</code> 索引对应的B+ 树中找出<code>key1 IS NULL</code> 和<code>key1 = &#39;abc&#39;</code> 的两个连续的记录范围</li><li>然后根据这些二级索引记录中的id 值再回表查找完整的用户记录。</li></ol><h3 id="range" tabindex="-1"><a class="header-anchor" href="#range" aria-hidden="true">#</a> range</h3><p><code>range</code>：利用索引进行范围匹配的访问方法（可以是聚簇索引也可以是二级索引）</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> single_table <span class="token keyword">WHERE</span> key2 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1438</span><span class="token punctuation">,</span> <span class="token number">6328</span><span class="token punctuation">)</span> <span class="token operator">OR</span> <span class="token punctuation">(</span>key2 <span class="token operator">&gt;=</span> <span class="token number">38</span> <span class="token operator">AND</span> key2 <span class="token operator">&lt;=</span> <span class="token number">79</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231228144721852.png" alt="image-20231228144721852" tabindex="0" loading="lazy"><figcaption>image-20231228144721852</figcaption></figure><p><code>key2</code>的列值只要匹配3个范围中的一个就算匹配成功</p><ul><li>范围1： key2 = 1438</li><li>范围2： key2 = 6328</li><li>范围3： key2 ∈ [38, 79] ，注意这里是闭区间。</li></ul><p>范围1 和 范围2 被称为单点区间</p><p>范围3 被称为连续范围区间</p><blockquote><p>明确range访问方法使用的范围区间</p></blockquote><p>只要索引列和常数使用<code>=、&lt;=&gt;、IN 、NOT IN 、IS NULL 、IS NOT NULL、&lt; 、&gt;= 、&lt;= 、BETWEEN 、!=、&lt;&gt;、LIKE </code>操作符连接起来，就可以产生一个所谓的区间</p><h3 id="index" tabindex="-1"><a class="header-anchor" href="#index" aria-hidden="true">#</a> index</h3><p><code>index</code>：覆盖索引，直接在二级索引中就能找到需要的记录，不进行回表操作</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> key_part1<span class="token punctuation">,</span> key_part2<span class="token punctuation">,</span> key_part3 <span class="token keyword">FROM</span> single_table <span class="token keyword">WHERE</span> key_part2 <span class="token operator">=</span> <span class="token string">&#39;abc&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="all" tabindex="-1"><a class="header-anchor" href="#all" aria-hidden="true">#</a> all</h3><p><code>all</code>：全表扫描</p><p>直接扫描聚簇索引叶子节点组成的双向链表</p><h2 id="join底层原理" tabindex="-1"><a class="header-anchor" href="#join底层原理" aria-hidden="true">#</a> JOIN底层原理</h2><h3 id="连接简介" tabindex="-1"><a class="header-anchor" href="#连接简介" aria-hidden="true">#</a> 连接简介</h3><h4 id="连接的本质" tabindex="-1"><a class="header-anchor" href="#连接的本质" aria-hidden="true">#</a> 连接的本质</h4><p>连接的本质就是把各个连接表中的记录都取出来一次匹配的组合加入结果集中返回给用户</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231205214514845.png" alt="image-20231205214514845" tabindex="0" loading="lazy"><figcaption>image-20231205214514845</figcaption></figure><p>这个过程称为连接查询，连接查询的结果集称为<strong>笛卡尔积</strong></p><h4 id="连接的过程" tabindex="-1"><a class="header-anchor" href="#连接的过程" aria-hidden="true">#</a> 连接的过程</h4><p>连接查询中的过滤条件：</p><ul><li>涉及单表的条件</li><li>涉及两表的条件</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> t1<span class="token punctuation">,</span> t2
<span class="token keyword">WHERE</span> t1<span class="token punctuation">.</span>m1 <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">AND</span> t1<span class="token punctuation">.</span>m1 <span class="token operator">=</span> t2<span class="token punctuation">.</span>m2 <span class="token operator">AND</span> t2<span class="token punctuation">.</span>n2 <span class="token operator">&lt;</span> <span class="token string">&#39;d&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code> t1.m1 &gt; 1</code></li><li><code>t1.m1 = t2.m2</code></li><li><code>t2.n2 &lt; &#39;d&#39;</code></li></ul><p><strong>执行过程：</strong></p><ol><li>确定第一个需要查询的表，称为<u><strong>驱动表</strong></u>，在该表中查询满足条件的所有记录 <ul><li>若对t1表没有条件，即没有单独面向t1表的条件</li><li>那么这个步骤返回的是整个t1表的记录</li></ul></li></ol><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231205215232263.png" alt="image-20231205215232263" tabindex="0" loading="lazy"><figcaption>image-20231205215232263</figcaption></figure><ol start="2"><li><p>针对上一步骤中从驱动表产生的结果集中的每条记录，分别取t2表中查找匹配的记录</p><ul><li>因为是根据驱动表中的数据去找，所以t2表也被称为<u><strong>被驱动表</strong></u></li></ul><ul><li>当<code>t1.m1 = 2</code>时，过滤条件<code>t1.m1 = t2.m2</code>就变成了<code>t2.m2 = 2</code><ul><li>所以此时t2表相当于有了<code>t2.m2 = 2</code>和<code>t2.n2 &lt; &#39;d&#39;</code>两个过滤条件，用这两个过滤条件去t2表中执行单表查询</li></ul></li><li>当<code>t1.m1 = 3</code>时，过滤条件<code>t1.m1 = t2.m2</code>就变成了<code>t2.m2 = 3</code><ul><li>所以此时t2表相当于有了<code>t2.m2 = 3</code>和<code>t2.n2 &lt; &#39;d&#39;</code>两个过滤条件，用这两个过滤条件去t2表中执行单表查询</li></ul></li></ul></li></ol><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231205215649933.png" alt="image-20231205215649933" tabindex="0" loading="lazy"><figcaption>image-20231205215649933</figcaption></figure><p>如果将<code>t1.m1 &gt; 1</code>条件去掉，那么从t1表中查到的数据就有3条，就需要查询3次t2表了</p><p>两表连接查询中，驱动表只需要访问一次，被驱动表可以访问多次</p><h4 id="内连接和外连接" tabindex="-1"><a class="header-anchor" href="#内连接和外连接" aria-hidden="true">#</a> 内连接和外连接</h4><blockquote><p>定义</p></blockquote><p><strong>内连接</strong></p><ul><li><strong>驱动表中的记录在被驱动表中找不到匹配的记录，该记录就不会被加入到最后的结果集</strong>，上边的连接过程就是内连接</li></ul><p><strong>外连接</strong></p><ul><li><p>驱动表中的记录<strong>即使在被驱动表中没有匹配的记录，也要加入到结果集</strong></p></li><li><p>根据选取驱动表的不同，外连接可以细分为2种</p><ul><li>左外连接：选取左侧的表为驱动表</li><li>右外连接：选取右侧的表为驱动表</li></ul></li></ul><blockquote><p>有时候并不需要将驱动表的全部记录都加入到最后的结果集</p></blockquote><p>不同地方的过滤条件</p><ul><li><strong>WHERE子句的过滤条件</strong><ul><li>凡是不符合WHERE过滤条件的记录都不会加入到最后的结果集</li></ul></li><li><strong>ON子句的过滤条件</strong><ul><li><strong>对于外连接的驱动表记录</strong>来说，<strong>如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录</strong>，该记录还是会被加到结果集中，对应的被驱动表记录的各个字段<strong>使用NULL值填充</strong></li><li>ON子句是专门为了外连接提出的，如果将ON子句放到内连接中，MySQL会将它和WHERE子句一样对待，<strong>内连接中的WHERE子句和ON子句是等价的</strong></li><li>一般情况下，我们将只涉及单表的过滤条件放到WHERE子句中，把涉及两表的过滤条件放到ON子句中 <ul><li>放到ON子句中的两表过滤条件称为**<u>连接条件</u>**</li></ul></li></ul></li></ul><h5 id="左连接" tabindex="-1"><a class="header-anchor" href="#左连接" aria-hidden="true">#</a> 左连接</h5><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> t2 <span class="token keyword">ON</span> 连接条件 <span class="token punctuation">[</span><span class="token keyword">WHERE</span> 过滤条件<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>放在左边的表称为外表或者驱动表 <ul><li>t1就是外表或者驱动表</li></ul></li><li>放在右边的表称为内表或者被驱动表 <ul><li>t2就是外表或者驱动表</li></ul></li><li>对于左右连接，必须使用ON子句来指出连接条件</li></ul><h5 id="右连接" tabindex="-1"><a class="header-anchor" href="#右连接" aria-hidden="true">#</a> 右连接</h5><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> t2 <span class="token keyword">ON</span> 连接条件 <span class="token punctuation">[</span><span class="token keyword">WHERE</span> 过滤条件<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>用法跟左连接一样，只不过右表变成外表或驱动表</li></ul><h5 id="内连接" tabindex="-1"><a class="header-anchor" href="#内连接" aria-hidden="true">#</a> 内连接</h5><blockquote><p>内连接和外连接的根本区别</p></blockquote><p><strong><u>在驱动表中的记录不符合ON子句连接条件的时候会不会把记录添加到最后的结果集</u></strong></p><ul><li><p>内连接没有强制要求写明ON子句</p></li><li><p>对于内连接来说，凡是不符合ON子句或WHERE子句的条件的记录都会被过滤，其实就相当于从笛卡尔积中将不符合条件的记录筛走</p></li><li><p>对于内连接来说，驱动表和被驱动表是可以相互转化的，不影响最终的结果</p></li></ul><h3 id="连接原理" tabindex="-1"><a class="header-anchor" href="#连接原理" aria-hidden="true">#</a> 连接原理</h3><p>MySQL 8.0 版本支持两种 JOIN 算法用于表之间的关联：</p><ul><li>Nested Loop Join</li><li>Hash Join</li></ul><h4 id="nested-loop-join" tabindex="-1"><a class="header-anchor" href="#nested-loop-join" aria-hidden="true">#</a> Nested Loop Join</h4><blockquote><p><strong>嵌套循环连接</strong></p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231205222915791.png" alt="image-20231205222915791" tabindex="0" loading="lazy"><figcaption>image-20231205222915791</figcaption></figure><ul><li><p>选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行驱动表的单表查询</p></li><li><p>对查询驱动表得到的结果集中的每一条记录，都分别到被驱动表中查找匹配的记录</p></li><li><p>如果有3个表进行连接的话，步骤2中得到的结果集就是新的驱动表，第3个表成为被驱动表</p></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>for(row in t1){
	for(row in t2){
		for(row in t3){
			if(row 符合条件){
				加入结果集
			}
		}
	}
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这个过程就是嵌套的循环，驱动表只访问一次，但是被驱动表可能被多次访问</li><li>访问次数取决于驱动表执行单表查询后结果集中记录条数</li><li>这是最简单，也是最笨拙的连接查询算法</li></ul><h5 id="index-nested-loop-join" tabindex="-1"><a class="header-anchor" href="#index-nested-loop-join" aria-hidden="true">#</a> Index Nested-Loop Join</h5><blockquote><p><strong>使用索引加快连接速度</strong></p></blockquote><blockquote><p>一个简单的例子</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 straight_join t2 <span class="token keyword">on</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span>a<span class="token operator">=</span>t2<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231228234651414.png" alt="image-20231228234651414" tabindex="0" loading="lazy"><figcaption>image-20231228234651414</figcaption></figure><ol><li>从表 t1 中读入一行数据 R；</li><li>从数据行 R 中，取出 a 字段到表 t2 里去查找；</li><li>取出表 t2 中满足条件的行，跟 R 组成一行，作为结果集的一部分；</li><li>重复执行步骤 1 到 3，直到表 t1 的末尾循环结束。</li></ol><p>在这个流程中</p><ol><li>对驱动表 t1 做了全表扫描，这个过程需要扫描 100 行；</li><li>而对于每一行 R，根据 a 字段去表 t2 查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描 100 行；</li><li>所以，整个执行流程，总扫描行数是 200。</li></ol><blockquote><p>一个稍微复杂的例子</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1<span class="token punctuation">,</span> t2 <span class="token keyword">WHERE</span> t1<span class="token punctuation">.</span>m1 <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">AND</span> t1<span class="token punctuation">.</span>m1 <span class="token operator">=</span> t2<span class="token punctuation">.</span>m2 <span class="token operator">AND</span> t2<span class="token punctuation">.</span>n2 <span class="token operator">&lt;</span> <span class="token string">&#39;d&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>在m2 列上建立索引，因为对m2 列的条件是等值查找，比如<code>t2.m2 = 2 、t2.m2 = 3</code> 等，所以可能使用到<code>ref</code> 的访问方法 <ul><li>假设使用ref 的访问方法去执行对t2 表的查询的话，需要回表之后再判断t2.n2 &lt; d 这个条件是否成立。</li><li>假设m2 列是t2 表的主键或者唯一二级索引列，那么使用<code>t2.m2 = 常数值</code>这样的条件从t2 表中查找记录的过程的代价就是常数级别的。</li><li>我们知道在单表中使用主键值或者唯一二级索引列的值进行等值查找的方式称之为<code>const</code> ，而MySQL把在连接查询中对被驱动表使用主键值或者唯一二级索引列的值进行等值查找的查询执行方式称之为： <code>eq_ref</code> 。</li></ul></li><li>在n2 列上建立索引，涉及到的条件是<code>t2.n2 &lt; &#39;d&#39;</code> ，可能用到<code>range</code> 的访问方法，假设使用<code>range</code> 的访问方法对t2 表的查询的话，需要回表之后再判断在m2 列上的条件是否成立。</li></ul><h5 id="block-nested-loop-join" tabindex="-1"><a class="header-anchor" href="#block-nested-loop-join" aria-hidden="true">#</a> Block Nested-Loop Join</h5><blockquote><p><strong>基于块的嵌套循环连接</strong></p></blockquote><p>扫描一个表的过程其实是先把这个表从磁盘上加载到内存，然后从内存中比较匹配条件是否满足</p><blockquote><p>存在什么问题？</p></blockquote><p>实际生产中表的数据是非常庞大的，内存可能无法承载表中的所有记录</p><p>而嵌套循环连接的两表连接过程中，被驱动表是需要被访问很多次的</p><p>如果这个被驱动表中的数据特别多，而且不能使用索引进行访问，那就相当于要从磁盘读取好几个表，这个I/O代价就非常大了</p><blockquote><p>嵌套循环连接的过程</p></blockquote><p>当被驱动表中的数据非常多时，每次访问被驱动表，被驱动表的记录会被加载到内存中，在内存中的每一条记录只会和驱动表结果集的一条记录做匹配，之后就会被从内存中清除掉。</p><p>然后再从驱动表结果集中拿出另一条记录，再一次把被驱动表的记录加载到内存中一遍，周而复始</p><p>驱动表结果集中有多少条记录，就得把被驱动表从磁盘上加载到内存中多少次。</p><blockquote><p><strong>解决方案：在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配</strong></p></blockquote><p><strong>join buffer</strong></p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231228160322151.png" alt="image-20231228160322151" tabindex="0" loading="lazy"><figcaption>image-20231228160322151</figcaption></figure><ol><li>join buffer 就是执行连接查询前申请的一块固定大小的内存</li><li>先把若干条驱动表结果集中的记录装在这个join buffer 中</li><li>然后开始扫描被驱动表，每一条被驱动表的记录一次性和join buffer 中的多条驱动表记录做匹配</li><li>因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的I/O 代价。</li></ol><p>最好的情况就是 join buffer 足够大，能够容纳整个驱动表结果集中的所有记录，这样只需要访问一次驱动表就能完成连接操作了</p><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231228224925473.png" alt="image-20231228224925473" tabindex="0" loading="lazy"><figcaption>image-20231228224925473</figcaption></figure><blockquote><p>如果内存不够大怎么办</p></blockquote><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231228225120806.png" alt="image-20231228225120806" tabindex="0" loading="lazy"><figcaption>image-20231228225120806</figcaption></figure><ol><li>扫描表 t1，顺序读取数据行放入 <code>join_buffer</code> 中，放完第 88 行 <code>join_buffer</code> 满了，继续第 2 步；</li><li>扫描表 t2，把 t2 中的每一行取出来，跟 <code>join_buffer</code> 中的数据做对比，满足 join 条件的，作为结果集的一部分返回；</li><li>清空 <code>join_buffer</code>；</li><li>继续扫描表 t1，顺序读取最后的 12 行数据放入 <code>join_buffer</code> 中，继续执行第 2 步。</li></ol><p>这种加入了 join buffer 的嵌套循环连接算法称为基于块的嵌套连接（Block Nested-Loop Join）算法</p><p>需要注意的是，驱动表的记录并不是所有列都会被放到 <code>join buffer</code> 中</p><p>只有查询列表中的列和过滤条件中的列才会被放到 <code>join buffer</code> 中</p><p>所以再次提醒我们，最好不要把 * 作为查询列表，只需要把我们关心的列放到查询列表就好了，这样还可以在join buffer 中放置更多的记录</p><h5 id="两种嵌套循环算法的比较" tabindex="-1"><a class="header-anchor" href="#两种嵌套循环算法的比较" aria-hidden="true">#</a> 两种嵌套循环算法的比较</h5><blockquote><p><strong>能不能用JOIN语句</strong></p></blockquote><ol><li>如果可以使用 <code>Index Nested-Loop Join</code> 算法，也就是说可以用上被驱动表上的索引，其实是没问题的；</li><li>如果使用 <code>Block Nested-Loop Join</code> 算法，扫描行数就会过多。尤其是在大表上的 join 操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种 join 尽量不要用。</li></ol><p><strong>也就是说要使用JOIN语句的时候需要给JOIN语句的条件建索引</strong></p><blockquote><p><strong>如果要使用 join，应该选择大表做驱动表还是选择小表做驱动表？</strong></p></blockquote><ol><li>如果是 <code>Index Nested-Loop Join</code> 算法，应该选择小表做驱动表；</li><li>如果是 <code>Block Nested-Loop Join</code> 算法： <ul><li>在 <code>join_buffer_size</code> 足够大的时候，是一样的；</li><li>在 <code>join_buffer_size</code> 不够大的时候（这种情况更常见），应该选择小表做驱动表。</li></ul></li></ol><p><strong>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤</strong></p><p><strong>过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</strong></p><h4 id="hash-join" tabindex="-1"><a class="header-anchor" href="#hash-join" aria-hidden="true">#</a> Hash Join</h4><p>HashJoin用于两张表之间连接条件没有索引的情况</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>foreach row r in R with matching condition:
    create hash table ht on r

foreach row s in S with matching condition:
    search s in hash table ht:
    if (found)
        send to client
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>扫描驱动表的时候创建一张哈希表</li><li>扫描第二张表的时候在哈希表中搜索每条关联的记录，找到就返回</li></ol><p>HashJoin选择驱动表和嵌套循环算法大致一样，都是较小的表作为驱动表</p><p>如果驱动表比较大，创建的哈希表超过了内存大小，MySQL会自动把结果转存在磁盘</p><h2 id="sql顺序" tabindex="-1"><a class="header-anchor" href="#sql顺序" aria-hidden="true">#</a> SQL顺序</h2><h3 id="sql编写顺序" tabindex="-1"><a class="header-anchor" href="#sql编写顺序" aria-hidden="true">#</a> SQL编写顺序</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token comment">-- 普通查询，聚合函数，DISTINCT</span>
<span class="token keyword">FROM</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">LEFT</span> <span class="token operator">/</span> <span class="token keyword">RIGHT</span><span class="token punctuation">)</span> <span class="token keyword">JOIN</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">ON</span>  <span class="token comment">-- 多表连接条件</span>
<span class="token keyword">WHERE</span>  <span class="token comment">-- 过滤行</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">-- 可以对多个字段进行嵌套分组</span>
<span class="token keyword">HAVING</span>  <span class="token comment">-- 过滤分组</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token keyword">ASC</span> <span class="token operator">/</span> <span class="token keyword">DESC</span><span class="token punctuation">)</span> <span class="token comment">-- 可以对多个字段进行排序</span>
<span class="token keyword">LIMIT</span> <span class="token keyword">offset</span><span class="token punctuation">,</span> size 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="sql执行顺序" tabindex="-1"><a class="header-anchor" href="#sql执行顺序" aria-hidden="true">#</a> SQL执行顺序</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span> <span class="token keyword">SELECT</span> 
<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> DISTICNCT <span class="token keyword">column</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> AGG_FUNC<span class="token punctuation">(</span><span class="token keyword">column</span> <span class="token operator">or</span> expiression<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> left_table
    <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">JOIN</span> right_table
    <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">ON</span> tablename<span class="token punctuation">.</span><span class="token keyword">column</span> <span class="token operator">=</span> 
        other_tablename<span class="token punctuation">.</span><span class="token keyword">column</span>
<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">WHERE</span> constraint_expiression
<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token keyword">column</span>
<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token keyword">WITH</span> CUBE<span class="token operator">|</span>ROLLUP
<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">HAVING</span> constraint_expiression
<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token keyword">column</span> <span class="token keyword">ASC</span><span class="token operator">|</span><span class="token keyword">DESC</span>
<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token keyword">LIMIT</span> count <span class="token keyword">OFFSET</span> count<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="http://lgy-markdown-img.oss-cn-guangzhou.aliyuncs.com/image/image-20231206124542286.png" alt="image-20231206124542286" tabindex="0" loading="lazy"><figcaption>image-20231206124542286</figcaption></figure><blockquote><p>每次执行完一个子句，都会在内部生成一个虚拟表</p></blockquote><ol><li>执行FROM和JOIN来确定表之间的关系，得到初步数据</li><li>执行WHERE对数据进行筛选</li><li>执行GORUP BY对筛选后的数据进行分组</li><li>各组分别执行聚合函数，计算出结果新增一列加进结果集中</li><li>对聚合函数的结果使用WITH指定的选项进一步聚合</li><li>各组分别执行HAVING对结果集进行筛选</li><li>从筛选后的结果中取出需要SELECT的字段</li><li>如果有DISTINCT，对SELECT出来的字段去重</li><li>将最终得出的结果按照ORDER BY的顺序排序</li><li>返回LIMIT限制的记录</li></ol><table><thead><tr><th>顺序</th><th>语法</th><th>作用</th></tr></thead><tbody><tr><td>1</td><td>FROM</td><td>对子句中的所有表执行笛卡尔积</td></tr><tr><td>2</td><td>ON</td><td>用ON条件筛选出连接表中符合条件的记录</td></tr><tr><td>3</td><td>JOIN</td><td>根据连接的形式选择保留表（驱动表），将保留表的数据加入结果集</td></tr><tr><td>4</td><td>WHERE</td><td>对连接完的结果集进行筛选，将符合条件记录的留下</td></tr><tr><td>5</td><td>GROUP BY</td><td>根据指定的列队结果集进行分组</td></tr><tr><td>6</td><td>聚合</td><td>每个组分别计算组内的聚合函数值，将其作为新的列放入自己分组的结果中</td></tr><tr><td>7</td><td>WITH</td><td>每个分组分别计算ROLLUP和CUBE参数带来的额外聚合列，并加入结果集</td></tr><tr><td>8</td><td>HAVING</td><td>根据条件筛选出每个分组中符合条件的记录</td></tr><tr><td>9</td><td>SELECT</td><td>从结果集中取出要返回的列</td></tr><tr><td>10</td><td>DISTINCT</td><td>去重</td></tr><tr><td>11</td><td>ORDER BY</td><td>根据规则对结果集排序</td></tr><tr><td>12</td><td>LIMIT</td><td>选择指定行数返回</td></tr></tbody></table><ol><li><p><strong>FROM执行笛卡尔积</strong></p><ul><li><p>对FROM子句中的前2个表执行笛卡尔积(交叉连接)，生成虚拟表VT1(virtual table)，获取不同数据源的数据集</p></li><li><p>FROM子句的执行顺序为从后往前，从右往左</p></li><li><p>FROM子句中写在最后的表(基础表)，将被最先处理，及最后的表为驱动表</p></li><li><p>当FROM子句中包含多个表的情况下，需要<strong>选择数据最少的表作为基础表</strong></p></li></ul></li></ol><blockquote><p><strong>为什么使用数据最少的表作为基础表能够提高查询性能?</strong></p><p>因为基础表需要进行全表扫描，后续的表可以使用索引，所以如果基础表存在索引，MySQL可能会找一张没有索引的来当基础表</p></blockquote><ol start="2"><li><p><strong>ON过滤器</strong></p><ul><li>ON中的逻辑表达式将应用到虚拟表VT1中的各个行</li><li>筛选出满足on逻辑表达式的行，生成虚拟表VT2</li></ul></li><li><p><strong>JOIN添加外部行</strong></p><ul><li>在保留表中不匹配的行将作为外部行添加到虚拟表VT2中，其中属于非保留表的字段被赋予NULL值，生成VT3。</li></ul><ul><li><p>LEFT OUTER JOIN 把左表记为保留表</p></li><li><p>RIGHT OUTER JOIN 把右表记为保留表</p></li><li><p>FULL OUTER JOIN 把左右表都作为保留表</p></li><li><p>INNER JOIN 左右表都不作为保留表</p></li></ul></li></ol><blockquote><p>如果FROM子句包含两个以上的表，则对上一个连接生成的结果表和下一个表重复执行步骤1~3，直到处理完所有的表为止，例如：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> student s
<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> category c <span class="token keyword">USING</span> <span class="token punctuation">(</span>category_id<span class="token punctuation">)</span>
<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> gaokao g <span class="token keyword">USING</span> <span class="token punctuation">(</span>stu_id<span class="token punctuation">)</span>
<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> division_result d <span class="token keyword">USING</span> <span class="token punctuation">(</span>stu_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><ol start="4"><li><p><strong>WHERE过滤器</strong></p><ul><li>根据指定的条件，从VT3中筛选满足条件的数据插入虚拟表VT4</li></ul><ul><li>由于数据还没有分组，因此现在还不能在WHERE过滤器中使用聚合函数对分组统计进行过滤</li><li>由于还没有进行SELECT操作，所以不能使用SELECT中定义的列别名，只能使用FROM中定义的表别名</li></ul></li><li><p><strong>GROUP BY分组</strong></p><ul><li>根据分组列表，将分组列表的值相同的记录归到一组，形成一个新的虚拟表VT5</li></ul><ul><li>从这一步开始，后面的语句都可以使用SELECT中的别名</li></ul></li><li><p><strong>AGG_FUNC计算聚合函数</strong></p><ul><li>聚集函数计算从列中取得的值，返回一个单一的值</li><li>AVG：返回平均值</li><li>COUNT：返回行数</li><li>FIRST：返回第一个记录的值</li><li>LAST：返回最后一个记录的值</li><li>MAX： 返回最大值</li><li>MIN：返回最小值</li><li>SUM： 返回总和</li></ul></li><li><p><strong>WITH应用ROLLUP或CUBE</strong></p><ul><li>对虚拟表 VT5应用ROLLUP或CUBE选项，生成虚拟表 VT6。</li><li>CUBE 和 ROLLUP 区别如下： <ul><li>CUBE 生成的结果数据集显示了所选列中值的所有组合的聚合。</li><li>ROLLUP 生成的结果数据集显示了所选列中值的某一层次结构的聚合</li></ul></li></ul></li><li><p><strong>HAVING过滤器</strong></p><ul><li>对虚拟表VT6根据指定的条件对数据进行筛选，把满足的数据插入虚拟表VT7</li><li>HAVING 语句在SQL中的主要作用与WHERE语句作用是相同的，但是HAVING是过滤聚合值</li><li>WHERE 关键字无法与聚合函数一起使用，HAVING子句主要和GROUP BY子句配合使用。</li></ul></li><li><p><strong>SELECT 选出指定列</strong></p><ul><li>将VT7中在SELECT 中出现的列筛选出来，并对字段进行处理，计算SELECT 子句中的表达式，产生虚拟表VT8</li></ul></li><li><p><strong>DISTINCT行去重</strong></p><ul><li>删除VT8中重复的行，生成虚拟表VT9</li></ul></li><li><p><strong>ORDER BY</strong>排列</p><ul><li><p>对VT9中的行按ORDER BY中的指定的列进行排序，生成游标VC10，注意不是虚拟表。</p></li><li><p>因此使用order by子句查询不能应用于表达式。同时order by子句的执行顺序为从左到右排序，是非常消耗资源的</p></li></ul></li><li><p><strong>LIMIT/OFFSET指定返回行</strong></p><ul><li>从VC10的开始处选择指定数量行，生成虚拟表VT11，并返回调用者</li></ul></li></ol><hr>`,207),l=[t];function i(p,c){return s(),a("div",null,l)}const u=n(o,[["render",i],["__file","SQL原理.html.vue"]]);export{u as default};
